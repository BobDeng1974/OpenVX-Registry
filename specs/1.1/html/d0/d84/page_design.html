<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>The OpenVX Specification: Design Overview</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../OpenVX_Color_119x55.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">The OpenVX Specification
   &#160;<span id="projectnumber">2b213f9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d0/d84/page_design.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Design Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_overview"></a>
Software Landscape</h1>
<p>OpenVX is intended to be used either directly by applications or as the acceleration layer for higher-level vision frameworks, engines or platform APIs.</p>
<p><div class="dotgraph">
<img src="../../dot_overview.png" alt="dot_overview.png" border="0" usemap="#dot_overview.map"/>
<map name="dot_overview.map" id="dot_overview.map"><area shape="rect" id="node4" href="http://www.khronos.org/openvx/" title="OpenVX" alt="" coords="106,110,153,136"/></map>
<div class="caption">
OpenVX Usage Overview</div>
</div>
</p>
<h1><a class="anchor" id="sec_design_objective"></a>
Design Objectives</h1>
<p>OpenVX is designed as a framework of standardized computer vision functions able to run on a wide variety of platforms and potentially to be accelerated by a vendor's implementation on that platform. OpenVX can improve the performance and efficiency of vision applications by providing an abstraction for commonly-used vision functions and an abstraction for aggregations of functions (a &ldquo;graph&rdquo;), thereby providing the implementer the opportunity to minimize the run-time overhead.</p>
<p>The functions in OpenVX are intended to cover common functionality required by many vision applications.</p>
<h2><a class="anchor" id="sec_sub_optimizations"></a>
Hardware Optimizations</h2>
<p>This specification makes no statements as to which acceleration methodology or techniques may be used in its implementation. Vendors may choose any number of implementation methods such as parallelism and/or specialized hardware offload techniques.</p>
<p>This specification also makes no statement or requirements on a &ldquo;level of performance&rdquo; as this may vary significantly across platforms and use cases.</p>
<h2><a class="anchor" id="sec_design_hw_limitations"></a>
Hardware Limitations</h2>
<p>The OpenVX focuses on vision functions that can be significantly accelerated by diverse hardware. Future versions of this specification may adopt additional vision functions into the core standard when hardware acceleration for those functions becomes practical.</p>
<h1><a class="anchor" id="sec_assumptions"></a>
Assumptions</h1>
<h2><a class="anchor" id="sec_portability"></a>
Portability</h2>
<p>OpenVX has been designed to maximize functional and performance portability wherever possible, while recognizing that the API is intended to be used on a wide diversity of devices with specific constraints and properties. Tradeoffs are made for portability where possible: for example, portable Graphs constructed using this API should work on any OpenVX implementation and return similar results within the precision bounds defined by the OpenVX conformance tests.</p>
<h2><a class="anchor" id="sec_opaque"></a>
Opaqueness</h2>
<p>OpenVX is intended to address a very broad range of devices and platforms, from deeply embedded systems to desktop machines and distributed computing architectures. The OpenVX API addresses this range of possible implementations without forcing hardware-specific requirements onto any particular implementation via the use of <em>opaque</em> objects for most program data.</p>
<p>All data, except client-facing structures, are opaque and hidden behind a reference that may be as thin or thick as an implementation needs. Each implementation provides the standardized interfaces for accessing data that takes care of specialized hardware, platform, or allocation requirements. Memory that is <em>imported</em> or <em>shared</em> from other APIs is not subsumed by OpenVX and is still maintained and accessible by the originator.</p>
<p>OpenVX does not dictate any requirements on memory allocation methods or the layout of opaque memory objects and it does not dictate byte packing or alignment for structures on architectures.</p>
<h1><a class="anchor" id="sec_framework"></a>
Object-Oriented Behaviors</h1>
<p>OpenVX objects are both strongly typed at compile-time for safety critical applications and are strongly typed at run-time for dynamic applications. Each object has its typedef'd type and its associated enumerated value in the <code><a class="el" href="../../d4/dae/group__group__basic__features.html#ga44aa67e15168e5912a0800090a120be6">vx_type_e</a></code> list. Any object may be down-cast to a <code><a class="el" href="../../dd/d90/group__group__reference.html#ga1a95c3bf180e49d4d1ecd64cb35f45a3">vx_reference</a></code> safely to be used in functions that require this, specifically <code><a class="el" href="../../dd/d90/group__group__reference.html#ga90f1230bf615e3e2d7e618cab1e2d6dc">vxQueryReference</a></code>, which can be used to get the <code><a class="el" href="../../d4/dae/group__group__basic__features.html#ga44aa67e15168e5912a0800090a120be6">vx_type_e</a></code> value using an <code><a class="el" href="../../d4/dae/group__group__basic__features.html#ga73d23cb932d31a69f44182054a987c85">vx_enum</a></code>.</p>
<h1><a class="anchor" id="sec_framework_objects"></a>
OpenVX Framework Objects</h1>
<p>This specification defines the following OpenVX framework objects.</p>
<ul>
<li><a class="el" href="../../d1/dc3/group__group__context.html">Object: Context</a> - The OpenVX context is the object domain for all OpenVX objects. All data objects <em>live</em> in the context as well as all framework objects. The OpenVX context keeps reference counts on all objects and must do garbage collection during its deconstruction to free lost references. While multiple clients may connect to the OpenVX context, all data are private in that the references that refer to data objects are given only to the creating party. The results of calling an OpenVX function on data objects created in different contexts are undefined.</li>
<li><a class="el" href="../../d7/dcd/group__group__kernel.html">Object: Kernel</a> - A Kernel in OpenVX is the abstract representation of a computer vision function, such as a &ldquo;Sobel Gradient&rdquo; or &ldquo;Lucas Kanade Feature Tracking&rdquo;. A vision function may implement many similar or identical features from other functions, but it is still considered a single, unique kernel as long as it is named by the same string and enumeration and conforms to the results specified by OpenVX. Kernels are similar to function signatures in this regard.</li>
<li><a class="el" href="../../d3/da9/group__group__parameter.html">Object: Parameter</a> - An abstract input, output, or bidirectional data object passed to a computer vision function. This object contains the signature of that parameter's usage from the kernel description. This information includes: <ul>
<li><em>Signature Index</em> - The numbered index of the parameter in the signature. </li>
<li><em>Object Type</em> - e.g. <code><a class="el" href="../../d4/dae/group__group__basic__features.html#gga44aa67e15168e5912a0800090a120be6ae6f1e4302792e3bce711e92024a8da1e">VX_TYPE_IMAGE</a></code>, or <code><a class="el" href="../../d4/dae/group__group__basic__features.html#gga44aa67e15168e5912a0800090a120be6a5edffe1547cd05513c7b079eed37d2b5">VX_TYPE_ARRAY</a></code>, or some other object type from <code><a class="el" href="../../d4/dae/group__group__basic__features.html#ga44aa67e15168e5912a0800090a120be6">vx_type_e</a></code>. </li>
<li><em>Usage Model</em> - e.g. <code><a class="el" href="../../d3/da9/group__group__parameter.html#gga4a11207b7fcf1135615b4ae11624f9edaf035abd15d4ce563ddb52e0ae68a9585">VX_INPUT</a></code>, <code><a class="el" href="../../d3/da9/group__group__parameter.html#gga4a11207b7fcf1135615b4ae11624f9eda866b82225216ce016a62aa0a7b356ebd">VX_OUTPUT</a></code>, or <code><a class="el" href="../../d3/da9/group__group__parameter.html#gga4a11207b7fcf1135615b4ae11624f9edaa2abfee3a4bfec8ce3faac784a815cda">VX_BIDIRECTIONAL</a></code>. </li>
<li><em>Presence State</em> - e.g. <code><a class="el" href="../../d3/da9/group__group__parameter.html#ggadee3d0820c9f76afc5273e4c1b7f3b04a9a6a5c9c3e554763e49a4cade5294a10">VX_PARAMETER_STATE_REQUIRED</a></code>, or <code><a class="el" href="../../d3/da9/group__group__parameter.html#ggadee3d0820c9f76afc5273e4c1b7f3b04a7368c3309cc3038cbaaa558466d6f551">VX_PARAMETER_STATE_OPTIONAL</a></code>.</li>
</ul>
</li>
<li><a class="el" href="../../d7/d61/group__group__node.html">Object: Node</a> - A node is an instance of a kernel that will be paired with a specific set of references (the parameters). Nodes are created from and associated with a single graph only. When a <code><a class="el" href="../../d3/da9/group__group__parameter.html#ga35fab5fdbef16e118146d667cd98cc4d">vx_parameter</a></code> is extracted from a Node, an additional attribute can be accessed: <ul>
<li><em>Reference</em> - The <code><a class="el" href="../../dd/d90/group__group__reference.html#ga1a95c3bf180e49d4d1ecd64cb35f45a3">vx_reference</a></code> assigned to this parameter index from the Node creation function (e.g., <code><a class="el" href="../../da/d4b/group__group__vision__function__sobel3x3.html#gafcd43da8855003037834f67be961aa81">vxSobel3x3Node</a></code>).</li>
</ul>
</li>
<li><a class="el" href="../../d9/d7f/group__group__graph.html">Object: Graph</a> - A set of nodes connected in a directed (only goes one-way) acyclic (does not loop back) fashion. A Graph may have sets of Nodes that are unconnected to other sets of Nodes within the same Graph. See <a class="el" href="../../d0/d84/page_design.html#sub_graphs_rules">Graph Formalisms</a>.</li>
</ul>
<h1><a class="anchor" id="sec_data_objects"></a>
OpenVX Data Objects</h1>
<p>Data objects are object that are processed by graphs in nodes.</p>
<ul>
<li><a class="el" href="../../d5/d8e/group__group__array.html">Object: Array</a> An opaque array object that could be an array of primitive data types or an array of structures.</li>
<li><a class="el" href="../../de/d78/group__group__convolution.html">Object: Convolution</a> An opaque object that contains \( MxN \) matrix of <code><a class="el" href="../../d4/dae/group__group__basic__features.html#ga26c6ff9283467866f2640bceba3341f4">vx_int16</a></code> values. Also contains a scaling factor for normalization. Used specifically with <code><a class="el" href="../../d3/d3b/group__group__vision__function__custom__convolution.html#ga045763096925998ad6872ef22805f556">vxuConvolve</a></code> and <code><a class="el" href="../../d3/d3b/group__group__vision__function__custom__convolution.html#gacb538509fd54e68bdda50eb0caa4bd9b">vxConvolveNode</a></code>.</li>
<li><a class="el" href="../../de/d09/group__group__delay.html">Object: Delay</a> An opaque object that contains a manually controlled, temporally-delayed list of objects.</li>
<li><a class="el" href="../../d3/d27/group__group__distribution.html">Object: Distribution</a> An opaque object that contains a frequency distribution (e.g., a histogram).</li>
<li><a class="el" href="../../df/d09/group__group__image.html">Object: Image</a> An opaque image object that may be some format in <code><a class="el" href="../../d4/dae/group__group__basic__features.html#ga249dd49823433ffa16cf2e60ed25b7f1">vx_df_image_e</a></code>.</li>
<li><a class="el" href="../../de/d5f/group__group__lut.html">Object: LUT</a> An opaque lookup table object used with <code><a class="el" href="../../d5/d4e/group__group__vision__function__lut.html#ga1622c2ce4f9d5ece01f93e9862503084">vxTableLookupNode</a></code> and <code><a class="el" href="../../d5/d4e/group__group__vision__function__lut.html#gaf17090061244fece88a4489066afd4c7">vxuTableLookup</a></code>.</li>
<li><a class="el" href="../../db/dba/group__group__matrix.html">Object: Matrix</a> An opaque object that contains \( MxN \) matrix of some scalar values.</li>
<li><a class="el" href="../../db/d29/group__group__pyramid.html">Object: Pyramid</a> An opaque object that contains multiple levels of scaled <code><a class="el" href="../../df/d09/group__group__image.html#gafaa07841fe324f1c1d5b0f27c27de7b5">vx_image</a></code> objects.</li>
<li><a class="el" href="../../d3/db0/group__group__remap.html">Object: Remap</a> An opaque object that contains the map of source points to destination points used to transform images.</li>
<li><a class="el" href="../../de/d7e/group__group__scalar.html">Object: Scalar</a> An opaque object that contains a single primitive data type.</li>
<li><a class="el" href="../../de/dbe/group__group__threshold.html">Object: Threshold</a> An opaque object that contains the thresholding configuration.</li>
<li><a class="el" href="../../db/d9f/group__group__object__array.html">Object: ObjectArray</a> An opaque array object that could be an array of any data-object (not data-type) of OpenVX except Delay and ObjectArray objects.</li>
</ul>
<h1><a class="anchor" id="sec_errors"></a>
Error Objects</h1>
<p>Error objects are specialized objects that may be returned from other object creator functions when serious platform issue occur (i.e., out of memory or out of handles). These can be checked at the time of creation of these objects, but checking also may be put-off until usage in other APIs or verification time, in which case, the implementation must return appropriate errors to indicate that an invalid object type was used.</p>
<div class="fragment"><div class="line">vx_&lt;object&gt; obj = vxCreate&lt;Object&gt;(context, ...);</div>
<div class="line"><a class="code" href="../../d4/dae/group__group__basic__features.html#ga64df90a05ff50c048d65ab77bc60e4f0">vx_status</a> status = <a class="code" href="../../d4/dae/group__group__basic__features.html#ga9ff8fafafe415f56a02e6a1825baac97">vxGetStatus</a>((<a class="code" href="../../dd/d90/group__group__reference.html#ga1a95c3bf180e49d4d1ecd64cb35f45a3">vx_reference</a>)obj);</div>
<div class="line"><span class="keywordflow">if</span> (status == <a class="code" href="../../d4/dae/group__group__basic__features.html#ggaa2387ff4d3e967f124fb316300503f92a1c066c6ca46bf666215a58b0b2221abb">VX_SUCCESS</a>) { </div>
<div class="line">    <span class="comment">// object is good</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="sub_graphs"></a>
Graphs Concepts</h1>
<p>The <em>graph</em> is the central computation concept of OpenVX. The purpose of using graphs to express the Computer Vision problem is to allow for the possibility of any implementation to maximize its optimization potential because all the operations of the graph and its dependencies are known ahead of time, before the graph is processed.</p>
<p>Graphs are composed of one or more <em>nodes</em> that are added to the graph through node creation functions. Graphs in OpenVX must be created ahead of processing time and verified by the implementation, after which they can be processed as many times as needed.</p>
<h2><a class="anchor" id="sub_graph_linking"></a>
Linking Nodes</h2>
<p>Graph Nodes are linked together via data dependencies with <em>no explicitly-stated ordering</em>. The same reference may be linked to other nodes. Linking has a limitation, however, in that only one node in a graph may output to any specific data object reference. That is, only a single writer of an object may exist in a given graph. This prevents indeterminate ordering from data dependencies. All writers in a graph shall produce output data before any reader of that data accesses it.</p>
<h2><a class="anchor" id="sec_data_virtual"></a>
Virtual Data Objects</h2>
<p>Graphs in OpenVX depend on data objects to link together nodes. When clients of OpenVX know that they do not need access to these <em>intermediate</em> data objects, they may be created as <code>virtual</code>. Virtual data objects can be used in the same manner as non-virtual data objects to link nodes of a graph together; however, virtual data objects are different in the following respects.</p>
<ul>
<li>Inaccessible - No calls to an Map/Unmap or Copy APIs shall succeed given a reference to an object created through a virtual create function from a Graph external perspective. Calls to Map/Unmap or Copy APIs from within client-defined node that belongs to the same graph as the virtual object will succeed as they are Graph internal.</li>
<li>Scoped - Virtual data objects are scoped within the Graph in which they are created; they cannot be shared outside their scope. The live range of the data content of a virtual data object is limited to a single graph execution. In other word, data content of a virtual object is undefined before graph execution and no data of a virtual object should be expected to be preserved across successive graph executions by the application.</li>
<li>Intermediates - Virtual data objects should be used only for intermediate operations within Graphs, because they are fundamentally inaccessible to clients of the API.</li>
<li>Dimensionless or Formatless - Virtual data objects may have dimensions and formats partially or fully undefined at creation time. For instance, a virtual image can be created with undefined or partially defined dimensions (0x0, Nx0 or 0xN where N is not null) and/or without defined format (VX_DF_IMAGE_VIRT). The undefined property of the virtual object at creation time is undefined with regard to the graph and mutable at graph verification time; it will be automatically adjusted at each graph verification, deduced from the node that outputs the virtual object. Dimensions and format properties that are well defined at virtual object creation time are immutable and can't be adjusted automatically at graph verification time. The Dimensionless or Formatless aspect of virtual data is a commodity that allows creating graphs generic with regard to dimensions or format, but there are restrictions: <ol>
<li>
Nodes may require the dimensions and/or the format to be defined for a virtual output object when it can't be deduced from its other parameters. For example, a Scale node requires well defined dimensions for the output image, while ColorConvert and ChannelCombine nodes require a well defined format for the output image.  </li>
<li>
An image created from ROI must always be well defined (<a class="el" href="../../d4/dae/group__group__basic__features.html#dd/d11/structvx__rectangle__t" title="The rectangle data structure that is shared with the users. The area of the rectangle can be computed...">vx_rectangle_t</a> parameter) and can't be created from a dimensionless virtual image.  </li>
<li>
A ROI of a formatless virtual image shouldn't be a node output.  </li>
<li>
Levels of a dimensionless or formatless virtual pyramid shouldn't be a node output.  </li>
</ol>
</li>
<li>Inheritance - A sub-object inherits from the virtual property of its parent. A sub-object also inherits from the Dimensionless or Formatless property of its parent with restrictions: <ol>
<li>
it is adjusted automatically at graph verification when the parent properties are adjusted (the parent is the output of a node)  </li>
<li>
it can't be adjusted at graph verification when the sub-object is itself the output of a node.  </li>
</ol>
</li>
<li>Optimizations - Virtual data objects do not have to be created during Graph validation and execution and therefore may be of zero <em>size</em>.</li>
</ul>
<p>These restrictions enable vendors the ability to optimize some aspects of the data object or its usage. Some vendors may not allocate such objects, some may create intermediate sub-objects of the object, and some may allocate the object on remote, inaccessible memories. OpenVX does not proscribe <em>which</em> optimization the vendor does, merely that it <em>may</em> happen.</p>
<h2><a class="anchor" id="sub_node_parameters"></a>
Node Parameters</h2>
<p>Parameters to node creation functions are defined as either atomic types, such as <code><a class="el" href="../../d4/dae/group__group__basic__features.html#ga822fc495cb9045d45893eed297d48737">vx_int32</a></code>, <code><a class="el" href="../../d4/dae/group__group__basic__features.html#ga73d23cb932d31a69f44182054a987c85">vx_enum</a></code>, or as objects, such as <code><a class="el" href="../../de/d7e/group__group__scalar.html#ga1bf12c9f0e72ed39970212b04148788d">vx_scalar</a></code>, <code><a class="el" href="../../df/d09/group__group__image.html#gafaa07841fe324f1c1d5b0f27c27de7b5">vx_image</a></code>. The atomic variables of the Node creation functions shall be converted by the framework into <code><a class="el" href="../../de/d7e/group__group__scalar.html#ga1bf12c9f0e72ed39970212b04148788d">vx_scalar</a></code> references for use by the Nodes. A node parameter of type <code><a class="el" href="../../de/d7e/group__group__scalar.html#ga1bf12c9f0e72ed39970212b04148788d">vx_scalar</a></code> can be changed during the graph execution; whereas, a node parameter of an atomic type (<code>vx_int32</code> etc.) require at least a graph revalidation if changed. All node parameter objects may be modified by retrieving the reference to the <code><a class="el" href="../../d3/da9/group__group__parameter.html#ga35fab5fdbef16e118146d667cd98cc4d">vx_parameter</a></code> via <code><a class="el" href="../../d3/da9/group__group__parameter.html#gab3e64f553957ac629e4f391eb4b47fdd">vxGetParameterByIndex</a></code>, and then passing that to <code><a class="el" href="../../d3/da9/group__group__parameter.html#ga1418cbc77cc0e5f88827874cc0eb7b96">vxQueryParameter</a></code> to retrieve the reference to the object.</p>
<div class="fragment"><div class="line">        <a class="code" href="../../d3/da9/group__group__parameter.html#ga35fab5fdbef16e118146d667cd98cc4d">vx_parameter</a> param = <a class="code" href="../../d3/da9/group__group__parameter.html#gab3e64f553957ac629e4f391eb4b47fdd">vxGetParameterByIndex</a>(node, p);</div>
<div class="line">        <a class="code" href="../../dd/d90/group__group__reference.html#ga1a95c3bf180e49d4d1ecd64cb35f45a3">vx_reference</a> ref;</div>
<div class="line">        <a class="code" href="../../d3/da9/group__group__parameter.html#ga1418cbc77cc0e5f88827874cc0eb7b96">vxQueryParameter</a>(param, <a class="code" href="../../d3/da9/group__group__parameter.html#gga0534bb02e93eb4bab196bde2d3eccd59a6c352e5e19f27e9b3c69314aeb48a8f6">VX_PARAMETER_REF</a>, &amp;ref, <span class="keyword">sizeof</span>(ref));</div>
</div><!-- fragment --><p> If the type of the parameter is unknown, it may be retrieved with the same function.</p>
<div class="fragment"><div class="line">            <a class="code" href="../../d4/dae/group__group__basic__features.html#ga73d23cb932d31a69f44182054a987c85">vx_enum</a> type;</div>
<div class="line">            <a class="code" href="../../d3/da9/group__group__parameter.html#ga1418cbc77cc0e5f88827874cc0eb7b96">vxQueryParameter</a>(param, <a class="code" href="../../d3/da9/group__group__parameter.html#gga0534bb02e93eb4bab196bde2d3eccd59aa400961b57d14a87fe6644cd1a1ca904">VX_PARAMETER_TYPE</a>, &amp;type, <span class="keyword">sizeof</span>(type));</div>
<div class="line">            <span class="comment">/* cast the ref to the correct vx_&lt;type&gt;. Atomics are now vx_scalar */</span></div>
</div><!-- fragment --> <h2><a class="anchor" id="sub_graph_parameters"></a>
Graph Parameters</h2>
<p>Parameters may exist on Graphs, as well. These parameters are defined by the author of the Graph and each Graph parameter is defined as a specific parameter from a Node within the Graph using <code><a class="el" href="../../d5/dab/group__group__graph__parameters.html#ga0d22fac26dc5e3c168fc0056f306ff29">vxAddParameterToGraph</a></code>. Graph parameters communicate to the implementation that there are specific Node parameters that may be modified by the client between Graph executions. Additionally, they are parameters that the client may set without the reference to the Node but with the reference to the Graph using <code><a class="el" href="../../d5/dab/group__group__graph__parameters.html#ga376e00e31c517e283676d8f7e74a2cc4">vxSetGraphParameterByIndex</a></code>. This allows for the Graph authors to construct <em>Graph Factories</em>. How these factories work falls outside the scope of this document. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="../../d5/dab/group__group__graph__parameters.html" title="Defines the Graph Parameter API. ">Framework: Graph Parameters</a></dd></dl>
<h2><a class="anchor" id="sub_graphs_execution"></a>
Execution Model</h2>
<p>Graphs must execute in both:</p>
<ul>
<li><em>Synchronous blocking mode</em> (in that <code><a class="el" href="../../d9/d7f/group__group__graph.html#ga36b37f13ca2269258b813955f7089873">vxProcessGraph</a></code> will block until the graph has completed), and in</li>
<li><em>Asynchronous single-issue-per-reference mode</em> (via <code><a class="el" href="../../d9/d7f/group__group__graph.html#ga718b5f98fd11581ec102303ce94f45b2">vxScheduleGraph</a></code> and <code><a class="el" href="../../d9/d7f/group__group__graph.html#ga201e9fa88779f902d09009ad11b8f083">vxWaitGraph</a></code>).</li>
</ul>
<h3><a class="anchor" id="sub_graphs_execution_asynch"></a>
Asynchronous Mode</h3>
<p>In asynchronous mode, Graphs must be single-issue-per-reference. This means that given a constructed graph reference \(G\), it may be scheduled multiple times but only executes sequentially with respect to itself. Multiple graphs references given to the asynchronous graph interface do not have a defined behavior and may execute in parallel or in series based on the behavior or the vendor's implementation.</p>
<h2><a class="anchor" id="sub_graphs_rules"></a>
Graph Formalisms</h2>
<p>To use graphs several rules must be put in place to allow deterministic execution of Graphs. The behavior of a <code>processGraph</code>( \(G\)) call is determined by the structure of the Processing Graph \(G\). The Processing Graph is a bipartite graph consisting of a set of Nodes \(N_1 \ldots N_n\) and a set of data objects \(d_1 \ldots d_i\). Each edge ( \(N_x\), \(D_y\)) in the graph represents a data object \(D_y\) that is written by Node \(N_x\) and each edge ( \(D_x\), \(N_y\)) represents a data object \(D_x\) that is read by Node \(N_y\). Each edge \(e\) has a name <code>Name</code>( \(e\)), which gives the parameter name of the node that references the corresponding data object. Each Node Parameter also has a type <code>Type(node, name)</code> in <code>{INPUT, OUTPUT, INOUT}</code>. Some data objects are <em>Virtual</em>, and some data objects are <em>Delay</em>. Delay data objects are just collections of data objects with indexing (like an image list) and known linking points in a graph. A node may be classified as a <em>head node</em>, which has no backward dependency. Alternatively, a node may be a <em>dependent node</em>, which has a backward dependency to the head node. In addition, the Processing Graph has several restrictions: </p>
<ol>
<li>
<em>Output typing</em> - Every output edge ( \(N_x\), \(D_y\)) requires <code>Type</code>( \(N_x\), <code>Name</code>( \(N_x\), \(D_y\))) in <code>{OUTPUT, INOUT}</code> </li>
<li>
<em>Input typing</em> - Every input edge ( \(N_x\), \(D_y\)) requires <code>Type</code>( \(N_y\), <code>Name</code>( \(D_x\), \(N_y\))) in <code>{INPUT}</code> or <code>{INOUT}</code> </li>
<li>
<em>Single Writer</em> - Every data object is the target of at most one output edge. </li>
<li>
<em>Broken Cycles</em> - Every cycle in \(G\) must contain at least input edge ( \(D_x\), \(N_y\)) where \(D_x\) is Delay. </li>
<li>
<em>Virtual images must have a source</em> - If \(D_y\) is Virtual, then there is at least one output edge that writes \(D_y\) ( \(N_x\), \(D_y\)) </li>
<li>
<em>Bidirectional data objects shall not be virtual</em> - If <code>Type</code>( \(N_x\), <code>Name</code>( \(N_x\), \(D_y\))) is INOUT implies \(D_y\) is non-Virtual. </li>
<li>
<em>Delay data objects shall not be virtual</em> - If \(D_x\) is Delay then it shall not be Virtual.  </li>
<li>
<em>A uniform image cannot be output or bidirectional</em>. </li>
</ol>
<p>The execution of each node in a graph consists of an atomic operation (sometimes referred to as <em>firing</em>) that consumes data representing each input data object, processes it, and produces data representing each output data object. A node may execute when all of its input edges are marked <em>present</em>. Before the graph executes, the following initial marking is used: </p>
<ul>
<li>
All input edges ( \(D_x\), \(N_y\)) from non-Virtual objects Dx are marked (parameters must be set).  </li>
<li>
All input edges ( \(D_x\), \(N_y\)) with an output edge ( \(N_z\), \(D_x\)) are unmarked. </li>
<li>
All input edges ( \(D_x\), \(N_y\)) where \(D_x\) is a Delay data object are marked. </li>
</ul>
<p><br/>
 Processing a node results in unmarking all the corresponding input edges and marking all its output edges; marking an output edge ( \(N_x\), \(D_y\)) where \(D_y\) is not a Delay results in marking all of the input edges ( \(D_y\), \(N_z\)). Following these rules, it is possible to statically schedule the nodes in a graph as follows: Construct a precedence graph \(P\), including all the nodes \(N_1 \ldots N_x\), and an edge ( \(N_x\), \(N_z\)) for every pair of edges ( \(N_x\), \(D_y\)) and ( \(D_y\), \(N_z\)) where \(D_y\) is not a Delay. Then unconditionally fire each node according to any topological sort of \(P\).</p>
<p>The following assertions should be verified: </p>
<ul>
<li>
\(P\) is a Directed Acyclic Graph (DAG), implied by 4 and the way it is constructed. </li>
<li>
Every data object has a value when it is executed, implied by 5, 6, 7, and the marking. </li>
<li>
Execution is deterministic if the nodes are deterministic, implied by 3, 4, and the marking. </li>
<li>
Every node completes its execution exactly once. </li>
</ul>
<p>The execution model described here just acts as a formalism. For example, independent processing is allowed across multiple depended and depending nodes and edges, provided that the result is invariant with the execution model described here.</p>
<h3><a class="anchor" id="sub_graphs_rules_data_obj"></a>
Contained &amp; Overlapping Data Objects</h3>
<p>There are cases in which two different data objects referenced by an output parameter of node \(N_1\) and input parameter of node \(N_2\) in a graph induce a dependency between these two nodes: For example, a pyramid and its level images, image and the sub-images created from it by <code><a class="el" href="../../df/d09/group__group__image.html#gaf8f9ca43fb8aed127aef27d24d39e4af">vxCreateImageFromROI</a></code>, or overlapping sub-images of the same image. Following figure show examples of this dependency. To simplify subsequent definitions and requirements a limitation is imposed that if a sub-image <em>I<sup>'</sup></em> has been created from image <em>I</em> and sub-image <em>I<sup>''</sup></em> has been created from <em>I<sup>'</sup></em>, then <em>I<sup>''</sup></em> is still considered a sub-image of <em>I</em> and not of <em>I<sup>'</sup></em>. In these cases it is expected that although the two nodes reference two different data objects, any change to one data object might be reflected in the other one. Therefore it implies that \(N_1\) comes before \(N_2\) in the graph's topological order. To ensure that, following definitions are introduced.</p>
<div class="image">
<img src="../../Overlap_DataObj_Pyramid.png" alt="Overlap_DataObj_Pyramid.png"/>
</div>
  <div class="image">
<img src="../../Overlap_DataObj_Image.png" alt="Overlap_DataObj_Image.png"/>
</div>
 <p><br/>
 </p>
<ol>
<li>
<em> Containment Set</em> - <em>C(d)</em>, the set of recursively contained data objects of <em>d</em>, named <em>Containment Set</em>, is defined as follows:<ul>
<li>\(C_0\)(<em>d</em>)={<em>d</em>}</li>
<li>\(C_1\)(<em>d</em>) is the set of all data objects that are <em>directly contained</em> by <em>d</em>: <ol>
<li>
If <em>d</em> is an image, all images created as an ROI of <em>d</em> are directly contained by <em>d</em>.  </li>
<li>
If <em>d</em> is a pyramid, all pyramid levels of <em>d</em> are directly contained by <em>d</em>.  </li>
<li>
If <em>d</em> is an object array, all elements of <em>d</em> are directly contained by <em>d</em>.  </li>
<li>
If <em>d</em> is a delay object, all slots of <em>d</em> are directly contained by <em>d</em>.  </li>
</ol>
</li>
<li>For i&gt;1, \(C_i\)(<em>d</em>) is the set of all data objects that are contained by <em>d</em> at the <em>i<sup>th</sup></em> order <p class="formulaDsp">
\begin{eqnarray} C_i(d)=\bigcup_{d&#39;\in{C_{i-1}(d)}}C_1(d&#39;) \end{eqnarray}
</p>
</li>
<li>C(<em>d</em>) is the set that contains <em>d</em> itself, the data objects <em>contained</em> by <em>d</em>, the data objects that are contained by the data objects contained by <em>d</em> and so on. Formally: <p class="formulaDsp">
\begin{eqnarray} C(d)=\bigcup_{i=0}^{\infty}C_i(d) \end{eqnarray}
</p>
  </li>
</ul>
</li>
<li>
<em>I(d)</em> is a predicate that equals true if and only if <em>d</em> is an image.  </li>
<li>
<em> Overlapping Relationship</em> - The overlapping relation \(R_{ov}\) is a relation defined for images, such that if \(i_1\) and \(i_2\) in <em>C(i)</em>, <em>i</em> being an image, then \(i_1\) \(R_{ov}\) \(i_2\) is true if and only if \(i_1\) and \(i_2\) overlap, i.e there exists a point (x,y) of <em>i</em> that is contained in both \(i_1\) and \(i_2\) . Note that this relation is reflexive and symmetric, but not transitive: \(i_1\) overlaps \(i_2\) and \(i_2\) overlaps \(i_3\) does not necessarily imply that \(i_1\) overlaps \(i_3\), as illustrated in the following figure:  <div class="image">
<img src="../../Overlap_DataObj_Overlap.png" alt="Overlap_DataObj_Overlap.png"/>
</div>
  </li>
<li>
<em> Dependency Relationship</em> - The dependency relationship \(N_1\) -&gt; \(N_2\), is a relation defined for nodes. \(N_1\) -&gt; \(N_2\) means that \(N_2\) depends on \(N_1\) and then implies that \(N_2\) must be executed after the completion of \(N_1\).  </li>
<li>
\(N_1\) -&gt; \(N_2\) if \(N_1\) writes to a data object \(d_1\) and \(N_2\) reads from a data object \(d_2\) and: <p class="formulaDsp">
\begin{eqnarray} d_1\in{C(d_2)}\ or\ d_2\in{C(d_1)}\ or\ (I(d_1)\ and\ I(d_2)\ and\ d_1R_{ov}d_2) \end{eqnarray}
</p>
  </li>
</ol>
<h2><a class="anchor" id="sec_graph_indep"></a>
Node Execution Independence</h2>
<p>In the following example a client computes the gradient magnitude and gradient phase from a blurred input image. The <code><a class="el" href="../../dd/df2/group__group__vision__function__magnitude.html#ga0dc84cdabde58c5e90879df99927037f">vxMagnitudeNode</a></code> and <code><a class="el" href="../../db/d4e/group__group__vision__function__phase.html#gaa071e6198fa494b414e7ddb68e9eb510">vxPhaseNode</a></code> are <em>independently</em> computed, in that each does not depend on the output of the other. OpenVX does not mandate that they are run simultaneously or in parallel, but it could be implemented this way by the OpenVX vendor.</p>
<p><div class="dotgraph">
<img src="../../dot_simple_independent.png" alt="dot_simple_independent.png" border="0" usemap="#dot_simple_independent.map"/>
<map name="dot_simple_independent.map" id="dot_simple_independent.map"><area shape="poly" id="node1" href="../../dd/dc1/group__group__vision__function__channelextract.html#ga0c5feb26a6a958f8eb3c66e139ca0663" title="Luma\nExtract" alt="" coords="85,47,84,43,81,40,77,37,73,35,67,35,62,35,57,37,53,40,50,43,50,47,50,50,53,54,57,56,62,58,67,59,73,58,77,56,81,54,84,50"/><area shape="poly" id="node2" href="../../d6/d58/group__group__vision__function__gaussian__image.html#gae13017cf2cfbea6de99bb11218bebaa5" title="Blur" alt="" coords="79,116,79,113,77,111,74,109,71,108,67,108,63,108,60,109,57,111,56,113,55,116,56,118,57,120,60,122,63,123,67,124,71,123,74,122,77,120,79,118"/><area shape="poly" id="node3" href="../../da/d4b/group__group__vision__function__sobel3x3.html#gafcd43da8855003037834f67be961aa81" title="Gradients" alt="" coords="87,180,86,178,83,176,79,174,73,173,67,172,61,173,55,174,51,176,48,178,47,180,48,183,51,185,55,187,61,188,67,188,73,188,79,187,83,185,86,183"/><area shape="poly" id="node4" href="../../dd/df2/group__group__vision__function__magnitude.html#ga0dc84cdabde58c5e90879df99927037f" title="Magnitude" alt="" coords="67,245,66,243,63,241,58,239,52,238,45,237,39,238,32,239,28,241,24,243,23,245,24,248,28,250,32,252,39,253,45,253,52,253,58,252,63,250,66,248"/><area shape="poly" id="node5" href="../../db/d4e/group__group__vision__function__phase.html#gaa071e6198fa494b414e7ddb68e9eb510" title="Phase" alt="" coords="103,245,103,243,101,241,97,239,94,238,89,237,85,238,81,239,78,241,76,243,75,245,76,248,78,250,81,252,85,253,89,253,94,253,97,252,101,250,103,248"/></map>
<div class="caption">
A simple graph with some independent nodes.</div>
</div>
</p>
<p>The code to construct such a graph can be seen below.</p>
<div class="fragment"><div class="line">    <a class="code" href="../../d1/dc3/group__group__context.html#ga0f4f894d935fbf50bf38b3529a001249">vx_context</a> context = <a class="code" href="../../d1/dc3/group__group__context.html#ga8a4d197c61df13f3f37de8b81af18fee">vxCreateContext</a>();</div>
<div class="line">    <a class="code" href="../../df/d09/group__group__image.html#gafaa07841fe324f1c1d5b0f27c27de7b5">vx_image</a> images[] = {</div>
<div class="line">            <a class="code" href="../../df/d09/group__group__image.html#gae7b0f2e7f1be975ad07055c9d7eef1a0">vxCreateImage</a>(context, 640, 480, <a class="code" href="../../d4/dae/group__group__basic__features.html#gga249dd49823433ffa16cf2e60ed25b7f1a2e6af7896ecd0784c04e5b727c8d6e4e">VX_DF_IMAGE_UYVY</a>),</div>
<div class="line">            <a class="code" href="../../df/d09/group__group__image.html#gae7b0f2e7f1be975ad07055c9d7eef1a0">vxCreateImage</a>(context, 640, 480, <a class="code" href="../../d4/dae/group__group__basic__features.html#gga249dd49823433ffa16cf2e60ed25b7f1a43c0bbfeef4963204af1ece7cc70649e">VX_DF_IMAGE_S16</a>),</div>
<div class="line">            <a class="code" href="../../df/d09/group__group__image.html#gae7b0f2e7f1be975ad07055c9d7eef1a0">vxCreateImage</a>(context, 640, 480, <a class="code" href="../../d4/dae/group__group__basic__features.html#gga249dd49823433ffa16cf2e60ed25b7f1ad57c5881488a19029a9ce095f13932cb">VX_DF_IMAGE_U8</a>),</div>
<div class="line">    };</div>
<div class="line">    <a class="code" href="../../d9/d7f/group__group__graph.html#ga7e71c08b1777e49abaf4417506ca8451">vx_graph</a> graph = <a class="code" href="../../d9/d7f/group__group__graph.html#ga6ce40cbacadd686cc46de313ea3a0fbd">vxCreateGraph</a>(context);</div>
<div class="line">    <a class="code" href="../../df/d09/group__group__image.html#gafaa07841fe324f1c1d5b0f27c27de7b5">vx_image</a> virts[] = {</div>
<div class="line">            <a class="code" href="../../df/d09/group__group__image.html#gae061ffcefba6ec95a7e6c99f1996fba4">vxCreateVirtualImage</a>(graph, 0, 0, <a class="code" href="../../d4/dae/group__group__basic__features.html#gga249dd49823433ffa16cf2e60ed25b7f1a2f7301752672cda96ae3d70851001cd5">VX_DF_IMAGE_VIRT</a>),</div>
<div class="line">            <a class="code" href="../../df/d09/group__group__image.html#gae061ffcefba6ec95a7e6c99f1996fba4">vxCreateVirtualImage</a>(graph, 0, 0, <a class="code" href="../../d4/dae/group__group__basic__features.html#gga249dd49823433ffa16cf2e60ed25b7f1a2f7301752672cda96ae3d70851001cd5">VX_DF_IMAGE_VIRT</a>),</div>
<div class="line">            <a class="code" href="../../df/d09/group__group__image.html#gae061ffcefba6ec95a7e6c99f1996fba4">vxCreateVirtualImage</a>(graph, 0, 0, <a class="code" href="../../d4/dae/group__group__basic__features.html#gga249dd49823433ffa16cf2e60ed25b7f1a2f7301752672cda96ae3d70851001cd5">VX_DF_IMAGE_VIRT</a>),</div>
<div class="line">            <a class="code" href="../../df/d09/group__group__image.html#gae061ffcefba6ec95a7e6c99f1996fba4">vxCreateVirtualImage</a>(graph, 0, 0, <a class="code" href="../../d4/dae/group__group__basic__features.html#gga249dd49823433ffa16cf2e60ed25b7f1a2f7301752672cda96ae3d70851001cd5">VX_DF_IMAGE_VIRT</a>),</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="../../dd/dc1/group__group__vision__function__channelextract.html#ga0c5feb26a6a958f8eb3c66e139ca0663">vxChannelExtractNode</a>(graph, images[0], <a class="code" href="../../d4/dae/group__group__basic__features.html#gga5918ef0456c126837dca21f6fb55ccb3aa8165329663163f9831a99fc6eab2c07">VX_CHANNEL_Y</a>, virts[0]),</div>
<div class="line">    <a class="code" href="../../d6/d58/group__group__vision__function__gaussian__image.html#gae13017cf2cfbea6de99bb11218bebaa5">vxGaussian3x3Node</a>(graph, virts[0], virts[1]),</div>
<div class="line">    <a class="code" href="../../da/d4b/group__group__vision__function__sobel3x3.html#gafcd43da8855003037834f67be961aa81">vxSobel3x3Node</a>(graph, virts[1], virts[2], virts[3]),</div>
<div class="line">    <a class="code" href="../../dd/df2/group__group__vision__function__magnitude.html#ga0dc84cdabde58c5e90879df99927037f">vxMagnitudeNode</a>(graph, virts[2], virts[3], images[1]),</div>
<div class="line">    <a class="code" href="../../db/d4e/group__group__vision__function__phase.html#gaa071e6198fa494b414e7ddb68e9eb510">vxPhaseNode</a>(graph, virts[2], virts[3], images[2]),</div>
<div class="line"></div>
<div class="line">    status = <a class="code" href="../../d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154">vxVerifyGraph</a>(graph);</div>
<div class="line">    <span class="keywordflow">if</span> (status == <a class="code" href="../../d4/dae/group__group__basic__features.html#ggaa2387ff4d3e967f124fb316300503f92a1c066c6ca46bf666215a58b0b2221abb">VX_SUCCESS</a>)</div>
<div class="line">    {</div>
<div class="line">        status = <a class="code" href="../../d9/d7f/group__group__graph.html#ga36b37f13ca2269258b813955f7089873">vxProcessGraph</a>(graph);</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="../../d1/dc3/group__group__context.html#ga84fd4eb1034c1746356db66eb3890258">vxReleaseContext</a>(&amp;context); <span class="comment">/* this will release everything */</span></div>
</div><!-- fragment --> <h2><a class="anchor" id="sec_graph_verification"></a>
Verification</h2>
<p>Graphs within OpenVX must go through a rigorous validation process before execution to satisfy the design concept of eliminating run-time overhead (parameter checking) that guarantees safe execution of the graph. OpenVX must check for (but is not limited to) these conditions:</p>
<ul>
<li>Parameters To Nodes: <ul>
<li>Each required parameter is given to the node (<a class="el" href="../../d3/da9/group__group__parameter.html#gadee3d0820c9f76afc5273e4c1b7f3b04">vx_parameter_state_e</a>). Optional parameters may not be present and therefore are not checked when absent. If present, they are checked. </li>
<li>Each parameter given to a node must be of the right <em>direction</em> (a value from <code><a class="el" href="../../d3/da9/group__group__parameter.html#ga4a11207b7fcf1135615b4ae11624f9ed">vx_direction_e</a></code>). </li>
<li>Each parameter given to a node must be of the right <em>object type</em> (from the object range of <code><a class="el" href="../../d4/dae/group__group__basic__features.html#ga44aa67e15168e5912a0800090a120be6">vx_type_e</a></code>). </li>
<li>Each parameter attribute or value must be verified. In the case of a scalar value, it may need to be range checked (e.g., \( 0.5 &lt;= k &lt;= 1.0 \)). The implementation is not required to do run-time range checking of scalar values. If the value of the scalar changes at run time to go outside the range, the results are undefined. The rationale is that the potential performance hit for run-time range checking is too large to be enforced. It will still be checked at graph verification time as a time-zero sanity check. If the scalar is an output parameter of another node, it must be initialized to a legal value. In the case of <code><a class="el" href="../../d1/d26/group__group__vision__function__scale__image.html#ga065754e616b553a39c13c16b4b8de45a">vxScaleImageNode</a></code>, the relation of the input image dimensions to the output image dimensions determines the scaling factor. These values or attributes of data objects must be checked for compatibility on each platform. </li>
<li>Graph Connectivity - the <code><a class="el" href="../../d9/d7f/group__group__graph.html#ga7e71c08b1777e49abaf4417506ca8451">vx_graph</a></code> must be a Directed Acyclic Graph (DAG). No cycles or feedback is allowed. The <code><a class="el" href="../../de/d09/group__group__delay.html#ga2c6de63476aff4a009bac8d0eb9800d1">vx_delay</a></code> object has been designed to explicitly address feedback between Graph executions. </li>
<li>Resolution of Virtual Data Objects - Any changes to <em>Virtual</em> data objects from unspecified to specific format or dimensions, as well as the related creation of objects of specific type that are observable at processing time, takes place at Verification time.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="sec_callback"></a>
Callbacks</h1>
<p>Callbacks are a method to control graph flow and to make decisions based on completed work. The <code><a class="el" href="../../d8/d69/group__group__node__callback.html#ga04a77098044842c96b6945c1eeb06509">vxAssignNodeCallback</a></code> call takes as a parameter a callback function. This function will be called after the execution of the particular node, but prior to the completion of the graph. If nodes are arranged into independent sets, the order of the callbacks is unspecified. Nodes that are arranged in a serial fashion due to data dependencies perform callbacks in order. The callback function may use the node reference first to extract parameters from the node, and then extract the data references. Data outputs of Nodes with callbacks shall be available (via Map/Unmap/Copy methods) when the callback is called.</p>
<h1><a class="anchor" id="sec_user_kernels"></a>
User Kernels</h1>
<p>OpenVX supports the concept of <em>client-defined functions</em> that shall be executed as <em>Nodes</em> from inside the Graph or are Graph <em>internal</em>. The purpose of this paradigm is to: </p>
<ul>
<li>Further exploit independent operation of nodes within the OpenVX platform. </li>
<li>Allow componentized functions to be reused elsewhere in OpenVX. </li>
<li>Formalize strict verification requirements (i.e., Contract Programming).</li>
</ul>
<p><div class="dotgraph">
<img src="../../dot_user_nodes.png" alt="dot_user_nodes.png" border="0" usemap="#dot_user_nodes.map"/>
<map name="dot_user_nodes.map" id="dot_user_nodes.map"><area shape="poly" id="node1" href="../../dd/dc1/group__group__vision__function__channelextract.html#ga0c5feb26a6a958f8eb3c66e139ca0663" title="Luma\nExtract" alt="" coords="60,36,59,34,57,31,54,29,50,28,46,27,42,28,38,29,35,31,33,34,32,36,33,39,35,42,38,44,42,45,46,46,50,45,54,44,57,42,59,39"/><area shape="poly" id="node2" href="../../d6/d58/group__group__vision__function__gaussian__image.html#gae13017cf2cfbea6de99bb11218bebaa5" title="Blur" alt="" coords="46,90,46,88,44,87,42,85,40,84,37,84,34,84,31,85,29,87,28,88,27,90,28,92,29,94,31,95,34,96,37,96,40,96,42,95,44,94,46,92"/><area shape="poly" id="node3" href="../../da/d4b/group__group__vision__function__sobel3x3.html#gafcd43da8855003037834f67be961aa81" title="Gradients" alt="" coords="46,147,46,145,43,143,40,142,36,141,31,141,26,141,22,142,18,143,16,145,15,147,16,149,18,150,22,152,26,153,31,153,36,153,40,152,43,150,46,149"/><area shape="poly" id="node4" href="../../dd/df2/group__group__vision__function__magnitude.html#ga0dc84cdabde58c5e90879df99927037f" title="Magnitude" alt="" coords="64,198,63,196,60,194,57,193,52,192,46,192,41,192,36,193,33,194,30,196,29,198,30,200,33,201,36,203,41,204,46,204,52,204,57,203,60,201,63,200"/><area shape="poly" id="node5" href="../../db/d4e/group__group__vision__function__phase.html#gaa071e6198fa494b414e7ddb68e9eb510" title="Phase" alt="" coords="23,198,22,196,21,194,19,193,15,192,12,192,9,192,6,193,3,194,2,196,1,198,2,200,3,201,6,203,9,204,12,204,15,204,19,203,21,201,22,200"/></map>
<div class="caption">
A graph with User Kernel nodes which are independent of the &ldquo;base&rdquo; nodes.</div>
</div>
</p>
<p>In this example, to execute client-supplied functions, the graph does not have to be halted and then resumed. These nodes shall be executed in an independent fashion with respect to independent base nodes within OpenVX. This allows implementations to further minimize execution time if hardware to exploit this property exists.</p>
<h2><a class="anchor" id="sec_user_node_validation"></a>
Parameter Validation</h2>
<p>User Kernels must aid in the Graph Verification effort by providing an explicit validation function for each vision function they implement. Each parameter passed to the instanced Node of a User Kernel is validated using the client-supplied validation function. The client must check these attributes and/or values of each parameter: </p>
<ul>
<li>Each attribute or value of the parameter must be checked. For example, the size of array, or the value of a scalar to be within a range, or a dimensionality constraint of an image such as width divisibility. (Some implementations may have restrictions, such as an image width be evenly divisible by some fixed number). </li>
<li>If the output parameters depend on attributes or values from input parameters, those relationships must be checked.</li>
</ul>
<h3><a class="anchor" id="subsec_meta_format"></a>
The Meta Format Object</h3>
<p>The Meta Format Object is an opaque object used to collect requirements about the output parameter, which then the OpenVX implementation will check. The Client must manually set relevant object attributes to be checked against output parameters, such as dimensionality, format, scaling, etc.</p>
<h2><a class="anchor" id="sec_functionnaming"></a>
User Kernels Naming Conventions</h2>
<p>User Kernels must be exported with a unique name (see <a class="el" href="../../index.html#sec_naming_conventions">Naming Conventions</a> for information on OpenVX conventions) and a unique enumeration. Clients of OpenVX may use either the name or enumeration to retrieve a kernel, so collisions due to non-unique names will cause problems. The kernel enumerations may be extended by following this example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define VX_KERNEL_NAME_KHR_XYZ &quot;org.khronos.example.xyz&quot;</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define VX_LIBRARY_XYZ (0x3) // assigned from Khronos, vendors control their own</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="keyword">enum</span> vx_kernel_xyz_ext_e {</div>
<div class="line">    VX_KERNEL_KHR_XYZ = <a class="code" href="../../d4/dae/group__group__basic__features.html#gadf866bd868ffb9a8c8dc157c2c541f40">VX_KERNEL_BASE</a>(<a class="code" href="../../d4/dae/group__group__basic__features.html#gga49682f34339161ba7594f52aa8d59c1ca7d6af4111ec80fa29c7cad71b89841dc">VX_ID_DEFAULT</a>, VX_LIBRARY_XYZ) + 0x0,</div>
<div class="line">    <span class="comment">// up to 0xFFF kernel enums can be created.</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> Each vendor of a vision function or an implementation must apply to Khronos to get a unique identifier (up to a limit of \( 2^{12}-1 \) vendors). Until they obtain a unique ID vendors must use <a class="el" href="../../d4/dae/group__group__basic__features.html#gga49682f34339161ba7594f52aa8d59c1ca7d6af4111ec80fa29c7cad71b89841dc">VX_ID_DEFAULT</a>.</p>
<p>To construct a kernel enumeration, a vendor must have both their ID and a <em>library</em> ID. The library ID's are completely <em>vendor</em> defined (however when using the <a class="el" href="../../d4/dae/group__group__basic__features.html#gga49682f34339161ba7594f52aa8d59c1ca7d6af4111ec80fa29c7cad71b89841dc">VX_ID_DEFAULT</a> ID, many libraries may collide in namespace).</p>
<p>Once both are defined, a kernel enumeration may be constructed using the <a class="el" href="../../d4/dae/group__group__basic__features.html#gadf866bd868ffb9a8c8dc157c2c541f40">VX_KERNEL_BASE</a> macro and an offset. (The offset is optional, but very helpful for long enumerations.)</p>
<h1><a class="anchor" id="sec_immediate_mode"></a>
Immediate Mode Functions</h1>
<p>OpenVX also contains an interface defined within <code>&lt;<a class="el" href="../../d2/d92/vxu_8h_source.html" title="The OpenVX Utility Library. ">VX/vxu.h</a>&gt;</code> that allows for immediate execution of vision functions. These interfaces are prefixed with <code>vxu</code> to distinguish them from the Node interfaces, which are of the form <code>vx&lt;Name&gt;Node</code>. Each of these interfaces replicates a Node interface with some exceptions. Immediate mode functions are defined to <em>behave</em> as <em>Single Node Graphs</em>, which have no leaking side-effects (e.g., no Log entries) within the Graph Framework after the function returns. The following tables refer to both the Immediate Mode and Graph Mode vision functions. The Module documentation for each vision function draws a distinction on each API by noting that it is either an immediate mode function with the tag <code>[Immediate]</code> or it is a Graph mode function by the tag <code>[Graph]</code>.</p>
<h1><a class="anchor" id="sec_target"></a>
Targets</h1>
<p>A 'Target' specifies a physical or logical devices where a node or an immediate mode function is executed. This allows the use of different implementations of vision functions on different targets. The existence of allowed Targets is exposed to the applications by the use of defined APIs. The choice of a Target allows for different levels of control on where the nodes can be executed. An OpenVX implementation must support at least one target. Additional supported targets are specified using the appropriate enumerations. See <code><a class="el" href="../../d7/d61/group__group__node.html#ga7409f4d86e22259caae9c0d42b18cbd9">vxSetNodeTarget</a></code>, <code><a class="el" href="../../d1/dc3/group__group__context.html#ga3b230756647b06dd4584b11c39891f96">vxSetImmediateModeTarget</a></code>, and <code><a class="el" href="../../d4/dae/group__group__basic__features.html#ga39fd08c4e2f3fea1a30caf312245f5c6">vx_target_e</a></code>. An OpenVX implementation must support at least one target VX_TARGET_ANY as well as VX_TARGET_STRING enumerates. An OpenVX implementation may also support more than these two to indicate the use of specific devices. For example, an implementation may add VX_TARGET_CPU and VX_TARGET_GPU enumerates to indicate the support of two possible targets to assign a nodes to (or to excute an immediate mode function). Another way an implementation can indicate the existence of multiple targets, for example CPU and GPU, is by specifying the target as VX_TARGET_STRING and using strings 'CPU' and 'GPU'. Thus defining targets using names rather than enumerates. The specific naming of string or enumerates is not enforced by the specification and it is up to the vendors to document and communicate the Target naming. Once available in a given implementation Applications can assign a Target to a node to specify the target that must execute that node by using the API <code><a class="el" href="../../d7/d61/group__group__node.html#ga7409f4d86e22259caae9c0d42b18cbd9">vxSetNodeTarget</a></code>. For immediate mode functions the target specifies the physical or logical device where the future execution of that function will be attempted. When an immediate mode function is not supported on the selected target the execution falls back to VX_TARGET_ANY.</p>
<h1><a class="anchor" id="sec_vision_functions"></a>
Base Vision Functions</h1>
<p>OpenVX comes with a standard or <em>base</em> set of vision functions. The following table lists the supported set of vision functions, their input types (first table) and output types (second table), and the version of OpenVX in which they are supported.</p>
<h2><a class="anchor" id="sec_vision_function_inputs"></a>
Inputs</h2>
<table class="doxtable">
<tr>
<th align="left">Vision Function </th><th align="center">U8 </th><th align="center">U16 </th><th align="center">S16 </th><th align="center">U32 </th><th align="center">S32 </th><th align="center">F32 </th><th align="center">color  </th></tr>
<tr>
<td align="left">AbsDiff </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.0.1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Accumulate </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">AccumulateSquared </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">AccumulateWeighted </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Add </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">And </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Box3x3 </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">CannyEdgeDetector </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">ChannelCombine </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">ChannelExtract </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1.0 </td></tr>
<tr>
<td align="left">ColorConvert </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1.0 </td></tr>
<tr>
<td align="left">ConvertDepth </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Convolve </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Dilate3x3 </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">EqualizeHistogram </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Erode3x3 </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">FastCorners </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Gaussian3x3 </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">HarrisCorners </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">HalfScaleGaussian </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Histogram </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">IntegralImage </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">TableLookup </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.1 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">LaplacianPyramid </td><td align="center">1.1 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">LaplacianReconstruct </td><td align="center"></td><td align="center"></td><td align="center">1.1 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Magnitude </td><td align="center"></td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">MeanStdDev </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Median3x3 </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">MinMaxLoc </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Multiply </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">NonLinearFilter </td><td align="center">1.1 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Not </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">OpticalFlowPyrLK </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Or </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Phase </td><td align="center"></td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">GaussianPyramid </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Remap </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">ScaleImage </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Sobel3x3 </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Subtract </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Threshold </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">WarpAffine </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">WarpPerspective </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Xor </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
</table>
<h2><a class="anchor" id="sec_vision_function_outputs"></a>
Outputs</h2>
<table class="doxtable">
<tr>
<th align="left">Vision Function </th><th align="center">U8 </th><th align="center">U16 </th><th align="center">S16 </th><th align="center">U32 </th><th align="center">S32 </th><th align="center">F32 </th><th align="center">color  </th></tr>
<tr>
<td align="left">AbsDiff </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.0.1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Accumulate </td><td align="center"></td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">AccumulateSquared </td><td align="center"></td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">AccumulateWeighted </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Add </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">And </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Box3x3 </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">CannyEdgeDetector </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">ChannelCombine </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1.0 </td></tr>
<tr>
<td align="left">ChannelExtract </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">ColorConvert </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1.0 </td></tr>
<tr>
<td align="left">ConvertDepth </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Convolve </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Dilate3x3 </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">EqualizeHistogram </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Erode3x3 </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">FastCorners </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Gaussian3x3 </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">HarrisCorners </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">HalfScaleGaussian </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Histogram </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">IntegralImage </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">TableLookup </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.1 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">LaplacianPyramid </td><td align="center"></td><td align="center"></td><td align="center">1.1 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">LaplacianReconstruct </td><td align="center">1.1 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Magnitude </td><td align="center"></td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">MeanStdDev </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1.0 </td><td align="center"></td></tr>
<tr>
<td align="left">Median3x3 </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">MinMaxLoc </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.0 </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Multiply </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">NonLinearFilter </td><td align="center">1.1 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Not </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">OpticalFlowPyrLK </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Or </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Phase </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">GaussianPyramid </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Remap </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">ScaleImage </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Sobel3x3 </td><td align="center"></td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Subtract </td><td align="center">1.0 </td><td align="center"></td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Threshold </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">WarpAffine </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">WarpPerspective </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="left">Xor </td><td align="center">1.0 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
</table>
<h1><a class="anchor" id="sec_lifecycle"></a>
Lifecycles</h1>
<h2><a class="anchor" id="sec_lc_context"></a>
OpenVX Context Lifecycle</h2>
<p>The lifecycle of the context is very simple.</p>
<p><div class="mscgraph">
<img src="../../msc_system.png" alt="msc_system" border="0" usemap="#msc_system.map"/>
<map name="msc_system.map" id="msc_system.map"><area href="../../d1/dc3/group__group__context.html#ga8a4d197c61df13f3f37de8b81af18fee" shape="rect" coords="241,26,359,39" alt=""/>
<area href="../../d1/dc3/group__group__context.html#ga0f4f894d935fbf50bf38b3529a001249" shape="rect" coords="265,58,335,71" alt=""/>
<area href="../../d1/dc3/group__group__context.html#ga84fd4eb1034c1746356db66eb3890258" shape="rect" coords="208,147,393,160" alt=""/>
</map>
<div class="caption">
The lifecycle model for an OpenVX Context.</div>
</div>
</p>
<h2><a class="anchor" id="sub_lc_graph"></a>
Graph Lifecycle</h2>
<p>OpenVX has four main phases of graph lifecycle: </p>
<ul>
<li>Construction - Graphs are created via <code><a class="el" href="../../d9/d7f/group__group__graph.html#ga6ce40cbacadd686cc46de313ea3a0fbd">vxCreateGraph</a></code>, and Nodes are connected together by data objects. </li>
<li>Verification - The graphs are checked for consistency, correctness, and other conditions. Memory allocation may occur. </li>
<li>Execution - The graphs are executed via <code><a class="el" href="../../d9/d7f/group__group__graph.html#ga36b37f13ca2269258b813955f7089873">vxProcessGraph</a></code> or <code><a class="el" href="../../d9/d7f/group__group__graph.html#ga718b5f98fd11581ec102303ce94f45b2">vxScheduleGraph</a></code>. Between executions data may be updated by the client or some other external mechanism. The client of OpenVX may change reference of input data to a graph, but this may require the graph to be validated again by checking <code><a class="el" href="../../d9/d7f/group__group__graph.html#ga017ab247c632dfe66a90e124cbf43c63">vxIsGraphVerified</a></code>. </li>
<li>Deconstruction - Graphs are released via <code><a class="el" href="../../d9/d7f/group__group__graph.html#ga1334f741d1c76d27a0e26117603885f1">vxReleaseGraph</a></code>. All Nodes in the Graph are released.</li>
</ul>
<p><div class="dotgraph">
<img src="../../dot_phases.png" alt="dot_phases.png" border="0" usemap="#dot_phases.map"/>
<map name="dot_phases.map" id="dot_phases.map"><area shape="poly" id="node1" href="../../d9/d7f/group__group__graph.html#ga6ce40cbacadd686cc46de313ea3a0fbd" title="Graph Construction" alt="" coords="110,14,107,11,100,7,89,5,74,3,58,3,42,3,27,5,16,7,9,11,6,14,9,18,16,21,27,24,42,25,58,26,74,25,89,24,100,21,107,18"/><area shape="poly" id="node2" href="../../d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154" title="Graph Verification" alt="" coords="108,62,105,58,98,55,87,52,73,51,58,50,43,51,29,52,18,55,11,58,8,62,11,65,18,69,29,71,43,73,58,73,73,73,87,71,98,69,105,65"/><area shape="poly" id="node3" href="../../d9/d7f/group__group__graph.html#ga36b37f13ca2269258b813955f7089873" title="Graph Execution" alt="" coords="106,119,103,115,97,112,87,109,74,108,60,107,46,108,33,109,23,112,17,115,14,119,17,122,23,125,33,128,46,130,60,130,74,130,87,128,97,125,103,122"/><area shape="poly" id="edge5" href="../../d3/da9/group__group__parameter.html#ga3707923da464d23acec18e3fc2506286" title="reference changes" alt="" coords="106,117,113,115,119,110,123,103,125,94,125,85,124,76,120,69,114,64,116,62,122,67,126,75,128,84,127,94,125,104,121,112,115,118,107,120"/><area shape="rect" id="edge5-label" href="../../d3/da9/group__group__parameter.html#ga3707923da464d23acec18e3fc2506286" title="reference changes" alt="" coords="126,85,189,95"/><area shape="poly" id="edge4" href="../../d3/da9/group__group__parameter.html#ga3707923da464d23acec18e3fc2506286" title="data updates" alt="" coords="105,118,108,114,112,113,116,114,118,119,116,123,111,124,111,121,114,121,115,118,114,116,112,115,109,116,107,119"/><area shape="rect" id="edge4-label" href="../../d3/da9/group__group__parameter.html#ga3707923da464d23acec18e3fc2506286" title="data updates" alt="" coords="117,114,160,123"/><area shape="poly" id="node4" href="../../d9/d7f/group__group__graph.html#ga1334f741d1c76d27a0e26117603885f1" title="Graph Deconstruction" alt="" coords="117,166,114,163,106,159,94,157,78,155,60,155,42,155,26,157,14,159,5,163,3,166,5,170,14,173,26,176,42,177,60,178,78,177,94,176,106,173,114,170"/></map>
<div class="caption">
Graph Lifecycle</div>
</div>
</p>
<h2><a class="anchor" id="sec_data_object_lifecycle"></a>
Data Object Lifecycle</h2>
<p>All objects in OpenVX follow a similar lifecycle model. All objects are </p>
<ul>
<li>Created via <code>vxCreate&lt;Object&gt;&lt;Method&gt;</code> or retreived via <code>vxGet&lt;Object&gt;&lt;Method&gt;</code> from the parent object if they are internally created. </li>
<li>Used within Graphs or immediate functions as needed. </li>
<li>Then objects must be released via <code>vxRelease&lt;Object&gt;</code> or via <code><a class="el" href="../../d1/dc3/group__group__context.html#ga84fd4eb1034c1746356db66eb3890258">vxReleaseContext</a></code> when all objects are released.</li>
</ul>
<h3><a class="anchor" id="sec_lc_image"></a>
OpenVX Image Lifecycle</h3>
<p>This is an example of the Image Lifecycle using the OpenVX Framework API. This would also apply to other data types with changes to the types and function names.</p>
<p><div class="mscgraph">
<img src="../../msc_image.png" alt="msc_image" border="0" usemap="#msc_image.map"/>
<map name="msc_image.map" id="msc_image.map"><area href="../../d1/dc3/group__group__context.html#ga8a4d197c61df13f3f37de8b81af18fee" shape="rect" coords="246,45,354,58" alt=""/>
<area href="../../d1/dc3/group__group__context.html#ga0f4f894d935fbf50bf38b3529a001249" shape="rect" coords="265,77,335,90" alt=""/>
<area href="../../df/d09/group__group__image.html#gae7b0f2e7f1be975ad07055c9d7eef1a0" shape="rect" coords="110,128,490,141" alt=""/>
<area href="../../df/d09/group__group__image.html#gafaa07841fe324f1c1d5b0f27c27de7b5" shape="rect" coords="269,160,331,173" alt=""/>
<area href="../../df/d09/group__group__image.html#ga7f680c04462fcb05a0eae1a96dd923e3" shape="rect" coords="240,211,361,224" alt=""/>
<area href="../../d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="269,243,331,256" alt=""/>
<area href="../../df/d09/group__group__image.html#ga251504d5e0c254143e0d0e1077c71181" shape="rect" coords="231,345,370,358" alt=""/>
<area href="../../d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="269,377,331,390" alt=""/>
<area href="../../d9/d7f/group__group__graph.html#gaa815ffa0b7cc2598d3d53bffc7c8c154" shape="rect" coords="231,479,370,492" alt=""/>
<area href="../../d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="269,511,331,524" alt=""/>
<area href="../../d9/d7f/group__group__graph.html#ga718b5f98fd11581ec102303ce94f45b2" shape="rect" coords="242,581,358,594" alt=""/>
<area href="../../d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="269,613,331,626" alt=""/>
<area href="../../d9/d7f/group__group__graph.html#ga201e9fa88779f902d09009ad11b8f083" shape="rect" coords="258,664,342,677" alt=""/>
<area href="../../d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="269,696,331,709" alt=""/>
<area href="../../df/d09/group__group__image.html#ga7f680c04462fcb05a0eae1a96dd923e3" shape="rect" coords="240,747,361,760" alt=""/>
<area href="../../d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="269,779,331,792" alt=""/>
<area href="../../df/d09/group__group__image.html#ga251504d5e0c254143e0d0e1077c71181" shape="rect" coords="231,881,370,894" alt=""/>
<area href="../../d4/dae/group__group__basic__features.html#gaa2387ff4d3e967f124fb316300503f92" shape="rect" coords="269,913,331,926" alt=""/>
<area href="../../df/d09/group__group__image.html#gab9d76afb39de187cf82faf9827eab9f1" shape="rect" coords="217,1015,384,1028" alt=""/>
<area href="../../d1/dc3/group__group__context.html#ga84fd4eb1034c1746356db66eb3890258" shape="rect" coords="208,1047,393,1060" alt=""/>
</map>
<div class="caption">
Image Object Lifecycle</div>
</div>
</p>
<h1><a class="anchor" id="sec_host_memory"></a>
Host Memory Data Object Access Patterns</h1>
<p>For objects retrieved from OpenVX that are 2D in nature, such as <code><a class="el" href="../../df/d09/group__group__image.html#gafaa07841fe324f1c1d5b0f27c27de7b5">vx_image</a></code>, <code><a class="el" href="../../db/dba/group__group__matrix.html#ga58694f635229a5e16823013ac75396f4">vx_matrix</a></code>, and <code><a class="el" href="../../de/d78/group__group__convolution.html#ga03700378868a539a20db1f3302ceb4bc">vx_convolution</a></code>, the manner in which the host-side has access to these memory regions is well-defined. OpenVX uses a row-major storage (that is each unit in a column is memory-adjacent to its row adjacent unit). Two-dimensional objects are always created (using <code><a class="el" href="../../df/d09/group__group__image.html#gae7b0f2e7f1be975ad07055c9d7eef1a0">vxCreateImage</a></code> or <code><a class="el" href="../../db/dba/group__group__matrix.html#ga60469797e6ebfc529887330ab076468c">vxCreateMatrix</a></code>) in width (columns) by height (rows) notation, with the arguments in that order. When accessing these structures in &ldquo;C&rdquo; with two-dimensional arrays of declared size, the user must therefore provide the array dimensions in the reverse of the order of the arguments to the Create function. This layout ensures <em>row-wise</em> storage in C on the host. A pointer could also be allocated for the matrix data and would have to be indexed in this row-major method.</p>
<h2><a class="anchor" id="sub_matrix_access"></a>
Matrix Access Example</h2>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code" href="../../d4/dae/group__group__basic__features.html#ga46d89d47ad9a2de1de723d0db861d324">vx_size</a> columns = 3;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="../../d4/dae/group__group__basic__features.html#ga46d89d47ad9a2de1de723d0db861d324">vx_size</a> rows = 4;</div>
<div class="line">    <a class="code" href="../../db/dba/group__group__matrix.html#ga58694f635229a5e16823013ac75396f4">vx_matrix</a> matrix = <a class="code" href="../../db/dba/group__group__matrix.html#ga60469797e6ebfc529887330ab076468c">vxCreateMatrix</a>(context, <a class="code" href="../../d4/dae/group__group__basic__features.html#gga44aa67e15168e5912a0800090a120be6aaa36bdf0ca05d4e93b1d5a4946570e16">VX_TYPE_FLOAT32</a>, columns, rows);</div>
<div class="line">    <a class="code" href="../../d4/dae/group__group__basic__features.html#ga64df90a05ff50c048d65ab77bc60e4f0">vx_status</a> status = <a class="code" href="../../d4/dae/group__group__basic__features.html#ga9ff8fafafe415f56a02e6a1825baac97">vxGetStatus</a>((<a class="code" href="../../dd/d90/group__group__reference.html#ga1a95c3bf180e49d4d1ecd64cb35f45a3">vx_reference</a>)matrix);</div>
<div class="line">    <span class="keywordflow">if</span> (status == <a class="code" href="../../d4/dae/group__group__basic__features.html#ggaa2387ff4d3e967f124fb316300503f92a1c066c6ca46bf666215a58b0b2221abb">VX_SUCCESS</a>)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="../../d4/dae/group__group__basic__features.html#ga822fc495cb9045d45893eed297d48737">vx_int32</a> j, i;</div>
<div class="line"><span class="preprocessor">#if defined(OPENVX_USE_C99)</span></div>
<div class="line"><span class="preprocessor"></span>        <a class="code" href="../../d4/dae/group__group__basic__features.html#gaf14ad5e46a20640307420a745d199e1d">vx_float32</a> mat[rows][columns]; <span class="comment">/* note: row major */</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>        <a class="code" href="../../d4/dae/group__group__basic__features.html#gaf14ad5e46a20640307420a745d199e1d">vx_float32</a> *mat = (<a class="code" href="../../d4/dae/group__group__basic__features.html#gaf14ad5e46a20640307420a745d199e1d">vx_float32</a> *)malloc(rows*columns*<span class="keyword">sizeof</span>(<a class="code" href="../../d4/dae/group__group__basic__features.html#gaf14ad5e46a20640307420a745d199e1d">vx_float32</a>));</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="../../db/dba/group__group__matrix.html#ga5a4912312011b9dbcf9230bd588d41f7">vxCopyMatrix</a>(matrix, mat, <a class="code" href="../../d1/dc3/group__group__context.html#ggadc2f56f2c0b0255308ce90746b454fe6a9405a00f7087f94be9c95bfbca5a98d8">VX_READ_ONLY</a>, <a class="code" href="../../d1/dc3/group__group__context.html#ggaeb1451df9727164fedf70723af2264b2acbf95a2ee31f2e48cf51ade3db9f4aba">VX_MEMORY_TYPE_HOST</a>) == <a class="code" href="../../d4/dae/group__group__basic__features.html#ggaa2387ff4d3e967f124fb316300503f92a1c066c6ca46bf666215a58b0b2221abb">VX_SUCCESS</a>) {</div>
<div class="line">            <span class="keywordflow">for</span> (j = 0; j &lt; (<a class="code" href="../../d4/dae/group__group__basic__features.html#ga822fc495cb9045d45893eed297d48737">vx_int32</a>)rows; j++)</div>
<div class="line">                <span class="keywordflow">for</span> (i = 0; i &lt; (<a class="code" href="../../d4/dae/group__group__basic__features.html#ga822fc495cb9045d45893eed297d48737">vx_int32</a>)columns; i++)</div>
<div class="line">#<span class="keywordflow">if</span> defined(OPENVX_USE_C99)</div>
<div class="line">                    mat[j][i] = (<a class="code" href="../../d4/dae/group__group__basic__features.html#gaf14ad5e46a20640307420a745d199e1d">vx_float32</a>)rand()/(<a class="code" href="../../d4/dae/group__group__basic__features.html#gaf14ad5e46a20640307420a745d199e1d">vx_float32</a>)RAND_MAX;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>                    mat[j*columns + i] = (<a class="code" href="../../d4/dae/group__group__basic__features.html#gaf14ad5e46a20640307420a745d199e1d">vx_float32</a>)rand()/(<a class="code" href="../../d4/dae/group__group__basic__features.html#gaf14ad5e46a20640307420a745d199e1d">vx_float32</a>)RAND_MAX;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>            <a class="code" href="../../db/dba/group__group__matrix.html#ga5a4912312011b9dbcf9230bd588d41f7">vxCopyMatrix</a>(matrix, mat, <a class="code" href="../../d1/dc3/group__group__context.html#ggadc2f56f2c0b0255308ce90746b454fe6af140b7ffd7e2f034287b322e407dfe0b">VX_WRITE_ONLY</a>, <a class="code" href="../../d1/dc3/group__group__context.html#ggaeb1451df9727164fedf70723af2264b2acbf95a2ee31f2e48cf51ade3db9f4aba">VX_MEMORY_TYPE_HOST</a>);</div>
<div class="line">        }</div>
<div class="line"><span class="preprocessor">#if !defined(OPENVX_USE_C99)</span></div>
<div class="line"><span class="preprocessor"></span>        free(mat);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    }</div>
</div><!-- fragment --> <h2><a class="anchor" id="sub_image_access"></a>
Image Access Example</h2>
<p>Images and Array differ slightly in how they are accessed due to more complex memory layout requirements.</p>
<div class="fragment"><div class="line">    <a class="code" href="../../d4/dae/group__group__basic__features.html#ga64df90a05ff50c048d65ab77bc60e4f0">vx_status</a> status = <a class="code" href="../../d4/dae/group__group__basic__features.html#ggaa2387ff4d3e967f124fb316300503f92a1c066c6ca46bf666215a58b0b2221abb">VX_SUCCESS</a>;</div>
<div class="line">    <span class="keywordtype">void</span> *base_ptr = NULL;</div>
<div class="line">    <a class="code" href="../../d4/dae/group__group__basic__features.html#ga1ddb983b9696cafdb4256c0df757171c">vx_uint32</a> width = 640, height = 480, plane = 0;</div>
<div class="line">    <a class="code" href="../../df/d09/group__group__image.html#gafaa07841fe324f1c1d5b0f27c27de7b5">vx_image</a> image = <a class="code" href="../../df/d09/group__group__image.html#gae7b0f2e7f1be975ad07055c9d7eef1a0">vxCreateImage</a>(context, width, height, <a class="code" href="../../d4/dae/group__group__basic__features.html#gga249dd49823433ffa16cf2e60ed25b7f1ad57c5881488a19029a9ce095f13932cb">VX_DF_IMAGE_U8</a>);</div>
<div class="line">    <a class="code" href="../../d4/dae/group__group__basic__features.html#dd/d11/structvx__rectangle__t">vx_rectangle_t</a> rect;</div>
<div class="line">    <a class="code" href="../../df/d09/group__group__image.html#d4/d7a/structvx__imagepatch__addressing__t">vx_imagepatch_addressing_t</a> addr;</div>
<div class="line">    <a class="code" href="../../df/d09/group__group__image.html#ga8fd401775d041066460dac11fef36abe">vx_map_id</a> map_id;</div>
<div class="line"></div>
<div class="line">    rect.<a class="code" href="../../d4/dae/group__group__basic__features.html#ab7cb39d467e8e8e0efe08431e35f8397">start_x</a> = rect.<a class="code" href="../../d4/dae/group__group__basic__features.html#ae2871975c8b902c837435a7f193faaa3">start_y</a> = 0;</div>
<div class="line">    rect.<a class="code" href="../../d4/dae/group__group__basic__features.html#acad6d4f2351b7bb779717f529763bc26">end_x</a> = rect.<a class="code" href="../../d4/dae/group__group__basic__features.html#a708920095a9e4589326039437015eeff">end_y</a> = PATCH_DIM;</div>
<div class="line"></div>
<div class="line">    status = <a class="code" href="../../df/d09/group__group__image.html#ga7f680c04462fcb05a0eae1a96dd923e3">vxMapImagePatch</a>(image, &amp;rect, plane, &amp;map_id,</div>
<div class="line">                                &amp;addr, &amp;base_ptr,</div>
<div class="line">                                <a class="code" href="../../d1/dc3/group__group__context.html#ggadc2f56f2c0b0255308ce90746b454fe6ac885a96e177eebbc289b0177346677ee">VX_READ_AND_WRITE</a>, <a class="code" href="../../d1/dc3/group__group__context.html#ggaeb1451df9727164fedf70723af2264b2acbf95a2ee31f2e48cf51ade3db9f4aba">VX_MEMORY_TYPE_HOST</a>, 0);</div>
<div class="line">    <span class="keywordflow">if</span> (status == <a class="code" href="../../d4/dae/group__group__basic__features.html#ggaa2387ff4d3e967f124fb316300503f92a1c066c6ca46bf666215a58b0b2221abb">VX_SUCCESS</a>)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="../../d4/dae/group__group__basic__features.html#ga1ddb983b9696cafdb4256c0df757171c">vx_uint32</a> x,y,i,j;</div>
<div class="line">        <a class="code" href="../../d4/dae/group__group__basic__features.html#gae3c17ecc60bf32f3e113766b10830aa4">vx_uint8</a> pixel = 0;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* a couple addressing options */</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">/* use linear addressing function/macro */</span></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; addr.<a class="code" href="../../df/d09/group__group__image.html#a3e817b04c32688a429bc804e740a2026">dim_x</a>*addr.<a class="code" href="../../df/d09/group__group__image.html#a904283b577503b16e52bff04dc9668cc">dim_y</a>; i++) {</div>
<div class="line">            <a class="code" href="../../d4/dae/group__group__basic__features.html#gae3c17ecc60bf32f3e113766b10830aa4">vx_uint8</a> *ptr2 = <a class="code" href="../../df/d09/group__group__image.html#ga0cbbec421058744f8d4e932c3b7e7260">vxFormatImagePatchAddress1d</a>(base_ptr,</div>
<div class="line">                                                         i, &amp;addr);</div>
<div class="line">            *ptr2 = pixel;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* 2d addressing option */</span></div>
<div class="line">        <span class="keywordflow">for</span> (y = 0; y &lt; addr.<a class="code" href="../../df/d09/group__group__image.html#a904283b577503b16e52bff04dc9668cc">dim_y</a>; y+=addr.<a class="code" href="../../df/d09/group__group__image.html#a0aea8b0d6d3b18d8b46cb21cfe606238">step_y</a>) {</div>
<div class="line">            <span class="keywordflow">for</span> (x = 0; x &lt; addr.<a class="code" href="../../df/d09/group__group__image.html#a3e817b04c32688a429bc804e740a2026">dim_x</a>; x+=addr.<a class="code" href="../../df/d09/group__group__image.html#a11879146df734d5d26b0e7fb69dfc800">step_x</a>) {</div>
<div class="line">                <a class="code" href="../../d4/dae/group__group__basic__features.html#gae3c17ecc60bf32f3e113766b10830aa4">vx_uint8</a> *ptr2 = <a class="code" href="../../df/d09/group__group__image.html#gafd66b7987853f58f018c34614ef4a1cd">vxFormatImagePatchAddress2d</a>(base_ptr,</div>
<div class="line">                                                             x, y, &amp;addr);</div>
<div class="line">                *ptr2 = pixel;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* direct addressing by client</span></div>
<div class="line"><span class="comment">         * for subsampled planes, scale will change</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        <span class="keywordflow">for</span> (y = 0; y &lt; addr.<a class="code" href="../../df/d09/group__group__image.html#a904283b577503b16e52bff04dc9668cc">dim_y</a>; y+=addr.<a class="code" href="../../df/d09/group__group__image.html#a0aea8b0d6d3b18d8b46cb21cfe606238">step_y</a>) {</div>
<div class="line">            <span class="keywordflow">for</span> (x = 0; x &lt; addr.<a class="code" href="../../df/d09/group__group__image.html#a3e817b04c32688a429bc804e740a2026">dim_x</a>; x+=addr.<a class="code" href="../../df/d09/group__group__image.html#a11879146df734d5d26b0e7fb69dfc800">step_x</a>) {</div>
<div class="line">                <a class="code" href="../../d4/dae/group__group__basic__features.html#gae3c17ecc60bf32f3e113766b10830aa4">vx_uint8</a> *tmp = (<a class="code" href="../../d4/dae/group__group__basic__features.html#gae3c17ecc60bf32f3e113766b10830aa4">vx_uint8</a> *)base_ptr;</div>
<div class="line">                i = ((addr.<a class="code" href="../../df/d09/group__group__image.html#ac2386b77b9262fd6e9219842375ff7d2">stride_y</a>*y*addr.<a class="code" href="../../df/d09/group__group__image.html#a36f91517cfea146f8a9c49b8e4160d58">scale_y</a>) /</div>
<div class="line">                      <a class="code" href="../../d4/dae/group__group__basic__features.html#gaccecc43fdc28478076941ef5a7d56da6">VX_SCALE_UNITY</a>) +</div>
<div class="line">                    ((addr.<a class="code" href="../../df/d09/group__group__image.html#aa2f0225f135d52d6402a46b197fa5b21">stride_x</a>*x*addr.<a class="code" href="../../df/d09/group__group__image.html#a9801c1ec00e484788b23a7ae860d843d">scale_x</a>) /</div>
<div class="line">                      <a class="code" href="../../d4/dae/group__group__basic__features.html#gaccecc43fdc28478076941ef5a7d56da6">VX_SCALE_UNITY</a>);</div>
<div class="line">                tmp[i] = pixel;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* more efficient direct addressing by client.</span></div>
<div class="line"><span class="comment">         * for subsampled planes, scale will change.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        <span class="keywordflow">for</span> (y = 0; y &lt; addr.<a class="code" href="../../df/d09/group__group__image.html#a904283b577503b16e52bff04dc9668cc">dim_y</a>; y+=addr.<a class="code" href="../../df/d09/group__group__image.html#a0aea8b0d6d3b18d8b46cb21cfe606238">step_y</a>) {</div>
<div class="line">            j = (addr.<a class="code" href="../../df/d09/group__group__image.html#ac2386b77b9262fd6e9219842375ff7d2">stride_y</a>*y*addr.<a class="code" href="../../df/d09/group__group__image.html#a36f91517cfea146f8a9c49b8e4160d58">scale_y</a>)/<a class="code" href="../../d4/dae/group__group__basic__features.html#gaccecc43fdc28478076941ef5a7d56da6">VX_SCALE_UNITY</a>;</div>
<div class="line">            <span class="keywordflow">for</span> (x = 0; x &lt; addr.<a class="code" href="../../df/d09/group__group__image.html#a3e817b04c32688a429bc804e740a2026">dim_x</a>; x+=addr.<a class="code" href="../../df/d09/group__group__image.html#a11879146df734d5d26b0e7fb69dfc800">step_x</a>) {</div>
<div class="line">                <a class="code" href="../../d4/dae/group__group__basic__features.html#gae3c17ecc60bf32f3e113766b10830aa4">vx_uint8</a> *tmp = (<a class="code" href="../../d4/dae/group__group__basic__features.html#gae3c17ecc60bf32f3e113766b10830aa4">vx_uint8</a> *)base_ptr;</div>
<div class="line">                i = j + (addr.<a class="code" href="../../df/d09/group__group__image.html#aa2f0225f135d52d6402a46b197fa5b21">stride_x</a>*x*addr.<a class="code" href="../../df/d09/group__group__image.html#a9801c1ec00e484788b23a7ae860d843d">scale_x</a>) /</div>
<div class="line">                    <a class="code" href="../../d4/dae/group__group__basic__features.html#gaccecc43fdc28478076941ef5a7d56da6">VX_SCALE_UNITY</a>;</div>
<div class="line">                tmp[i] = pixel;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* this commits the data back to the image.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        status = <a class="code" href="../../df/d09/group__group__image.html#ga251504d5e0c254143e0d0e1077c71181">vxUnmapImagePatch</a>(image, map_id);</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="../../df/d09/group__group__image.html#gab9d76afb39de187cf82faf9827eab9f1">vxReleaseImage</a>(&amp;image);</div>
</div><!-- fragment --> <h2><a class="anchor" id="sub_array_access"></a>
Array Access Example</h2>
<p>Arrays only require a single value, the stride, instead of the entire addressing structure that images need.</p>
<div class="fragment"><div class="line">        <a class="code" href="../../d4/dae/group__group__basic__features.html#ga46d89d47ad9a2de1de723d0db861d324">vx_size</a> i, stride = <span class="keyword">sizeof</span>(<a class="code" href="../../d4/dae/group__group__basic__features.html#ga46d89d47ad9a2de1de723d0db861d324">vx_size</a>);</div>
<div class="line">        <span class="keywordtype">void</span> *base = NULL;</div>
<div class="line">        <a class="code" href="../../df/d09/group__group__image.html#ga8fd401775d041066460dac11fef36abe">vx_map_id</a> map_id;</div>
<div class="line">        <span class="comment">/* access entire array at once */</span></div>
<div class="line">        <a class="code" href="../../d5/d8e/group__group__array.html#ga532c755084f03ab9089f24bae92ca8ab">vxMapArrayRange</a>(array, 0, num_items, &amp;map_id, &amp;stride, &amp;base, <a class="code" href="../../d1/dc3/group__group__context.html#ggadc2f56f2c0b0255308ce90746b454fe6ac885a96e177eebbc289b0177346677ee">VX_READ_AND_WRITE</a>, <a class="code" href="../../d1/dc3/group__group__context.html#ggaeb1451df9727164fedf70723af2264b2acbf95a2ee31f2e48cf51ade3db9f4aba">VX_MEMORY_TYPE_HOST</a>, 0);</div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; num_items; i++)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="../../d5/d8e/group__group__array.html#ga9b10bfd44f918317c122467f6e22b3ba">vxArrayItem</a>(mystruct, base, i, stride).some_uint += i;</div>
<div class="line">            <a class="code" href="../../d5/d8e/group__group__array.html#ga9b10bfd44f918317c122467f6e22b3ba">vxArrayItem</a>(mystruct, base, i, stride).some_double = 3.14f;</div>
<div class="line">        }</div>
<div class="line">        <a class="code" href="../../d5/d8e/group__group__array.html#ga5d9be9157b753e561b1a6b5d2d1c0fd4">vxUnmapArrayRange</a>(array, map_id);</div>
</div><!-- fragment --><p> Map/Unmap pairs can also be called on individual elements of array using a method similar to this:</p>
<div class="fragment"><div class="line">        <span class="comment">/* access each array item individually */</span></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; num_items; i++)</div>
<div class="line">        {</div>
<div class="line">            mystruct *myptr = NULL;</div>
<div class="line">            <a class="code" href="../../d5/d8e/group__group__array.html#ga532c755084f03ab9089f24bae92ca8ab">vxMapArrayRange</a>(array, i, i+1, &amp;map_id, &amp;stride, (<span class="keywordtype">void</span> **)&amp;myptr, <a class="code" href="../../d1/dc3/group__group__context.html#ggadc2f56f2c0b0255308ce90746b454fe6ac885a96e177eebbc289b0177346677ee">VX_READ_AND_WRITE</a>, <a class="code" href="../../d1/dc3/group__group__context.html#ggaeb1451df9727164fedf70723af2264b2acbf95a2ee31f2e48cf51ade3db9f4aba">VX_MEMORY_TYPE_HOST</a>, 0);</div>
<div class="line">            myptr-&gt;some_uint += 1;</div>
<div class="line">            myptr-&gt;some_double = 3.14f;</div>
<div class="line">            <a class="code" href="../../d5/d8e/group__group__array.html#ga5d9be9157b753e561b1a6b5d2d1c0fd4">vxUnmapArrayRange</a>(array, map_id);</div>
<div class="line">        }</div>
</div><!-- fragment --> <h1><a class="anchor" id="sec_concurrent_access"></a>
Concurrent Data Object Access</h1>
<p>Accessing OpenVX data-objects using the functions Map, Copy, Read concurrently to an execution of a graph that is accessing the same data objects is permitted only if all accesses are read-only. That is, for Map, Copy to have a read-only access mode and for nodes in the graph to have that data-object as an input parameter only. In all other cases, including write or read-write modes and Write access function, as well as a graph nodes having the data-object as output or bidirectional, the application must guarantee that the access is not performed concurrently with the graph execution. That can be achieved by calling un-map following a map and commit following access before calling <code><a class="el" href="../../d9/d7f/group__group__graph.html#ga718b5f98fd11581ec102303ce94f45b2">vxScheduleGraph</a></code> or <code><a class="el" href="../../d9/d7f/group__group__graph.html#ga36b37f13ca2269258b813955f7089873">vxProcessGraph</a></code>. In addition, the application must call <code><a class="el" href="../../d9/d7f/group__group__graph.html#ga201e9fa88779f902d09009ad11b8f083">vxWaitGraph</a></code> after <code><a class="el" href="../../d9/d7f/group__group__graph.html#ga718b5f98fd11581ec102303ce94f45b2">vxScheduleGraph</a></code> before calling Map, Read, Write or Copy to avoid restricted concurrent access. An application that fails to follow the above might encounter an undefined behavior and/or data loss without being notified by the OpenVX framework. Accessing images created from ROI (<code><a class="el" href="../../df/d09/group__group__image.html#gaf8f9ca43fb8aed127aef27d24d39e4af">vxCreateImageFromROI</a></code>) must be treated in this respect as if the entire image is being accessed.</p>
<ul>
<li>Setting an attribute is considered as writing to a data object in this respect.</li>
<li>For concurrent execution of several graphs please see <a class="el" href="../../d0/d84/page_design.html#sub_graphs_execution">Execution Model</a></li>
<li>Also see the graph formalism section for guidance on accessing ROIs of the same image within a graph.</li>
</ul>
<h1><a class="anchor" id="sec_valid_region"></a>
Valid Image Region</h1>
<p>The valid region mechanism informs the application as to which pixels of the output images of a graph's execution have valid values (see valid pixel definition below). The mechanism also applies to immediate mode (VXU) calls, and supports the communication of the valid region between different graph executions. Some vision functions, mainly those providing statistics and summarization of image information, use the valid region to ignore pixels that are not valid on their inputs (potentially bad or unstable pixel values). A good example of such a function is Min/Max Location. Formalization of the valid region mechanism is given below.</p>
<ul>
<li>Valid Pixels - All output pixels of an OpenVX function are considered valid by default, unless their calculation depends on input pixels that are not valid. An input pixel is not valid in one of two situations: <ol>
<li>
The pixel is outside of the image border and the border mode in use is <code><a class="el" href="../../dc/de4/group__group__borders.html#gga2430709469c374c6fadfac72abbbcbb4aef25f2567896eb2dda48c2869030664f">VX_BORDER_UNDEFINED</a></code>  </li>
<li>
The pixel is outside the valid region of the input image.  </li>
</ol>
</li>
<li>Valid Region - The region in the image that contains all the valid pixels. Theoretically this can be of any shape. OpenVX currently only supports rectangular valid regions. In subsequent text the term 'valid rectangle' denotes a valid region that is rectangular in shape.</li>
<li>Valid Rectangle Reset - In some cases it is not possible to calculate a valid rectangle for the output image of a vision function (for example, warps and remap). In such cases, the vision function is said to reset the valid Region to the entire image. The attribute <code><a class="el" href="../../d7/d61/group__group__node.html#gga6698e2a55aa6d7fd5c45e746a0d640b9aa674356b35e4bd1b12a433abdd71cd00">VX_NODE_VALID_RECT_RESET</a></code> is a read only attribute and is used to communicate valid rectangle reset behavior to the application. When it is set to <code><a class="el" href="../../d4/dae/group__group__basic__features.html#gga7ab7c7864a0ea6762a9e15be80ef28f0a2a695a4d881a8c863881d4f1f88d6442">vx_true_e</a></code> for a given node the valid rectangle of the output images will reset to the full image upon execution of the node, when it is set to <code><a class="el" href="../../d4/dae/group__group__basic__features.html#gga7ab7c7864a0ea6762a9e15be80ef28f0afb2a8f065f221fda7ecac976517a28f3">vx_false_e</a> </code> the valid rectangle will be calculated. All standard OpenVX functions will have this attribute set to <code><a class="el" href="../../d4/dae/group__group__basic__features.html#gga7ab7c7864a0ea6762a9e15be80ef28f0afb2a8f065f221fda7ecac976517a28f3">vx_false_e</a> </code> by default, except for Warp and Remap where it will be set to <code><a class="el" href="../../d4/dae/group__group__basic__features.html#gga7ab7c7864a0ea6762a9e15be80ef28f0a2a695a4d881a8c863881d4f1f88d6442">vx_true_e</a></code>.</li>
<li>Valid Rectangle Initialization - Upon the creation of an image, its valid rectangle is the entire image. One exception to this is when creating an image via <code><a class="el" href="../../df/d09/group__group__image.html#gaf8f9ca43fb8aed127aef27d24d39e4af">vxCreateImageFromROI</a></code>; in that case, the valid region of the ROI image is the subset of the valid region of the parent image that is within the ROI. In other words, the valid region of an image created using an ROI is the largest rectangle that contains valid pixels in the parent image.</li>
<li>Valid Rectangle Calculation - The valid rectangle of an image changes as part of the graph execution, the correct value is guaranteed only when the execution finishes. The valid rectangle of an image remains unchanged between graph executions and persists between graph executions as long as the application doesn't explicitly change the valid region via <code><a class="el" href="../../df/d09/group__group__image.html#ga1ca44f61b0e41b49a145f26f9215ef43">vxSetImageValidRectangle</a></code>. Notice that using <code><a class="el" href="../../df/d09/group__group__image.html#ga7f680c04462fcb05a0eae1a96dd923e3">vxMapImagePatch</a></code>, <code><a class="el" href="../../df/d09/group__group__image.html#ga251504d5e0c254143e0d0e1077c71181">vxUnmapImagePatch</a></code> or <code><a class="el" href="../../df/d09/group__group__image.html#ga95876e3ba7123ff80a51fdc55a0cf5c0">vxSwapImageHandle</a></code> does not change the valid region of an image.</li>
<li>Valid Rectangle for Immediate mode (VXU) - VXU is considered a single node graph execution, thus the valid rectangle of an output of VXU will be propagated for an input to a consequent VXU call (when using the same output image from one call as input to the consecutive call).</li>
<li>Valid Region Usage - For all standard OpenVX functions, the framework must guarantee that all pixel values inside the valid rectangle of the output images are valid. The framework does not guarantee that input pixels outside of the valid rectangle are processed. For the following vision functions, the framework guarantees that pixels outside of the valid rectangle do not participate in calculating the vision function result: Equalize Histogram, Integral Image, Fast Corners, Histogram, Mean and Standard Deviation, Min Max Location, Optical Flow Pyramid (LK) and Canny Edge Detector. An application can get the valid rectangle of an image by using <code><a class="el" href="../../df/d09/group__group__image.html#ga9d77b2b8edd3f17da0d74c8fc6674085">vxGetValidRegionImage</a></code>.</li>
<li>User kernels - User kernels may change the valid rectangles of their output images. To change the valid rectangle, the programmer of the user kernel must provide a call-back function that sets the valid rectangle. The output validator of the user kernel must provide this callback by setting the value of the <code><a class="el" href="../../da/d83/group__group__user__kernels.html#gabfa72c9eff71470a4c96e3cab7dbe838">vx_meta_format</a></code> attribute <code><a class="el" href="../../da/d83/group__group__user__kernels.html#gga244bdb2fc3ebac38195a2be5dc37d99ba7092061036dc800df5ae31b2b841f6ff">VX_VALID_RECT_CALLBACK</a></code> during the output validator. The callback function must be callable by the OpenVX framework during graph validation and execution. Assumptions must not be made regarding the order and the frequency by which the valid rectangle callback is called. The framework will recalculate the valid region when a change in the input valid regions is detected. For user nodes, the default value of <code><a class="el" href="../../d7/d61/group__group__node.html#gga6698e2a55aa6d7fd5c45e746a0d640b9aa674356b35e4bd1b12a433abdd71cd00">VX_NODE_VALID_RECT_RESET</a></code> is <code><a class="el" href="../../d4/dae/group__group__basic__features.html#gga7ab7c7864a0ea6762a9e15be80ef28f0a2a695a4d881a8c863881d4f1f88d6442">vx_true_e</a></code>. Setting <code><a class="el" href="../../da/d83/group__group__user__kernels.html#gga244bdb2fc3ebac38195a2be5dc37d99ba7092061036dc800df5ae31b2b841f6ff">VX_VALID_RECT_CALLBACK</a></code> during parameter validation to a value other than NULL will result in setting <code><a class="el" href="../../d7/d61/group__group__node.html#gga6698e2a55aa6d7fd5c45e746a0d640b9aa674356b35e4bd1b12a433abdd71cd00">VX_NODE_VALID_RECT_RESET</a></code> to <code><a class="el" href="../../d4/dae/group__group__basic__features.html#gga7ab7c7864a0ea6762a9e15be80ef28f0afb2a8f065f221fda7ecac976517a28f3">vx_false_e</a></code>. Note: the above means that when <code><a class="el" href="../../da/d83/group__group__user__kernels.html#gga244bdb2fc3ebac38195a2be5dc37d99ba7092061036dc800df5ae31b2b841f6ff">VX_VALID_RECT_CALLBACK</a></code> is not set or set to NULL the user-node will reset the valid rectangle to the entire image.</li>
<li>In addition, valid rectangle reset occurs in the following scenarios: <ol>
<li>
A reset of the valid rectangle of a parent image when a node writes to one of its ROIs. The only case where the reset does not occur is when the child ROI image is identical to the parent image.  </li>
<li>
For nodes that have the <code><a class="el" href="../../d7/d61/group__group__node.html#gga6698e2a55aa6d7fd5c45e746a0d640b9aa674356b35e4bd1b12a433abdd71cd00">VX_NODE_VALID_RECT_RESET</a></code> set to <code><a class="el" href="../../d4/dae/group__group__basic__features.html#gga7ab7c7864a0ea6762a9e15be80ef28f0a2a695a4d881a8c863881d4f1f88d6442">vx_true_e</a></code>  </li>
</ol>
</li>
</ul>
<h1><a class="anchor" id="sec_extending"></a>
Extending OpenVX</h1>
<p>Beyond <a class="el" href="../../d0/d84/page_design.html#sec_user_kernels">User Kernels</a> there are other mechanisms for vendors to extend features in OpenVX. These mechanisms are not available to User Kernels. Each OpenVX official extension has a unique identifier, comprised of capital letters, numbers and the underscore character, prefixed with "KHR_", for example "KHR_NEW_FEATURE".</p>
<h2><a class="anchor" id="sub_attribute_extensions"></a>
Extending Attributes</h2>
<p>When extending attributes, vendors <em>must</em> use their assigned ID from <code><a class="el" href="../../d4/dae/group__group__basic__features.html#ga49682f34339161ba7594f52aa8d59c1c">vx_vendor_id_e</a></code> in conjunction with the appropriate macros for creating new attributes with <code><a class="el" href="../../d4/dae/group__group__basic__features.html#gaa3d7c5da21e23c3b0747091591fe1afa">VX_ATTRIBUTE_BASE</a></code>. The typical mechanism to extend a new attribute for some object type (for example a <code><a class="el" href="../../d7/d61/group__group__node.html#ga7f1b5d91fac63093ee3a77e87d942f96">vx_node</a></code> attribute from <code><a class="el" href="../../d4/dae/group__group__basic__features.html#gga49682f34339161ba7594f52aa8d59c1cabdf546df1dd991b0aacdbba7980fa7cd">VX_ID_TI</a></code>) would look like this:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> {</div>
<div class="line">   VX_NODE_TI_NEWTHING = <a class="code" href="../../d4/dae/group__group__basic__features.html#gaa3d7c5da21e23c3b0747091591fe1afa">VX_ATTRIBUTE_BASE</a>(<a class="code" href="../../d4/dae/group__group__basic__features.html#gga49682f34339161ba7594f52aa8d59c1cabdf546df1dd991b0aacdbba7980fa7cd">VX_ID_TI</a>, <a class="code" href="../../d4/dae/group__group__basic__features.html#gga44aa67e15168e5912a0800090a120be6a1b3fff82901acfb0df4aaf1906ca9596">VX_TYPE_NODE</a>) + 0x0,</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="sub_kernel_extensions"></a>
Vendor Custom Kernels</h2>
<p>Vendors wanting to add more kernels to the base set supplied to OpenVX should provide a header of the form </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;VX/vx_ext_&lt;vendor&gt;</span>.h&gt;</div>
</div><!-- fragment --><p> that contains definitions of each of the following. </p>
<ul>
<li>New Node Creation Function Prototype per function. <div class="fragment"><div class="line"></div>
<div class="line"><a class="code" href="../../d7/d61/group__group__node.html#ga7f1b5d91fac63093ee3a77e87d942f96">vx_node</a> vxXYZNode(<a class="code" href="../../d9/d7f/group__group__graph.html#ga7e71c08b1777e49abaf4417506ca8451">vx_graph</a> graph, <a class="code" href="../../df/d09/group__group__image.html#gafaa07841fe324f1c1d5b0f27c27de7b5">vx_image</a> input, <a class="code" href="../../d4/dae/group__group__basic__features.html#ga1ddb983b9696cafdb4256c0df757171c">vx_uint32</a> value, <a class="code" href="../../df/d09/group__group__image.html#gafaa07841fe324f1c1d5b0f27c27de7b5">vx_image</a> output, <a class="code" href="../../d5/d8e/group__group__array.html#gab1f0193f8a470dd2fe10de539a533697">vx_array</a> temp);</div>
</div><!-- fragment --> </li>
<li>A new Kernel Enumeration(s) and Kernel String per function. <div class="fragment"><div class="line"><span class="preprocessor">#define VX_KERNEL_NAME_KHR_XYZ &quot;org.khronos.example.xyz&quot;</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define VX_LIBRARY_XYZ (0x3) // assigned from Khronos, vendors control their own</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="keyword">enum</span> vx_kernel_xyz_ext_e {</div>
<div class="line">    VX_KERNEL_KHR_XYZ = <a class="code" href="../../d4/dae/group__group__basic__features.html#gadf866bd868ffb9a8c8dc157c2c541f40">VX_KERNEL_BASE</a>(<a class="code" href="../../d4/dae/group__group__basic__features.html#gga49682f34339161ba7594f52aa8d59c1ca7d6af4111ec80fa29c7cad71b89841dc">VX_ID_DEFAULT</a>, VX_LIBRARY_XYZ) + 0x0,</div>
<div class="line">    <span class="comment">// up to 0xFFF kernel enums can be created.</span></div>
<div class="line">};</div>
</div><!-- fragment --> </li>
<li>A new VXU Function per function. <div class="fragment"><div class="line"></div>
<div class="line"><a class="code" href="../../d4/dae/group__group__basic__features.html#ga64df90a05ff50c048d65ab77bc60e4f0">vx_status</a> vxuXYZ(<a class="code" href="../../d1/dc3/group__group__context.html#ga0f4f894d935fbf50bf38b3529a001249">vx_context</a> context, <a class="code" href="../../df/d09/group__group__image.html#gafaa07841fe324f1c1d5b0f27c27de7b5">vx_image</a> input, <a class="code" href="../../d4/dae/group__group__basic__features.html#ga1ddb983b9696cafdb4256c0df757171c">vx_uint32</a> value, <a class="code" href="../../df/d09/group__group__image.html#gafaa07841fe324f1c1d5b0f27c27de7b5">vx_image</a> output, <a class="code" href="../../d5/d8e/group__group__array.html#gab1f0193f8a470dd2fe10de539a533697">vx_array</a> temp);</div>
</div><!-- fragment --> This should come with good documentation for each new part of the extension. Ideally, these sorts of extensions should not require linking to new objects to facilitate usage.</li>
</ul>
<h2><a class="anchor" id="sub_framework_extensions"></a>
Vendor Custom Extensions</h2>
<p>Some extensions affect <em>base</em> vision functions and thus may be invisible to most users. In these circumstances, the vendor must report the supported extensions to the base nodes through the <code><a class="el" href="../../d1/dc3/group__group__context.html#gga7f849c7db71cc56b2a554d7d342ff421a784fe616980de2412ad031eea0b23d47">VX_CONTEXT_EXTENSIONS</a></code> attribute on the context.</p>
<div class="fragment"><div class="line">    <a class="code" href="../../d4/dae/group__group__basic__features.html#ga9ce3f44bccc95f52b9897df2b3620713">vx_char</a> *tmp, *extensions = NULL;</div>
<div class="line">    <a class="code" href="../../d4/dae/group__group__basic__features.html#ga46d89d47ad9a2de1de723d0db861d324">vx_size</a> size = 0;</div>
<div class="line">    <a class="code" href="../../d1/dc3/group__group__context.html#ga9f5c06778936c587051184ac0358abfd">vxQueryContext</a>(context,<a class="code" href="../../d1/dc3/group__group__context.html#gga7f849c7db71cc56b2a554d7d342ff421a451e58a67e4061962dccfa4d3c3934d1">VX_CONTEXT_EXTENSIONS_SIZE</a>,&amp;size,<span class="keyword">sizeof</span>(size));</div>
<div class="line">    extensions = malloc(size);</div>
<div class="line">    <a class="code" href="../../d1/dc3/group__group__context.html#ga9f5c06778936c587051184ac0358abfd">vxQueryContext</a>(context,<a class="code" href="../../d1/dc3/group__group__context.html#gga7f849c7db71cc56b2a554d7d342ff421a784fe616980de2412ad031eea0b23d47">VX_CONTEXT_EXTENSIONS</a>,</div>
<div class="line">                   extensions, size);</div>
</div><!-- fragment --><p> Extensions in this list are dependent on the extension itself; they may or may not have a header and new kernels or framework feature or data objects. The common feature is that they are implemented and supported by the implementation vendor.</p>
<h2><a class="anchor" id="sub_hints"></a>
Hinting</h2>
<p>The specification defines a Hinting API that allows Clients to feed information to the implementation for <em>optional</em> behavior changes. See <a class="el" href="../../d6/d28/group__group__hint.html">Framework: Hints</a>. It is assumed that most of the hints will be vendor- or implementation-specific. Check with the OpenVX implementation vendor for information on vendor-specific extensions.</p>
<h2><a class="anchor" id="sub_directives"></a>
Directives</h2>
<p>The specification defines a Directive API to control implementation behavior. See <a class="el" href="../../dc/d94/group__group__directive.html">Framework: Directives</a>. This <em>may</em> allow things like disabling parallelism for debugging, enabling cache writing-through for some buffers, or any implementation-specific optimization.</p>
<h1><a class="anchor" id="sec_known_extensions"></a>
Known Extensions to OpenVX</h1>
<h2><a class="anchor" id="sub_node_tiling_ext"></a>
User Kernel Tiling</h2>
<p>The User Kernel Tiling facility enables optimizations of the user kernels (e.g., locality of execution or parallelism) when performing computation on the image data. Modern processors have a diverse memory hierarchy that varies from relatively small but fast and expensive memory to relatively large but slow and inexpensive memory. Image data are typically too large to fit into the fast but small memory. The ability to break the image data into smaller sized units allows for optimized computation on these smaller units with fast memory access or parallel execution of a user kernel on multiple image tiles simultaneously. The OpenVX Graph Manager possesses the knowledge about the memory hierarchy of the platform and is hence in a position to break the image data into smaller units for memory optimization. Knowledge of the memory access pattern of an algorithm is key for the graph manager to enable optimizations.</p>
<p>The Khronos OpenVX Working Group will include this extension as part of the future version of this specification, contingent on community feedback.</p>
 

 <h2>Copyright</h2>
 <p>The Khronos Group 2011-2016. OpenVX&trade;, OpenCL&trade;, OpenGL&trade;, and OpenMAX&trade; are trademarks of the Khronos Group&trade;.</p>

 <p>Copyright &copy; 2016 The Khronos Group Inc. All Rights Reserved.</p>

 <p>This specification is protected by copyright laws and contains material proprietary to the Khronos Group, Inc. It or any components may not be reproduced, republished, distributed, transmitted, displayed, broadcast or otherwise exploited in any manner without the express prior written permission of Khronos Group. You may use this specification for implementing the functionality therein, without altering or removing any trademark, copyright or other notice from the specification, but the receipt or possession of this specification does not convey any rights to reproduce, disclose, or distribute its contents, or to manufacture, use, or sell anything that it may describe, in whole or in part.</p>

 <p>Khronos Group grants express permission to any current Promoter, Contributor or Adopter member of Khronos to copy and redistribute UNMODIFIED versions of this specification in any fashion, provided that NO CHARGE is made for the specification and the latest available update of the specification for any version of the API is used whenever possible.  Such distributed specification may be re-formatted AS LONG AS the contents of the specification are not changed in any way.  The specification may be incorporated into a product that is sold as long as such product includes significant independent work developed by the seller.   A link to the current version of this specification on the Khronos Group web-site should be included whenever possible with specification distributions.</p>

 <p>Khronos Group makes no, and expressly disclaims any, representations or warranties, express or implied, regarding this specification, including, without limitation, any implied warranties of merchantability or fitness for a particular purpose or non-infringement of any intellectual property. Khronos Group makes no, and expressly disclaims any, warranties, express or implied, regarding the correctness, accuracy, completeness, timeliness, and reliability of the specification. Under no circumstances will the Khronos Group, or any of its Promoters, Contributors or Members or their respective partners, officers, directors, employees, agents or representatives be liable for any damages, whether direct, indirect, special or consequential damages for lost revenues, lost profits, or otherwise, arising from or in connection with these materials.</p>

 <p>Khronos, DevU, StreamInput, glTF, WebGL, WebCL, COLLADA, OpenKODE, OpenVG, OpenVX, OpenSL ES and OpenMAX are trademarks of the Khronos Group Inc.  ASTC is a trademark of ARM Holdings PLC, OpenCL is a trademark of Apple Inc. and OpenGL is a registered trademark and the OpenGL ES and OpenGL SC logos are trademarks of Silicon Graphics International used under license by Khronos.  All other product names, trademarks, and/or company names are used solely for identification and belong to their respective owners.</p>

  </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Sep 20 2016 15:46:09 for The OpenVX Specification by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
