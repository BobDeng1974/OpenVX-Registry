<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVX Graph Pipelining Extension: Design Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenVX_170px_June16.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVX Graph Pipelining Extension
   &#160;<span id="projectnumber">950f130</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_design.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Design Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="data_references"></a>
Data reference</h1>
<p>In this extension, the term 'data reference' is used frequently. In this section we define this term.</p>
<p>Data references are OpenVX references to any of the OpenVX data types listed below,</p><ul>
<li>VX_TYPE_LUT</li>
<li>VX_TYPE_DISTRIBUTION</li>
<li>VX_TYPE_PYRAMID</li>
<li>VX_TYPE_THRESHOLD</li>
<li>VX_TYPE_MATRIX</li>
<li>VX_TYPE_CONVOLUTION</li>
<li>VX_TYPE_SCALAR</li>
<li>VX_TYPE_ARRAY</li>
<li>VX_TYPE_IMAGE</li>
<li>VX_TYPE_REMAP</li>
<li>VX_TYPE_OBJECT_ARRAY</li>
<li>VX_TYPE_TENSOR (OpenVX 1.2 and above)</li>
</ul>
<p>The APIs which operate on data references take as input a <code>vx_reference</code> type. An application can pass any of the above defined data type references to such an API.</p>
<h1><a class="anchor" id="sec_design_pipelining"></a>
Pipelining and Batch Processing</h1>
<p>Pipelining and Batch Processing APIs allow an application to construct a graph which can be executed in a pipelined fashion (see <a class="el" href="index.html#sec_pipelining">Graph Pipelining</a>), or batch processing fashion (see <a class="el" href="index.html#sec_batch_processing">Graph Batch Processing</a>).</p>
<h2><a class="anchor" id="sec_design_queue"></a>
Graph Parameter Queues</h2>
<p>The concept of OpenVX "Graph Parameters" is defined in the main OpenVX spec as a means to expose external ports of a graph. Graph parameters enable the abstraction of the remaining graph ports which are not connected as graph parameters. Since graph pipelining and batching is concerned primarily with controlling the flow of data to and from the graph, OpenVX graph parameters provide a useful construct for enabling pipelining and batching.</p>
<p>This extension introduces the concept of <b>graph parameter queueing</b> to enable assigning multiple data objects to a graph parameter (either at once, or spaced in time) without needing to wait for the previous graph completion(s). At runtime, the application can utilize the <code><a class="el" href="d7/d94/group__group__pipelining.html#gae8570fab78fc47b2258b5ee296a6aae4">vxGraphParameterEnqueueReadyRef</a></code> function to enqueue a number of data references into a graph parameter to be used by the graph. Likewise, the application can use the <code><a class="el" href="d7/d94/group__group__pipelining.html#ga5e1cf3af554ea41fcf6e8140bc6e46f4">vxGraphParameterDequeueDoneRef</a></code> function to dequeue a number of data references from a graph parameter after the graph is done using them (thus, making them available for the application). The <code><a class="el" href="d7/d94/group__group__pipelining.html#ga5badde82c260e46de01106615ec25913">vxGraphParameterCheckDoneRef</a></code> function is a non-blocking call that can be used to determine if there are references available for dequeuing, and if so, how many.</p>
<p>In order for the implementation to know which graph parameters it needs to support queuing on, the application should configure this by calling <code><a class="el" href="d7/d94/group__group__pipelining.html#ga4a050fb0e974eaf1532e0cef243a7731">vxSetGraphScheduleConfig</a></code> before calling vxVerifyGraph or vxScheduleGraph.</p>
<h2><a class="anchor" id="sec_graph_schedule_config"></a>
Graph Schedule Configuration</h2>
<p>The graph schedule configuration function (<code><a class="el" href="d7/d94/group__group__pipelining.html#ga4a050fb0e974eaf1532e0cef243a7731">vxSetGraphScheduleConfig</a></code>) allows users to enable enqueuing of multiple input and output references to a graph parameter. It also allows users to control how the graph gets scheduled based on the references enqueued by the user.</p>
<p>The <code>graph_schedule_mode</code> parameter defines two modes of graph scheduling:</p><ol type="1">
<li><code><a class="el" href="d7/d94/group__group__pipelining.html#ggaf3e082f7326cf34b0ba143b8756f126ca14cf92647f3b25c7c8ae18805703f534">VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</a></code><ul>
<li>Here the application enqueues the references to be processed at a graph parameter</li>
<li>Later when application calls <code>vxScheduleGraph</code>, all the previously enqueued references get processed.</li>
<li>Enqueuing multiple references and calling a single <code>vxScheduleGraph</code> allows implementation flexibility to optimize the execution of the multiple graph executions based on the number of the enqueued references.</li>
</ul>
</li>
<li><code><a class="el" href="d7/d94/group__group__pipelining.html#ggaf3e082f7326cf34b0ba143b8756f126ca24051853304870234f5a58b225045478">VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</a></code><ul>
<li>Here also, the user enqueues the references that they want to process at a graph parameter</li>
<li>However here user does not explicitly call <code>vxScheduleGraph</code></li>
<li><code>vxVerifyGraph</code> <em>must</em> be called in this mode (since <code>vxScheduleGraph</code> is not called).</li>
<li>The implementation automatically triggers graph execution when it has enough enqueued references to start a graph execution</li>
<li>Enqueuing multiple references without calling <code>vxScheduleGraph</code> allows the implementation to start a graph execution as soon as minimal input or output references are available.</li>
</ul>
</li>
</ol>
<p>In both of these modes, <code>vxProcessGraph</code> is not allowed. The next two sections show how the graph schedule configuration, along with reference enqueue and dequeue is used to realize the graph pipelining and batch processing use-cases.</p>
<h2><a class="anchor" id="sec_queue"></a>
Example Graph pipelining application</h2>
<p>Graph pipelining allow users to schedule a graph multiple times, without having to wait for a graph execution to complete. Each such execution of the graph operates on different input or output references.</p>
<p>In a typical pipeline execution model, there is a pipe-up phase where new inputs are enqueued and graph is scheduled multiple times until the pipeline is full. Once the pipeline is full, then outputs begin to be filled as often as inputs are enqueued (as shown in <a class="el" href="index.html#Figure_1-3">Figure_1-3</a>).</p>
<p><a class="anchor" id="four"></a> </p><div class="image">
<img src="pipe_updown.png" alt="pipe_updown.png"/>
</div>
 <p>In order for the graph to be executed in a pipelined fashion, the steps outlined below need to be followed by an application:</p><ol type="1">
<li>Create a graph and add nodes to the graph as usual.</li>
<li>For data references which need to be enqueued and dequeued by the application, add them as graph parameters.</li>
<li>Call <code> <a class="el" href="d7/d94/group__group__pipelining.html#ga4a050fb0e974eaf1532e0cef243a7731">vxSetGraphScheduleConfig</a></code> with the parameters as follows:<ol type="a">
<li>Set scheduling mode (<code><a class="el" href="d7/d94/group__group__pipelining.html#ggaf3e082f7326cf34b0ba143b8756f126ca14cf92647f3b25c7c8ae18805703f534">VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</a></code> or <code><a class="el" href="d7/d94/group__group__pipelining.html#ggaf3e082f7326cf34b0ba143b8756f126ca24051853304870234f5a58b225045478">VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</a></code>).</li>
<li>List the graph parameters on which enqueue / dequeue operations are required.</li>
<li>For these parameters specify the list of references that could be enqueued later.</li>
</ol>
</li>
<li>All other data references created in, and associated with, the graph are made specific to the graph. A data reference can be made specific to a graph by either creating it as virtual or by exporting and re-importing the graph using the import/export extension.</li>
<li>Delays in the graph, if any, MUST be set to auto-age using <code>vxRegisterAutoAging</code>.</li>
<li>Verify the graph using <code>vxVerifyGraph</code>.</li>
<li>Now data reference enqueue / dequeue can be done on associated graph parameters using <code><a class="el" href="d7/d94/group__group__pipelining.html#gae8570fab78fc47b2258b5ee296a6aae4">vxGraphParameterEnqueueReadyRef</a></code> and <code><a class="el" href="d7/d94/group__group__pipelining.html#ga5e1cf3af554ea41fcf6e8140bc6e46f4">vxGraphParameterDequeueDoneRef</a></code>.</li>
<li>Graph execution on enqueued parameters depends on the scheduling mode chosen:<ol type="a">
<li><code><a class="el" href="d7/d94/group__group__pipelining.html#ggaf3e082f7326cf34b0ba143b8756f126ca14cf92647f3b25c7c8ae18805703f534">VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</a></code>: User manually schedules the graph on the full set of all enqueued parameters by calling <code>vxScheduleGraph</code>. This gives more control to the application to limit when the graph execution on enqueued parameters can begin.</li>
<li><code><a class="el" href="d7/d94/group__group__pipelining.html#ggaf3e082f7326cf34b0ba143b8756f126ca24051853304870234f5a58b225045478">VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</a></code>: Implementation automatically schedules graph as long as enough data is enqueued to it. This gives more control to the implementation to decide when the graph execution on enqueued parameters can begin.</li>
</ol>
</li>
<li><code><a class="el" href="d7/d94/group__group__pipelining.html#ga5badde82c260e46de01106615ec25913">vxGraphParameterCheckDoneRef</a></code> can be used to determine when to dequeue graph parameters for completed graph executions.</li>
<li>In order to gracefully end graph pipelining, the application should cease enqueing graph parameters, and call <code>vxWaitGraph</code> to wait for the in-flight graph executions to complete. When the call returns, call <code><a class="el" href="d7/d94/group__group__pipelining.html#ga5e1cf3af554ea41fcf6e8140bc6e46f4">vxGraphParameterDequeueDoneRef</a></code> on all the graph parameters to return control of the buffers to the application.</li>
</ol>
<p>The following code offers an example of the process outlined above, using <code><a class="el" href="d7/d94/group__group__pipelining.html#ggaf3e082f7326cf34b0ba143b8756f126ca24051853304870234f5a58b225045478">VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</a></code> scheduling mode.</p>
<p><a class="anchor" id="example"></a></p><div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* index of graph parameter data reference which is used to provide input to the graph */</span></div><div class="line"><span class="preprocessor">#define GRAPH_PARAMETER_IN  (0u)</span></div><div class="line"><span class="comment">/* index of graph parameter data reference which is used to provide output to the graph */</span></div><div class="line"><span class="preprocessor">#define GRAPH_PARAMETER_OUT (1u)</span></div><div class="line"><span class="comment">/* max parameters to this graph */</span></div><div class="line"><span class="preprocessor">#define GRAPH_PARAMETER_MAX (2u)</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Utility API used to add a graph parameter from a node, node parameter index</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> add_graph_parameter_by_node_index(vx_graph graph, vx_node node, vx_uint32 node_parameter_index)</div><div class="line">{</div><div class="line">    vx_parameter parameter = vxGetParameterByIndex(node, node_parameter_index);</div><div class="line"></div><div class="line">    vxAddParameterToGraph(graph, parameter);</div><div class="line">    vxReleaseParameter(&amp;parameter);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Utility API used to create graph with graph parameter for input and output</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The following graph is created,</span></div><div class="line"><span class="comment"> * IN_IMG -&gt; EXTRACT_NODE -&gt; TMP_IMG -&gt; CONVERT_DEPTH_NODE -&gt; OUT_IMG</span></div><div class="line"><span class="comment"> *                                          ^</span></div><div class="line"><span class="comment"> *                                          |</span></div><div class="line"><span class="comment"> *                                      SHIFT_SCALAR</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * IN_IMG and OUT_IMG are graph parameters.</span></div><div class="line"><span class="comment"> * TMP_IMG is a virtual image</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> vx_graph create_graph(vx_context context, vx_uint32 width, vx_uint32 height)</div><div class="line">{</div><div class="line">    vx_graph graph;</div><div class="line">    vx_node n0, n1;</div><div class="line">    vx_image tmp_img;</div><div class="line">    vx_int32 shift;</div><div class="line">    vx_scalar s0;</div><div class="line"></div><div class="line">    graph = vxCreateGraph(context);</div><div class="line"></div><div class="line">    <span class="comment">/* create intermediate virtual image */</span></div><div class="line">    tmp_img = vxCreateVirtualImage(graph, 0, 0, VX_DF_IMAGE_VIRT);</div><div class="line"></div><div class="line">    <span class="comment">/* create first node, input is NULL this will be made as graph parameter */</span></div><div class="line">    n0 = vxChannelExtractNode(graph, NULL, VX_CHANNEL_G, tmp_img);</div><div class="line"></div><div class="line">    <span class="comment">/* create a scalar object required for second node */</span></div><div class="line">    shift = 8;</div><div class="line">    s0 = vxCreateScalar(context, VX_TYPE_INT32, &amp;shift);</div><div class="line"></div><div class="line">    <span class="comment">/* create second node, output is NULL since this will be made as graph parameter */</span></div><div class="line">    n1 = vxConvertDepthNode(graph, tmp_img, NULL, VX_CONVERT_POLICY_SATURATE, s0);</div><div class="line"></div><div class="line">    <span class="comment">/* add graph parameters */</span></div><div class="line">    add_graph_parameter_by_node_index(graph, n0, 0);</div><div class="line">    add_graph_parameter_by_node_index(graph, n1, 1);</div><div class="line"></div><div class="line">    vxReleaseScalar(&amp;s0);</div><div class="line">    vxReleaseNode(&amp;n0);</div><div class="line">    vxReleaseNode(&amp;n1);</div><div class="line">    vxReleaseImage(&amp;tmp_img);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> graph;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Utility API used to fill data and enqueue input to graph</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> enqueue_input(vx_graph graph, vx_uint32 width, vx_uint32 height, vx_image in_img)</div><div class="line">{</div><div class="line">    vx_rectangle_t rect = { 0, 0, width, height};</div><div class="line">    vx_imagepatch_addressing_t imagepatch_addr;</div><div class="line">    vx_map_id map_id;</div><div class="line">    <span class="keywordtype">void</span> *user_ptr;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(in_img!=NULL)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Fill input data using Copy/Map/SwapHandles */</span></div><div class="line">        vxMapImagePatch(in_img, &amp;rect, 0, &amp;map_id, &amp;imagepatch_addr, &amp;user_ptr, VX_WRITE_ONLY, VX_MEMORY_TYPE_NONE, VX_NOGAP_X);</div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">        vxUnmapImagePatch(in_img, map_id);</div><div class="line">        <a class="code" href="d7/d94/group__group__pipelining.html#gae8570fab78fc47b2258b5ee296a6aae4">vxGraphParameterEnqueueReadyRef</a>(graph, GRAPH_PARAMETER_IN, (vx_reference*)&amp;in_img, 1);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Utility API used to fill input to graph</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> dequeue_input(vx_graph graph, vx_image *in_img)</div><div class="line">{</div><div class="line">    vx_uint32 num_refs;</div><div class="line"></div><div class="line">    *in_img = NULL;</div><div class="line"></div><div class="line">    <span class="comment">/* Get consumed input reference */</span></div><div class="line">    <a class="code" href="d7/d94/group__group__pipelining.html#ga5e1cf3af554ea41fcf6e8140bc6e46f4">vxGraphParameterDequeueDoneRef</a>(graph, GRAPH_PARAMETER_IN, (vx_reference*)in_img, 1, &amp;num_refs);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Utility API used to enqueue output to graph</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> enqueue_output(vx_graph graph, vx_image out_img)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>(out_img!=NULL)</div><div class="line">    {</div><div class="line">        <a class="code" href="d7/d94/group__group__pipelining.html#gae8570fab78fc47b2258b5ee296a6aae4">vxGraphParameterEnqueueReadyRef</a>(graph, GRAPH_PARAMETER_OUT, (vx_reference*)&amp;out_img, 1);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> vx_bool is_output_available(vx_graph graph)</div><div class="line">{</div><div class="line">    vx_uint32 num_refs;</div><div class="line"></div><div class="line">    <a class="code" href="d7/d94/group__group__pipelining.html#ga5badde82c260e46de01106615ec25913">vxGraphParameterCheckDoneRef</a>(graph, GRAPH_PARAMETER_OUT, &amp;num_refs);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (num_refs &gt; 0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Utility API used to dequeue output and consume it</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> dequeue_output(vx_graph graph, vx_uint32 width, vx_uint32 height, vx_image *out_img)</div><div class="line">{</div><div class="line">    vx_rectangle_t rect = { 0, 0, width, height};</div><div class="line">    vx_imagepatch_addressing_t imagepatch_addr;</div><div class="line">    vx_map_id map_id;</div><div class="line">    <span class="keywordtype">void</span> *user_ptr;</div><div class="line">    vx_uint32 num_refs;</div><div class="line"></div><div class="line">    *out_img = NULL;</div><div class="line"></div><div class="line">    <span class="comment">/* Get output reference and consume new data, waits until a reference is available */</span></div><div class="line">    <a class="code" href="d7/d94/group__group__pipelining.html#ga5e1cf3af554ea41fcf6e8140bc6e46f4">vxGraphParameterDequeueDoneRef</a>(graph, GRAPH_PARAMETER_OUT, (vx_reference*)out_img, 1, &amp;num_refs);</div><div class="line">    <span class="keywordflow">if</span>(*out_img!=NULL)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Consume output data using Copy/Map/SwapHandles */</span></div><div class="line">        vxMapImagePatch(*out_img, &amp;rect, 0, &amp;map_id, &amp;imagepatch_addr, &amp;user_ptr, VX_READ_ONLY, VX_MEMORY_TYPE_NONE, VX_NOGAP_X);</div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">        vxUnmapImagePatch(*out_img, map_id);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Max number of input references */</span></div><div class="line"><span class="preprocessor">#define GRAPH_PARAMETER_IN_MAX_REFS   (2u)</span></div><div class="line"><span class="comment">/* Max number of output references */</span></div><div class="line"><span class="preprocessor">#define GRAPH_PARAMETER_OUT_MAX_REFS   (2u)</span></div><div class="line"></div><div class="line"><span class="comment">/* execute graph in a pipelined manner</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> vx_khr_pipelining()</div><div class="line">{</div><div class="line">    vx_uint32 width = 640, height = 480, i;</div><div class="line">    vx_context context;</div><div class="line">    vx_graph graph;</div><div class="line">    vx_image in_refs[GRAPH_PARAMETER_IN_MAX_REFS];</div><div class="line">    vx_image out_refs[GRAPH_PARAMETER_IN_MAX_REFS];</div><div class="line">    vx_image in_img, out_img;</div><div class="line">    <a class="code" href="d7/d94/group__group__pipelining.html#d3/d75/structvx__graph__parameter__queue__params__t">vx_graph_parameter_queue_params_t</a> graph_parameters_queue_params_list[GRAPH_PARAMETER_MAX];</div><div class="line"></div><div class="line">    context = vxCreateContext();</div><div class="line">    graph = create_graph(context, width, height);</div><div class="line"></div><div class="line">    create_data_refs(context, in_refs, out_refs, GRAPH_PARAMETER_IN_MAX_REFS, GRAPH_PARAMETER_OUT_MAX_REFS, width, height);</div><div class="line"></div><div class="line">    graph_parameters_queue_params_list[0].<a class="code" href="d7/d94/group__group__pipelining.html#a166bb44eca258b4062bcda6a7016f4c6">graph_parameter_index</a> = GRAPH_PARAMETER_IN;</div><div class="line">    graph_parameters_queue_params_list[0].<a class="code" href="d7/d94/group__group__pipelining.html#a8133edd03997cf745296dc15389d8479">refs_list_size</a> = GRAPH_PARAMETER_IN_MAX_REFS;</div><div class="line">    graph_parameters_queue_params_list[0].<a class="code" href="d7/d94/group__group__pipelining.html#abf7cc3019803ed40bdc8bf617fc77b7e">refs_list</a> = (vx_reference*)&amp;in_refs[0];</div><div class="line"></div><div class="line">    graph_parameters_queue_params_list[1].<a class="code" href="d7/d94/group__group__pipelining.html#a166bb44eca258b4062bcda6a7016f4c6">graph_parameter_index</a> = GRAPH_PARAMETER_OUT;</div><div class="line">    graph_parameters_queue_params_list[1].<a class="code" href="d7/d94/group__group__pipelining.html#a8133edd03997cf745296dc15389d8479">refs_list_size</a> = GRAPH_PARAMETER_OUT_MAX_REFS;</div><div class="line">    graph_parameters_queue_params_list[1].<a class="code" href="d7/d94/group__group__pipelining.html#abf7cc3019803ed40bdc8bf617fc77b7e">refs_list</a> = (vx_reference*)&amp;out_refs[0];</div><div class="line"></div><div class="line">    <a class="code" href="d7/d94/group__group__pipelining.html#ga4a050fb0e974eaf1532e0cef243a7731">vxSetGraphScheduleConfig</a>(graph,</div><div class="line">            <a class="code" href="d7/d94/group__group__pipelining.html#ggaf3e082f7326cf34b0ba143b8756f126ca24051853304870234f5a58b225045478">VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</a>,</div><div class="line">            GRAPH_PARAMETER_MAX,</div><div class="line">            graph_parameters_queue_params_list</div><div class="line">            );</div><div class="line"></div><div class="line">    vxVerifyGraph(graph);</div><div class="line"></div><div class="line">    <span class="comment">/* enqueue input and output to trigger graph */</span></div><div class="line">    <span class="keywordflow">for</span>(i=0; i&lt;GRAPH_PARAMETER_IN_MAX_REFS; i++)</div><div class="line">    {</div><div class="line">        enqueue_input(graph, width, height, in_refs[i]);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span>(i=0; i&lt;GRAPH_PARAMETER_OUT_MAX_REFS; i++)</div><div class="line">    {</div><div class="line">        enqueue_output(graph, out_refs[i]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(1)</div><div class="line">    {</div><div class="line">        <span class="comment">/* wait for input to be available, dequeue it - BLOCKs until input can be dequeued */</span></div><div class="line">        dequeue_input(graph, &amp;in_img);</div><div class="line"></div><div class="line">        <span class="comment">/* wait for output to be available, dequeue output and process it - BLOCKs until output can be dequeued */</span></div><div class="line">        dequeue_output(graph, width, height, &amp;out_img);</div><div class="line"></div><div class="line">        <span class="comment">/* recycle input - fill new data and re-enqueue*/</span></div><div class="line">        enqueue_input(graph, width, height, in_img);</div><div class="line"></div><div class="line">        <span class="comment">/* recycle output */</span></div><div class="line">        enqueue_output(graph, out_img);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(CheckExit())</div><div class="line">        {</div><div class="line">            <span class="comment">/* App wants to exit, break from main loop */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * wait until all previous graph executions have completed</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    vxWaitGraph(graph);</div><div class="line"></div><div class="line">    <span class="comment">/* flush output references, only required if need to consume last few references */</span></div><div class="line">    <span class="keywordflow">while</span>( is_output_available(graph) )</div><div class="line">    {</div><div class="line">      dequeue_output(graph, width, height, &amp;out_img);</div><div class="line">    }</div><div class="line"></div><div class="line">    vxReleaseGraph(&amp;graph);</div><div class="line">    release_data_refs(in_refs, out_refs, GRAPH_PARAMETER_IN_MAX_REFS, GRAPH_PARAMETER_OUT_MAX_REFS);</div><div class="line">    vxReleaseContext(&amp;context);</div><div class="line">}</div></div><!-- fragment --> <h2><a class="anchor" id="sec_batch_processing_app"></a>
Example Batch processing application</h2>
<p>In order for the graph to be executed in batch processing mode, the steps outlined below need to be followed by an application:</p><ol type="1">
<li>Create a graph and add nodes to the graph as usual.</li>
<li>For data references which need to be 'batched' by the application, add them as graph parameters.</li>
<li>Call <code> <a class="el" href="d7/d94/group__group__pipelining.html#ga4a050fb0e974eaf1532e0cef243a7731">vxSetGraphScheduleConfig</a></code> with the parameters as follows:<ol type="a">
<li>Set scheduling mode (<code><a class="el" href="d7/d94/group__group__pipelining.html#ggaf3e082f7326cf34b0ba143b8756f126ca14cf92647f3b25c7c8ae18805703f534">VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</a></code> or <code><a class="el" href="d7/d94/group__group__pipelining.html#ggaf3e082f7326cf34b0ba143b8756f126ca24051853304870234f5a58b225045478">VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</a></code>).</li>
<li>List the graph parameters which will be batch processed.</li>
<li>For these parameters specify the list of references that could be enqueued later for batch processing.</li>
</ol>
</li>
<li>All other data references created in, and associated with the graph are made specific to the graph. A data reference can be made specific to a graph by either creating it as virtual or by exporting and re-importing the graph using the import/export extension.</li>
<li>Delays in the graph, if any, MUST be set to auto-age using <code>vxRegisterAutoAging</code>.</li>
<li>Verify the graph using <code>vxVerifyGraph</code>.</li>
<li>To execute the graph:<ol type="a">
<li>Enqueue the data references which need to be processed in a batch using <code><a class="el" href="d7/d94/group__group__pipelining.html#gae8570fab78fc47b2258b5ee296a6aae4">vxGraphParameterEnqueueReadyRef</a></code>.</li>
<li>If scheduling mode was set to <code><a class="el" href="d7/d94/group__group__pipelining.html#ggaf3e082f7326cf34b0ba143b8756f126ca14cf92647f3b25c7c8ae18805703f534">VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</a></code>, use <code>vxScheduleGraph</code> to trigger the batch processing.</li>
<li>Use <code>vxWaitGraph</code> to wait for the batch processing to complete.</li>
<li>Dequeue the processed data references using <code><a class="el" href="d7/d94/group__group__pipelining.html#ga5e1cf3af554ea41fcf6e8140bc6e46f4">vxGraphParameterDequeueDoneRef</a></code>.</li>
</ol>
</li>
</ol>
<p>The following code offers a example of the process outlined above using <code><a class="el" href="d7/d94/group__group__pipelining.html#ggaf3e082f7326cf34b0ba143b8756f126ca14cf92647f3b25c7c8ae18805703f534">VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</a></code> scheduling mode.</p>
<p><a class="anchor" id="example"></a></p><div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Max batch size supported by application */</span></div><div class="line"><span class="preprocessor">#define GRAPH_PARAMETER_MAX_BATCH_SIZE  (10u)</span></div><div class="line"></div><div class="line"><span class="comment">/* execute graph in a batch-processing manner</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> vx_khr_batch_processing()</div><div class="line">{</div><div class="line">    vx_uint32 width = 640, height = 480, actual_batch_size;</div><div class="line">    vx_context context;</div><div class="line">    vx_graph graph;</div><div class="line">    vx_image in_refs[GRAPH_PARAMETER_MAX_BATCH_SIZE];</div><div class="line">    vx_image out_refs[GRAPH_PARAMETER_MAX_BATCH_SIZE];</div><div class="line">    <a class="code" href="d7/d94/group__group__pipelining.html#d3/d75/structvx__graph__parameter__queue__params__t">vx_graph_parameter_queue_params_t</a> graph_parameters_queue_params_list[GRAPH_PARAMETER_MAX];</div><div class="line"></div><div class="line">    context = vxCreateContext();</div><div class="line">    graph = create_graph(context, width, height);</div><div class="line"></div><div class="line">    create_data_refs(context, in_refs, out_refs, GRAPH_PARAMETER_MAX_BATCH_SIZE, GRAPH_PARAMETER_MAX_BATCH_SIZE, width, height);</div><div class="line"></div><div class="line">    graph_parameters_queue_params_list[0].<a class="code" href="d7/d94/group__group__pipelining.html#a166bb44eca258b4062bcda6a7016f4c6">graph_parameter_index</a> = GRAPH_PARAMETER_IN;</div><div class="line">    graph_parameters_queue_params_list[0].<a class="code" href="d7/d94/group__group__pipelining.html#a8133edd03997cf745296dc15389d8479">refs_list_size</a> = GRAPH_PARAMETER_MAX_BATCH_SIZE;</div><div class="line">    graph_parameters_queue_params_list[0].<a class="code" href="d7/d94/group__group__pipelining.html#abf7cc3019803ed40bdc8bf617fc77b7e">refs_list</a> = (vx_reference*)&amp;in_refs[0];</div><div class="line"></div><div class="line">    graph_parameters_queue_params_list[1].<a class="code" href="d7/d94/group__group__pipelining.html#a166bb44eca258b4062bcda6a7016f4c6">graph_parameter_index</a> = GRAPH_PARAMETER_OUT;</div><div class="line">    graph_parameters_queue_params_list[1].<a class="code" href="d7/d94/group__group__pipelining.html#a8133edd03997cf745296dc15389d8479">refs_list_size</a> = GRAPH_PARAMETER_MAX_BATCH_SIZE;</div><div class="line">    graph_parameters_queue_params_list[1].<a class="code" href="d7/d94/group__group__pipelining.html#abf7cc3019803ed40bdc8bf617fc77b7e">refs_list</a> = (vx_reference*)&amp;out_refs[0];</div><div class="line"></div><div class="line">    <a class="code" href="d7/d94/group__group__pipelining.html#ga4a050fb0e974eaf1532e0cef243a7731">vxSetGraphScheduleConfig</a>(graph,</div><div class="line">            <a class="code" href="d7/d94/group__group__pipelining.html#ggaf3e082f7326cf34b0ba143b8756f126ca14cf92647f3b25c7c8ae18805703f534">VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</a>,</div><div class="line">            GRAPH_PARAMETER_MAX,</div><div class="line">            graph_parameters_queue_params_list</div><div class="line">            );</div><div class="line"></div><div class="line">    vxVerifyGraph(graph);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(1)</div><div class="line">    {</div><div class="line">        <span class="comment">/* read next batch of input and output */</span></div><div class="line">        get_input_output_batch(in_refs, out_refs,</div><div class="line">                GRAPH_PARAMETER_MAX_BATCH_SIZE,</div><div class="line">                &amp;actual_batch_size);</div><div class="line"></div><div class="line">        <a class="code" href="d7/d94/group__group__pipelining.html#gae8570fab78fc47b2258b5ee296a6aae4">vxGraphParameterEnqueueReadyRef</a>(graph,</div><div class="line">            GRAPH_PARAMETER_IN,</div><div class="line">            (vx_reference*)&amp;in_refs[0],</div><div class="line">            actual_batch_size);</div><div class="line"></div><div class="line">        <a class="code" href="d7/d94/group__group__pipelining.html#gae8570fab78fc47b2258b5ee296a6aae4">vxGraphParameterEnqueueReadyRef</a>(</div><div class="line">            graph,</div><div class="line">            GRAPH_PARAMETER_OUT,</div><div class="line">            (vx_reference*)&amp;out_refs[0],</div><div class="line">            actual_batch_size);</div><div class="line"></div><div class="line">        <span class="comment">/* trigger processing of previously enqueued input and output */</span></div><div class="line">        vxScheduleGraph(graph);</div><div class="line">        <span class="comment">/* wait for the batch processing to complete */</span></div><div class="line">        vxWaitGraph(graph);</div><div class="line"></div><div class="line">        <span class="comment">/* dequeue the processed input and output data */</span></div><div class="line">        <a class="code" href="d7/d94/group__group__pipelining.html#ga5e1cf3af554ea41fcf6e8140bc6e46f4">vxGraphParameterDequeueDoneRef</a>(graph,</div><div class="line">            GRAPH_PARAMETER_IN,</div><div class="line">            (vx_reference*)&amp;in_refs[0],</div><div class="line">            GRAPH_PARAMETER_MAX_BATCH_SIZE,</div><div class="line">            &amp;actual_batch_size);</div><div class="line"></div><div class="line">        <a class="code" href="d7/d94/group__group__pipelining.html#ga5e1cf3af554ea41fcf6e8140bc6e46f4">vxGraphParameterDequeueDoneRef</a>(</div><div class="line">            graph,</div><div class="line">            GRAPH_PARAMETER_OUT,</div><div class="line">            (vx_reference*)&amp;out_refs[0],</div><div class="line">            GRAPH_PARAMETER_MAX_BATCH_SIZE,</div><div class="line">            &amp;actual_batch_size);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(CheckExit())</div><div class="line">        {</div><div class="line">            <span class="comment">/* App wants to exit, break from main loop */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    vxReleaseGraph(&amp;graph);</div><div class="line">    release_data_refs(in_refs, out_refs, GRAPH_PARAMETER_MAX_BATCH_SIZE, GRAPH_PARAMETER_MAX_BATCH_SIZE);</div><div class="line">    vxReleaseContext(&amp;context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="sec_design_streaming"></a>
Streaming</h1>
<p>OpenVX APIs allow a user to construct a graph with source nodes and sink nodes. A source node is a node which takes no input and only outputs data to one or more data references. A sink node is a node which takes one or more data references as input but produces no output. For such a graph, graph execution can be started in streaming mode, wherein, user intervention is not needed to re-schedule the graph each time.</p>
<h2><a class="anchor" id="sec_sourcesink"></a>
Source/sink user nodes</h2>
<p>Source/sink user nodes are implemented using the existing user kernel OpenVX API.</p>
<p>The following is an example of streaming user source node where the data references are coming from a vendor specific capture device component: </p><div class="fragment"><div class="line"><span class="keyword">static</span> vx_status user_node_source_validate(vx_node node, <span class="keyword">const</span> vx_reference parameters[], vx_uint32 num, vx_meta_format metas[])</div><div class="line">{</div><div class="line">    <span class="comment">/* if any verification checks do here */</span></div><div class="line">    <span class="keywordflow">return</span> VX_SUCCESS;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> vx_status user_node_source_init(vx_node node, <span class="keyword">const</span> vx_reference parameters[], vx_uint32 num)</div><div class="line">{</div><div class="line">    vx_image img = (vx_image)parameters[0];</div><div class="line">    vx_uint32 width, height, i;</div><div class="line">    vx_enum df;</div><div class="line"></div><div class="line">    vxQueryImage(img, VX_IMAGE_WIDTH, &amp;width, <span class="keyword">sizeof</span>(vx_uint32));</div><div class="line">    vxQueryImage(img, VX_IMAGE_HEIGHT, &amp;height, <span class="keyword">sizeof</span>(vx_uint32));</div><div class="line">    vxQueryImage(img, VX_IMAGE_FORMAT, &amp;df, <span class="keyword">sizeof</span>(vx_enum));</div><div class="line"></div><div class="line">    CaptureDeviceOpen(&amp;capture_dev, width, height, df);</div><div class="line">    <span class="comment">/* allocate images for priming the capture device.</span></div><div class="line"><span class="comment">     * Typically capture devices need some image references to be primed in order to start</span></div><div class="line"><span class="comment">     * capturing data.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    CaptureDeviceAllocHandles(capture_dev, capture_refs_prime, MAX_CAPTURE_REFS_PRIME);</div><div class="line">    <span class="comment">/* prime image references to capture device */</span></div><div class="line">    <span class="keywordflow">for</span>(i=0; i&lt;MAX_CAPTURE_REFS_PRIME; i++)</div><div class="line">    {</div><div class="line">        CaptureDeviceSwapHandles(capture_dev, capture_refs_prime[i], NULL);</div><div class="line">    }</div><div class="line">    <span class="comment">/* start capturing data to primed image references */</span></div><div class="line">    CaptureDeviceStart(capture_dev);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> VX_SUCCESS;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> vx_status user_node_source_run(vx_node node, vx_reference parameters[], vx_uint32 num)</div><div class="line">{</div><div class="line">    vx_reference empty_ref, full_ref;</div><div class="line"></div><div class="line">    empty_ref = parameters[0];</div><div class="line"></div><div class="line">    <span class="comment">/* swap a &#39;empty&#39; image reference with a captured image reference filled with data</span></div><div class="line"><span class="comment">     * If this is one of the first few calls to CaptureDeviceSwapHandle, then</span></div><div class="line"><span class="comment">     * full_buf would be one of the image references primed during user_node_source_init</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    CaptureDeviceSwapHandles(capture_dev, empty_ref, &amp;full_ref);</div><div class="line"></div><div class="line">    parameters[0] = full_ref;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> VX_SUCCESS;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> vx_status user_node_source_deinit(vx_node node, <span class="keyword">const</span> vx_reference parameters[], vx_uint32 num)</div><div class="line">{</div><div class="line">    CaptureDeviceStop(capture_dev);</div><div class="line">    CaptureDeviceFreeHandles(capture_dev, capture_refs_prime, MAX_CAPTURE_REFS_PRIME);</div><div class="line">    CaptureDeviceClose(&amp;capture_dev);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> VX_SUCCESS;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Add user node as streaming node */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> user_node_source_add(vx_context context)</div><div class="line">{</div><div class="line">    vxAllocateUserKernelId(context, &amp;user_node_source_kernel_id);</div><div class="line"></div><div class="line">    user_node_source_kernel = vxAddUserKernel(</div><div class="line">            context,</div><div class="line">            <span class="stringliteral">&quot;user_kernel.source&quot;</span>,</div><div class="line">            user_node_source_kernel_id,</div><div class="line">            (vx_kernel_f)user_node_source_run,</div><div class="line">            1,</div><div class="line">            user_node_source_validate,</div><div class="line">            user_node_source_init,</div><div class="line">            user_node_source_deinit</div><div class="line">            );</div><div class="line"></div><div class="line">    vxAddParameterToKernel(user_node_source_kernel,</div><div class="line">        0,</div><div class="line">        VX_OUTPUT,</div><div class="line">        VX_TYPE_IMAGE,</div><div class="line">        VX_PARAMETER_STATE_REQUIRED</div><div class="line">        );</div><div class="line"></div><div class="line">    vxFinalizeKernel(user_node_source_kernel);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> user_node_source_remove()</div><div class="line">{</div><div class="line">    vxRemoveKernel(user_node_source_kernel);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span></div><div class="line"><span class="keyword">static</span> vx_node user_node_source_create_node(vx_graph graph, vx_image output)</div><div class="line">{</div><div class="line">    vx_node node = NULL;</div><div class="line"></div><div class="line">    node = vxCreateGenericNode(graph, user_node_source_kernel);</div><div class="line">    vxSetParameterByIndex(node, 0, (vx_reference)output);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> node;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> Likewise, the following is an example of streaming user sink node where the data references are going to a vendor specific display device component: </p><div class="fragment"><div class="line"><span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span></div><div class="line"><span class="keyword">static</span> vx_status user_node_sink_validate(vx_node node, <span class="keyword">const</span> vx_reference parameters[], vx_uint32 num, vx_meta_format metas[])</div><div class="line">{</div><div class="line">    <span class="comment">/* if any verification checks do here */</span></div><div class="line">    <span class="keywordflow">return</span> VX_SUCCESS;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> vx_status user_node_sink_init(vx_node node, <span class="keyword">const</span> vx_reference parameters[], vx_uint32 num)</div><div class="line">{</div><div class="line">    vx_image img = (vx_image)parameters[0];</div><div class="line">    vx_uint32 width, height;</div><div class="line">    vx_enum df;</div><div class="line"></div><div class="line">    vxQueryImage(img, VX_IMAGE_WIDTH, &amp;width, <span class="keyword">sizeof</span>(vx_uint32));</div><div class="line">    vxQueryImage(img, VX_IMAGE_HEIGHT, &amp;height, <span class="keyword">sizeof</span>(vx_uint32));</div><div class="line">    vxQueryImage(img, VX_IMAGE_FORMAT, &amp;df, <span class="keyword">sizeof</span>(vx_enum));</div><div class="line"></div><div class="line">    DisplayDeviceOpen(&amp;display_dev, width, height, df);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> VX_SUCCESS;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> vx_status user_node_sink_run(vx_node node, vx_reference parameters[], vx_uint32 num)</div><div class="line">{</div><div class="line">    vx_reference new_ref, old_ref;</div><div class="line"></div><div class="line">    new_ref = parameters[0];</div><div class="line"></div><div class="line">    <span class="comment">/* swap input reference with reference currently held by display</span></div><div class="line"><span class="comment">     * if this is first call to DisplayDeviceSwapHandle, then out_ref could be NULL</span></div><div class="line"><span class="comment">     * NULL reference when returned via parameters to framework is ignored by framework</span></div><div class="line"><span class="comment">     * non-NULL reference when returned via parameters to framework is recycled by framework for subsequent graph execution</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    DisplayDeviceSwapHandles(display_dev, new_ref, &amp;old_ref);</div><div class="line"></div><div class="line">    parameters[0] = old_ref;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> VX_SUCCESS;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> vx_status user_node_sink_deinit(vx_node node, <span class="keyword">const</span> vx_reference parameters[], vx_uint32 num)</div><div class="line">{</div><div class="line">    DisplayDeviceClose(&amp;display_dev);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> VX_SUCCESS;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Add user node as streaming node */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> user_node_sink_add(vx_context context)</div><div class="line">{</div><div class="line">    vxAllocateUserKernelId(context, &amp;user_node_sink_kernel_id);</div><div class="line"></div><div class="line">    user_node_sink_kernel = vxAddUserKernel(</div><div class="line">            context,</div><div class="line">            <span class="stringliteral">&quot;user_kernel.sink&quot;</span>,</div><div class="line">            user_node_sink_kernel_id,</div><div class="line">            (vx_kernel_f)user_node_sink_run,</div><div class="line">            1,</div><div class="line">            user_node_sink_validate,</div><div class="line">            user_node_sink_init,</div><div class="line">            user_node_sink_deinit</div><div class="line">            );</div><div class="line"></div><div class="line">    vxAddParameterToKernel(user_node_sink_kernel,</div><div class="line">        0,</div><div class="line">        VX_INPUT,</div><div class="line">        VX_TYPE_IMAGE,</div><div class="line">        VX_PARAMETER_STATE_REQUIRED</div><div class="line">        );</div><div class="line"></div><div class="line">    vxFinalizeKernel(user_node_sink_kernel);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> user_node_sink_remove()</div><div class="line">{</div><div class="line">    vxRemoveKernel(user_node_sink_kernel);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span></div><div class="line"><span class="keyword">static</span> vx_node user_node_sink_create_node(vx_graph graph, vx_image input)</div><div class="line">{</div><div class="line">    vx_node node = NULL;</div><div class="line"></div><div class="line">    node = vxCreateGenericNode(graph, user_node_sink_kernel);</div><div class="line">    vxSetParameterByIndex(node, 0, (vx_reference)input);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> node;</div><div class="line">}</div></div><!-- fragment --><p> In both these examples, the user node 'swaps' the reference provided by the implementation with another 'compatible' reference. This allows user nodes to implement zero-copy capture and display functions.</p>
<h2><a class="anchor" id="sec_triggering"></a>
Graph streaming application</h2>
<p>To execute a graph in streaming mode, the following steps need to followed by an application:</p><ul>
<li>Create a graph with source and sink nodes.</li>
<li>All data references created in and associated with the graph are made specific to the graph. A data reference can be made specific to a graph by either creating it as virtual or by exporting and re-importing the graph using the import/export extension.</li>
<li>Verify the graph using <code>vxVerifyGraph</code></li>
<li>Start the streaming mode of graph execution using <code><a class="el" href="d3/dac/group__group__streaming.html#ga473953557c79a410acf0ac7a7fa925be">vxStartGraphStreaming</a></code></li>
<li>Now the graph gets re-scheduled continuously.<ul>
<li>The implementation automatically decides the re-schedule trigger condition.</li>
</ul>
</li>
<li>Sometimes a user node may want to stop the continuous graph execution due to end of stream or error condition detected within its node execution. In this case the user node should return an error status. When a error status is returned by the user node, the continuous graph execution is stopped.</li>
<li>Application can use <code>vxWaitGraph</code> to wait for streaming graph execution to stop on its own.</li>
<li>Alternatively, user application can explicitly stop the streaming mode of execution using <code><a class="el" href="d3/dac/group__group__streaming.html#gaf407e65530d3edf739466431f1f37722">vxStopGraphStreaming</a></code>.</li>
<li>In all cases, the continuous mode of graph execution is stopped at an implementation-defined logical boundary (e.g. after all previous graph executions have completed).</li>
</ul>
<p>The following example code demonstrates how one can use these APIs in an application, </p><div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Utility API used to create graph with source and sink nodes</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> vx_graph create_graph(vx_context context, vx_uint32 width, vx_uint32 height)</div><div class="line">{</div><div class="line">    vx_graph graph;</div><div class="line">    vx_node n0, n1, node_source, node_sink;</div><div class="line">    vx_image in_img, tmp_img, out_img;</div><div class="line">    vx_int32 shift;</div><div class="line">    vx_scalar s0;</div><div class="line"></div><div class="line">    graph = vxCreateGraph(context);</div><div class="line"></div><div class="line">    in_img = vxCreateVirtualImage(graph, width, height, VX_DF_IMAGE_RGB);</div><div class="line"></div><div class="line">    <span class="comment">/* create source node */</span></div><div class="line">    node_source = user_node_source_create_node(graph, in_img);</div><div class="line"></div><div class="line">    <span class="comment">/* create intermediate virtual image */</span></div><div class="line">    tmp_img = vxCreateVirtualImage(graph, 0, 0, VX_DF_IMAGE_VIRT);</div><div class="line"></div><div class="line">    <span class="comment">/* create first node, input is NULL since this will be made as graph parameter */</span></div><div class="line">    n0 = vxChannelExtractNode(graph, in_img, VX_CHANNEL_G, tmp_img);</div><div class="line"></div><div class="line">    out_img = vxCreateVirtualImage(graph, 0, 0, VX_DF_IMAGE_S16);</div><div class="line"></div><div class="line">    <span class="comment">/* create a scalar object required for second node */</span></div><div class="line">    shift = 8;</div><div class="line">    s0 = vxCreateScalar(context, VX_TYPE_INT32, &amp;shift);</div><div class="line"></div><div class="line">    <span class="comment">/* create second node, output is NULL since this will be made as graph parameter */</span></div><div class="line">    n1 = vxConvertDepthNode(graph, tmp_img, out_img, VX_CONVERT_POLICY_SATURATE, s0);</div><div class="line"></div><div class="line">    <span class="comment">/* create sink node */</span></div><div class="line">    node_sink = user_node_sink_create_node(graph, out_img);</div><div class="line"></div><div class="line">    vxReleaseScalar(&amp;s0);</div><div class="line">    vxReleaseNode(&amp;n0);</div><div class="line">    vxReleaseNode(&amp;n1);</div><div class="line">    vxReleaseNode(&amp;node_source);</div><div class="line">    vxReleaseNode(&amp;node_sink);</div><div class="line">    vxReleaseImage(&amp;tmp_img);</div><div class="line">    vxReleaseImage(&amp;in_img);</div><div class="line">    vxReleaseImage(&amp;out_img);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> graph;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> vx_khr_streaming_sample()</div><div class="line">{</div><div class="line">    vx_uint32 width = 640, height = 480;</div><div class="line">    vx_context context = vxCreateContext();</div><div class="line">    vx_graph graph;</div><div class="line"></div><div class="line">    <span class="comment">/* add user kernels to context */</span></div><div class="line">    user_node_source_add(context);</div><div class="line">    user_node_sink_add(context);</div><div class="line"></div><div class="line">    graph = create_graph(context, width, height);</div><div class="line"></div><div class="line">    vxVerifyGraph(graph);</div><div class="line"></div><div class="line">    <span class="comment">/* execute graph in streaming mode,</span></div><div class="line"><span class="comment">     * graph is retriggered when input reference is consumed by a graph execution</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="d3/dac/group__group__streaming.html#ga473953557c79a410acf0ac7a7fa925be">vxStartGraphStreaming</a>(graph);</div><div class="line"></div><div class="line">    <span class="comment">/* wait until user wants to exit */</span></div><div class="line">    WaitExit();</div><div class="line"></div><div class="line">    <span class="comment">/* stop graph streaming */</span></div><div class="line">    <a class="code" href="d3/dac/group__group__streaming.html#gaf407e65530d3edf739466431f1f37722">vxStopGraphStreaming</a>(graph);</div><div class="line"></div><div class="line">    vxReleaseGraph(&amp;graph);</div><div class="line"></div><div class="line">    <span class="comment">/* remove user kernels from context */</span></div><div class="line">    user_node_source_remove();</div><div class="line">    user_node_sink_remove();</div><div class="line"></div><div class="line">    vxReleaseContext(&amp;context);</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="sec_design_event"></a>
Event handling</h1>
<p>Event handling APIs allow users to register conditions on a graph, based on which events are generated by the implementation. User applications can then wait for events and take appropriate action based on the received event. User-specified events can also be generated by the application so that all events can be handled at a centralized location. This simplifies the application state machine, and in the case of graph pipelining, it allows optimized scheduling of the graph.</p>
<h2><a class="anchor" id="sec_limitations"></a>
Motivation for event handling</h2>
<ol type="1">
<li>Pipelining without events would need blocking calls on the data producers, consumers, and the graph itself. If there were multiple graphs or multiple data producers/consumers pipelined at different rates, one can see how the application logic can easily get complicated.</li>
<li>Applications need a mechanism to allow input references to be dequeued before the full graph execution is completed. This allows implementations to have larger pipeline depths but at the same time have fewer queued references at a graph parameter.</li>
</ol>
<h2><a class="anchor" id="sec_using_event_handling"></a>
Event handling application</h2>
<p>Event handling APIs allow user the flexibility to do early dequeue of input references, and late enqueue of output references. It enables applications to effectively block at a single centralized location for both implementation-generated events as well as user-generated events. Event handling allows the graph to produce events which can then be used by the application. For example, if the thread had an event handler that is used to manage multiple graphs, consumers, and producers, then the events produced by the implementation could feed into this manager. Likewise, early dequeue of input can be achieved, if the event handler could use the graph parameter consumed events to trigger calls to <code><a class="el" href="d7/d94/group__group__pipelining.html#gae8570fab78fc47b2258b5ee296a6aae4">vxGraphParameterEnqueueReadyRef</a></code>, <code><a class="el" href="d7/d94/group__group__pipelining.html#ga5e1cf3af554ea41fcf6e8140bc6e46f4">vxGraphParameterDequeueDoneRef</a></code>.</p>
<p>The following code offers an example of the event handling. </p><div class="fragment"><div class="line"><span class="comment">/* Utility API to clear any pending events */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> clear_pending_events(vx_context context)</div><div class="line">{</div><div class="line">    <a class="code" href="df/d5f/group__group__event.html#d1/d61/structvx__event__t">vx_event_t</a> event;</div><div class="line"></div><div class="line">    <span class="comment">/* do not block */</span></div><div class="line">    <span class="keywordflow">while</span>(<a class="code" href="df/d5f/group__group__event.html#gad389b5cf1edc4a121e2ef76cff22a967">vxWaitEvent</a>(context, &amp;event, vx_true_e)==VX_SUCCESS)</div><div class="line">        ;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* execute graph in a pipelined manner with events used</span></div><div class="line"><span class="comment"> * to schedule the graph execution</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> vx_khr_pipelining_with_events()</div><div class="line">{</div><div class="line">    vx_uint32 width = 640, height = 480, i;</div><div class="line">    vx_context context;</div><div class="line">    vx_graph graph;</div><div class="line">    vx_image in_refs[GRAPH_PARAMETER_IN_MAX_REFS];</div><div class="line">    vx_image out_refs[GRAPH_PARAMETER_IN_MAX_REFS];</div><div class="line">    vx_image in_img, out_img;</div><div class="line">    <a class="code" href="d7/d94/group__group__pipelining.html#d3/d75/structvx__graph__parameter__queue__params__t">vx_graph_parameter_queue_params_t</a> graph_parameters_queue_params_list[GRAPH_PARAMETER_MAX];</div><div class="line"></div><div class="line">    context = vxCreateContext();</div><div class="line">    graph = create_graph(context, width, height);</div><div class="line"></div><div class="line">    create_data_refs(context, in_refs, out_refs, GRAPH_PARAMETER_IN_MAX_REFS, GRAPH_PARAMETER_OUT_MAX_REFS, width, height);</div><div class="line"></div><div class="line">    graph_parameters_queue_params_list[0].<a class="code" href="d7/d94/group__group__pipelining.html#a166bb44eca258b4062bcda6a7016f4c6">graph_parameter_index</a> = GRAPH_PARAMETER_IN;</div><div class="line">    graph_parameters_queue_params_list[0].<a class="code" href="d7/d94/group__group__pipelining.html#a8133edd03997cf745296dc15389d8479">refs_list_size</a> = GRAPH_PARAMETER_IN_MAX_REFS;</div><div class="line">    graph_parameters_queue_params_list[0].<a class="code" href="d7/d94/group__group__pipelining.html#abf7cc3019803ed40bdc8bf617fc77b7e">refs_list</a> = (vx_reference*)&amp;in_refs[0];</div><div class="line"></div><div class="line">    graph_parameters_queue_params_list[1].<a class="code" href="d7/d94/group__group__pipelining.html#a166bb44eca258b4062bcda6a7016f4c6">graph_parameter_index</a> = GRAPH_PARAMETER_OUT;</div><div class="line">    graph_parameters_queue_params_list[1].<a class="code" href="d7/d94/group__group__pipelining.html#a8133edd03997cf745296dc15389d8479">refs_list_size</a> = GRAPH_PARAMETER_OUT_MAX_REFS;</div><div class="line">    graph_parameters_queue_params_list[1].<a class="code" href="d7/d94/group__group__pipelining.html#abf7cc3019803ed40bdc8bf617fc77b7e">refs_list</a> = (vx_reference*)&amp;out_refs[0];</div><div class="line"></div><div class="line">    <a class="code" href="d7/d94/group__group__pipelining.html#ga4a050fb0e974eaf1532e0cef243a7731">vxSetGraphScheduleConfig</a>(graph,</div><div class="line">            <a class="code" href="d7/d94/group__group__pipelining.html#ggaf3e082f7326cf34b0ba143b8756f126ca24051853304870234f5a58b225045478">VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</a>,</div><div class="line">            GRAPH_PARAMETER_MAX,</div><div class="line">            graph_parameters_queue_params_list</div><div class="line">            );</div><div class="line"></div><div class="line">    <span class="comment">/* register events for input consumed and output consumed */</span></div><div class="line">    <a class="code" href="df/d5f/group__group__event.html#ga0b0864a8a19575099457759bd86f65a5">vxRegisterEvent</a>((vx_reference)graph, <a class="code" href="df/d5f/group__group__event.html#gga21a4f8180495b5c7616f790bc9fbe14ca33f6ca76317ae605c1aef1a1bc3a7f03">VX_EVENT_GRAPH_PARAMETER_CONSUMED</a>, GRAPH_PARAMETER_IN);</div><div class="line">    <a class="code" href="df/d5f/group__group__event.html#ga0b0864a8a19575099457759bd86f65a5">vxRegisterEvent</a>((vx_reference)graph, <a class="code" href="df/d5f/group__group__event.html#gga21a4f8180495b5c7616f790bc9fbe14ca33f6ca76317ae605c1aef1a1bc3a7f03">VX_EVENT_GRAPH_PARAMETER_CONSUMED</a>, GRAPH_PARAMETER_OUT);</div><div class="line"></div><div class="line">    vxVerifyGraph(graph);</div><div class="line"></div><div class="line">    <span class="comment">/* disable events generation */</span></div><div class="line">    <a class="code" href="df/d5f/group__group__event.html#ga05f217e114a2bd01467e24956e7d4e7f">vxEnableEvents</a>(context);</div><div class="line">    <span class="comment">/* clear pending events.</span></div><div class="line"><span class="comment">     * Not strictly required but- it&#39;s a good practice to clear any</span></div><div class="line"><span class="comment">     * pending events from last execution before waiting on new events */</span></div><div class="line">    clear_pending_events(context);</div><div class="line"></div><div class="line">    <span class="comment">/* enqueue input and output to trigger graph */</span></div><div class="line">    <span class="keywordflow">for</span>(i=0; i&lt;GRAPH_PARAMETER_IN_MAX_REFS; i++)</div><div class="line">    {</div><div class="line">        enqueue_input(graph, width, height, in_refs[i]);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span>(i=0; i&lt;GRAPH_PARAMETER_OUT_MAX_REFS; i++)</div><div class="line">    {</div><div class="line">        enqueue_output(graph, out_refs[i]);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(1)</div><div class="line">    {</div><div class="line">        <a class="code" href="df/d5f/group__group__event.html#d1/d61/structvx__event__t">vx_event_t</a> event;</div><div class="line"></div><div class="line">        <span class="comment">/* wait for events, block until event is received */</span></div><div class="line">        <a class="code" href="df/d5f/group__group__event.html#gad389b5cf1edc4a121e2ef76cff22a967">vxWaitEvent</a>(context, &amp;event, vx_false_e);</div><div class="line"></div><div class="line">        <span class="comment">/* event for input data ready for recycling, i.e early input release */</span></div><div class="line">        <span class="keywordflow">if</span>(event.<a class="code" href="df/d5f/group__group__event.html#a33d6c96255712ee37545ee02ff787c48">type</a> == <a class="code" href="df/d5f/group__group__event.html#gga21a4f8180495b5c7616f790bc9fbe14ca33f6ca76317ae605c1aef1a1bc3a7f03">VX_EVENT_GRAPH_PARAMETER_CONSUMED</a></div><div class="line">            &amp;&amp; event.<a class="code" href="df/d5f/group__group__event.html#add3ad7645802265a3fd8e75129479ba8">event_info</a>.graph_parameter_consumed.graph == graph</div><div class="line">            &amp;&amp; event.<a class="code" href="df/d5f/group__group__event.html#add3ad7645802265a3fd8e75129479ba8">event_info</a>.graph_parameter_consumed.graph_parameter_index == GRAPH_PARAMETER_IN</div><div class="line">            )</div><div class="line">        {</div><div class="line">            <span class="comment">/* dequeue consumed input, fill new data and re-enqueue */</span></div><div class="line">            dequeue_input(graph, &amp;in_img);</div><div class="line">            enqueue_input(graph, width, height, in_img);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        <span class="comment">/* event for output data ready for recycling, i.e output release */</span></div><div class="line">        <span class="keywordflow">if</span>(event.<a class="code" href="df/d5f/group__group__event.html#a33d6c96255712ee37545ee02ff787c48">type</a> == <a class="code" href="df/d5f/group__group__event.html#gga21a4f8180495b5c7616f790bc9fbe14ca33f6ca76317ae605c1aef1a1bc3a7f03">VX_EVENT_GRAPH_PARAMETER_CONSUMED</a></div><div class="line">            &amp;&amp; event.<a class="code" href="df/d5f/group__group__event.html#add3ad7645802265a3fd8e75129479ba8">event_info</a>.graph_parameter_consumed.graph == graph</div><div class="line">            &amp;&amp; event.<a class="code" href="df/d5f/group__group__event.html#add3ad7645802265a3fd8e75129479ba8">event_info</a>.graph_parameter_consumed.graph_parameter_index == GRAPH_PARAMETER_OUT</div><div class="line">            )</div><div class="line">        {</div><div class="line">            <span class="comment">/* dequeue output reference, consume generated data and re-enqueue output reference */</span></div><div class="line">            dequeue_output(graph, width, height, &amp;out_img);</div><div class="line">            enqueue_output(graph, out_img);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">if</span>(event.<a class="code" href="df/d5f/group__group__event.html#a33d6c96255712ee37545ee02ff787c48">type</a> == <a class="code" href="df/d5f/group__group__event.html#gga21a4f8180495b5c7616f790bc9fbe14cada641f6ae23587683bce2393aacd1329">VX_EVENT_USER</a></div><div class="line">            &amp;&amp; event.<a class="code" href="df/d5f/group__group__event.html#add3ad7645802265a3fd8e75129479ba8">event_info</a>.user_event.user_event_id == 0xDEADBEEF <span class="comment">/* app code for exit */</span></div><div class="line">            )</div><div class="line">        {</div><div class="line">            <span class="comment">/* App wants to exit, break from main loop */</span></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * wait until all previous graph executions have completed</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    vxWaitGraph(graph);</div><div class="line"></div><div class="line">    <span class="comment">/* flush output references, only required if need to consume last few references */</span></div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">      dequeue_output(graph, width, height, &amp;out_img);</div><div class="line">    } <span class="keywordflow">while</span>(out_img!=NULL);</div><div class="line"></div><div class="line">    vxReleaseGraph(&amp;graph);</div><div class="line">    release_data_refs(in_refs, out_refs, GRAPH_PARAMETER_IN_MAX_REFS, GRAPH_PARAMETER_OUT_MAX_REFS);</div><div class="line"></div><div class="line">    <span class="comment">/* disable events generation */</span></div><div class="line">    <a class="code" href="df/d5f/group__group__event.html#gab91a2826eb0a9f4063cfff24143f44fb">vxDisableEvents</a>(context);</div><div class="line">    <span class="comment">/* clear pending events.</span></div><div class="line"><span class="comment">     * Not strictly required but- it&#39;s a good practice to clear any</span></div><div class="line"><span class="comment">     * pending events from last execution before exiting application */</span></div><div class="line">    clear_pending_events(context);</div><div class="line"></div><div class="line">    vxReleaseContext(&amp;context);</div><div class="line">}</div></div><!-- fragment --></div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 3 2018 20:48:12 for OpenVX Graph Pipelining Extension by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
