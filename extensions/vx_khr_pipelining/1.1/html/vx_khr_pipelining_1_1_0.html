<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="The KhronosÂ® OpenVX Working Group, Editors: Kedar Chitnis, Jesse Villareal, Radhakrishna Giduthuri, and Frank Brill">
<title>The OpenVX&#8482; Graph Pipelining, Streaming, and Batch Processing Extension</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 1.9047619047619047em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 0.9523809523809523em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: #fff; color: #222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

object, svg { display: inline-block; vertical-align: middle; }

.center { margin-left: auto; margin-right: auto; }

.spread { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.1607142857142858em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.4; color: black; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #0068b0; text-decoration: none; line-height: inherit; }
a:hover, a:focus { color: #333; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: Noto, sans-serif; font-weight: normal; font-size: 0.9523809523809523em; line-height: 1.6; margin-bottom: 0.75em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.8333333333333334em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Noto, sans-serif; font-weight: normal; font-style: normal; color: black; text-rendering: optimizeLegibility; margin-top: 0.5em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #4d4d4d; line-height: 0; }

h1 { font-size: 2.0238095238095237em; }

h2 { font-size: 1.6071428571428572em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.3095238095238095em; }

h4 { font-size: 1.0714285714285714em; }

h5 { font-size: 1.0714285714285714em; }

h6 { font-size: 0.9523809523809523em; }

hr { border: solid #ddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; color: #264357; }

/* Lists */
ul, ol, dl { font-size: 0.9523809523809523em; line-height: 1.6; margin-bottom: 0.75em; list-style-position: outside; font-family: Noto, sans-serif; }

ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 0.9523809523809523em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3em; font-weight: bold; }
dl dd { margin-bottom: 0.75em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: black; border-bottom: 1px dotted #ddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 0.75em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #ddd; }
blockquote cite { display: block; font-size: 0.7738095238095238em; color: #5e93b8; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #5e93b8; }

blockquote, blockquote p { line-height: 1.6; color: #333; }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #ddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.8928571428571429em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.619047619047619em; }
  h2 { font-size: 2.2023809523809526em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6071428571428572em; }
  h4 { font-size: 1.369047619047619em; } }
/* Tables */
table { background: #fff; margin-bottom: 1.25em; border: solid 1px #d8d8ce; }
table thead, table tfoot { background: #eee; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #6d6e71; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f8f8f8; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.4; }

body { -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; tab-size: 4; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }

a:hover, a:focus { text-decoration: underline; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: inherit; font-style: normal !important; letter-spacing: 0; padding: 0; background-color: transparent; -webkit-border-radius: 0; border-radius: 0; line-height: inherit; word-wrap: break-word; }
*:not(pre) > code.nobreak { word-wrap: normal; }
*:not(pre) > code.nowrap { white-space: nowrap; }

pre, pre > code { line-height: 1.6; color: #264357; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }

em em { font-style: normal; }

strong strong { font-weight: normal; }

.keyseq { color: #333333; }

kbd { font-family: Consolas, "Liberation Mono", Courier, monospace; display: inline-block; color: black; font-size: 0.6190476190476191em; line-height: 1.45; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -moz-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: 0 0.15em; padding: 0.2em 0.5em; vertical-align: middle; position: relative; top: -0.1em; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menuref { color: #000; }

.menuseq b:not(.caret), .menuref { font-weight: inherit; }

.menuseq { word-spacing: -0.02em; }
.menuseq b.caret { font-size: 1.1904761904761905em; line-height: 0.8; }
.menuseq i.caret { font-weight: bold; text-align: center; width: 0.45em; }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 1.5em; padding-right: 1.5em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: black; margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #ddd; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #ddd; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #ddd; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: #5e93b8; display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: #333; }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: #333; }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: black; border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 0 solid #ddd; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: Noto, sans-serif; list-style-type: none; }
#toc li { line-height: 1.3334; margin-top: 0.3334em; }
#toc a { text-decoration: none; }
#toc a:active { text-decoration: underline; }

#toctitle { color: black; font-size: 1.1428571428571428em; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.3095238095238095em; }
  body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { margin-top: 0 !important; background-color: #fff; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #ddd; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.1428571428571428em; }
  #toc.toc2 > ul { font-size: 0.8571428571428571em; margin-bottom: 0; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #ddd; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
  #toc.toc2 { width: 20em; }
  #toc.toc2 #toctitle { font-size: 1.3095238095238095em; }
  #toc.toc2 > ul { font-size: 0.9047619047619048em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background-color: none; padding: 1.25em; }

#footer-text { color: black; line-height: 1.44; }

#content { margin-bottom: 0.625em; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { #content { margin-bottom: 1.25em; }
  .sect1 { padding-bottom: 1.25em; } }
.sect1:last-child { padding-bottom: 0; }

.sect1 + .sect1 { border-top: 0 solid #ddd; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.8095238095238095em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: black; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: black; }

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; }

table.tableblock > caption.title { white-space: nowrap; overflow: visible; max-width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: black; }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: initial; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: Noto, sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #ddd; color: #5e93b8; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: black; margin-top: 0; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint { background: #eee; }
.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint { background: #f2f1f1; }

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { border: 1px hidden #666; -webkit-border-radius: 0; border-radius: 0; word-wrap: break-word; padding: 1.25em 1.5625em 1.125em 1.5625em; font-size: 0.7738095238095238em; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.8630952380952381em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.9523809523809523em; } }

.literalblock.output pre { color: #eee; background-color: #264357; }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1.25em 1.5625em 1.125em 1.5625em; -webkit-border-radius: 0; border-radius: 0; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.7142857142857143em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: #999; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

table.pyhltable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; line-height: 1.6; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

pre.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #ddd; }

pre.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background: none !important; padding-right: 0 !important; }

.quoteblock { margin: 0 1em 0.75em 1.5em; display: table; }
.quoteblock > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock blockquote p { color: #333; font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.619047619047619em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: black; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.5em; margin-right: 0.5ex; text-align: right; }
.quoteblock .quoteblock { margin-left: 0; margin-right: 0; padding: 0.5em 0; border-left: 3px solid #5e93b8; }
.quoteblock .quoteblock blockquote { padding: 0 0 0 0.75em; }
.quoteblock .quoteblock blockquote:before { display: none; }

.verseblock { margin: 0 1em 0.75em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: #333; font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.7738095238095238em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.025em; color: #5e93b8; }

.quoteblock.abstract { margin: 0 0 0.75em 0; display: block; }
.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p { text-align: left; word-spacing: 0; }
.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before { display: none; }

table.tableblock { max-width: 100%; border-collapse: separate; }
table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid #d8d8ce; }

table.grid-all > thead > tr > .tableblock, table.grid-all > tbody > tr > .tableblock { border-width: 0 1px 1px 0; }

table.grid-all > tfoot > tr > .tableblock { border-width: 1px 1px 0 0; }

table.grid-cols > * > tr > .tableblock { border-width: 0 1px 0 0; }

table.grid-rows > thead > tr > .tableblock, table.grid-rows > tbody > tr > .tableblock { border-width: 0 0 1px 0; }

table.grid-rows > tfoot > tr > .tableblock { border-width: 1px 0 0 0; }

table.grid-all > * > tr > .tableblock:last-child, table.grid-cols > * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-all > tbody > tr:last-child > .tableblock, table.grid-all > thead:last-child > tr > .tableblock, table.grid-rows > tbody > tr:last-child > .tableblock, table.grid-rows > thead:last-child > tr > .tableblock { border-bottom-width: 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot { border-width: 1px 0; }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.4; background: #eee; }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: #222; font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 0.9523809523809523em; }

td > div.verse { white-space: pre; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.375em; }

ul.checklist, ul.none, ol.none, ul.no-bullet, ol.no-bullet, ol.unnumbered, ul.unstyled, ol.unstyled { list-style-type: none; }

ul.no-bullet, ol.no-bullet, ol.unnumbered { margin-left: 0.625em; }

ul.unstyled, ol.unstyled { margin-left: 0; }

ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1.25em; font-size: 0.7619047619047619em; position: relative; bottom: 0.125em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }

ul.inline { display: -ms-flexbox; display: -webkit-box; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; list-style: none; margin: 0 0 0.375em -0.75em; }

ul.inline > li { margin-left: 0.75em; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1, td.hdlist2 { vertical-align: top; padding: 0 0.625em; }

td.hdlist1 { font-weight: bold; padding-bottom: 0.75em; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0.4em 0.75em 0 0.75em; line-height: 1; vertical-align: top; }
.colist > table tr > td:first-of-type img { max-width: initial; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px #fff; -webkit-box-shadow: 0 0 0 1px #ddd; box-shadow: 0 0 0 1px #ddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; display: inline-block; }
a.image object { pointer-events: none; }

sup.footnote, sup.footnoteref { font-size: 0.8333333333333334em; position: static; vertical-align: super; }
sup.footnote a, sup.footnoteref a { text-decoration: none; }
sup.footnote a:active, sup.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -0.25em 0 0.75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em 0 0.225em; line-height: 1.3334; font-size: 0.8333333333333334em; margin-left: 1.2em; margin-bottom: 0.2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; margin-left: -1.05em; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }
a span.icon > .fa { cursor: inherit; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.380952380952381em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #29475c; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: black; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.7142857142857143em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { border-bottom: 1px solid #ddd; }

.sect1 { padding-bottom: 0; }

#toctitle { color: #00406F; font-weight: normal; margin-top: 1.5em; }

.sidebarblock { border-color: #aaa; }

code { -webkit-border-radius: 4px; border-radius: 4px; }

p.tableblock.header { color: #6d6e71; }

.literalblock pre, .listingblock pre { background: #eee; }

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
<link rel="stylesheet" href="katex/katex.min.css">
<script src="katex/katex.min.js"></script>
<script src="katex/contrib/auto-render.min.js"></script>
    <!-- Use KaTeX to render math once document is loaded, see
         https://github.com/Khan/KaTeX/tree/master/contrib/auto-render -->
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(
            document.body,
            {
                delimiters: [
                    { left: "$$", right: "$$", display: true},
                    { left: "\\[", right: "\\]", display: true},
                    { left: "$", right: "$", display: false},
                    { left: "\\(", right: "\\)", display: false}
                ]
            }
        );
    });
</script></head>
<body class="book toc2 toc-left" style="max-width: 100;">
<div id="header">
<h1>The OpenVX<sup>&#8482;</sup> Graph Pipelining, Streaming, and Batch Processing Extension</h1>
<div class="details">
<span id="author" class="author">The Khronos<sup>Â®</sup> OpenVX Working Group</span><br>
<span id="author2" class="author">Editors: Kedar Chitnis, Jesse Villareal, Radhakrishna Giduthuri, and Frank Brill</span><br>
<span id="revnumber">version 1.1.0,</span>
<span id="revdate">Wed, 10 Apr 2019 14:21:26 +0000</span>
<br><span id="revremark">Git branch information not available</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="#sec_purpose">1.1. Purpose</a></li>
<li><a href="#sec_acknowledge">1.2. Acknowledgements</a></li>
<li><a href="#sec_background">1.3. Background and Terminology</a>
<ul class="sectlevel3">
<li><a href="#sec_pipelining">1.3.1. Graph Pipelining</a></li>
<li><a href="#sec_batch_processing">1.3.2. Graph Batch Processing</a></li>
<li><a href="#sec_streaming">1.3.3. Graph Streaming</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#page_design">2. Design Overview</a>
<ul class="sectlevel2">
<li><a href="#data_references">2.1. Data reference</a></li>
<li><a href="#sec_design_pipelining">2.2. Pipelining and Batch Processing</a>
<ul class="sectlevel3">
<li><a href="#sec_design_queue">2.2.1. Graph Parameter Queues</a></li>
<li><a href="#sec_graph_schedule_config">2.2.2. Graph Schedule Configuration</a></li>
<li><a href="#sec_queue">2.2.3. Example Graph pipelining application</a></li>
<li><a href="#sec_batch_processing_app">2.2.4. Example Batch processing application</a></li>
</ul>
</li>
<li><a href="#sec_design_streaming">2.3. Streaming</a>
<ul class="sectlevel3">
<li><a href="#sec_sourcesink">2.3.1. Source/sink user nodes</a></li>
<li><a href="#sec_source_pipeup">2.3.2. Kernel Pipeup</a></li>
<li><a href="#sec_triggering">2.3.3. Graph streaming application</a></li>
</ul>
</li>
<li><a href="#sec_design_event">2.4. Event handling</a>
<ul class="sectlevel3">
<li><a href="#sec_limitations">2.4.1. Motivation for event handling</a></li>
<li><a href="#sec_using_event_handling">2.4.2. Event handling application</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#module_documentation">3. Module Documentation</a>
<ul class="sectlevel2">
<li><a href="#group_pipelining">3.1. Pipelining and Batch Processing</a>
<ul class="sectlevel3">
<li><a href="#_data_structures">3.1.1. Data Structures</a></li>
<li><a href="#_enumerations">3.1.2. Enumerations</a></li>
<li><a href="#_functions">3.1.3. Functions</a></li>
</ul>
</li>
<li><a href="#group_streaming">3.2. Streaming</a>
<ul class="sectlevel3">
<li><a href="#_enumerations_2">3.2.1. Enumerations</a></li>
<li><a href="#_functions_2">3.2.2. Functions</a></li>
</ul>
</li>
<li><a href="#group_event">3.3. Event Handling</a>
<ul class="sectlevel3">
<li><a href="#_data_structures_2">3.3.1. Data Structures</a></li>
<li><a href="#_enumerations_3">3.3.2. Enumerations</a></li>
<li><a href="#_functions_3">3.3.3. Functions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_conformance">4. Conformance</a>
<ul class="sectlevel2">
<li><a href="#_pipelining_batch_processing_event_handling">4.1. Pipelining, Batch Processing, Event Handling</a></li>
<li><a href="#_streaming">4.2. Streaming</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="imageblock text-center">
<div class="content">
<img src="data:image/svg+xml;base64,PHN2ZyBpZD0iT3BlblZYIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMjMyLjc1IDMwOC40MiI+PGRlZnM+PHN0eWxlPi5jbHMtMXtpc29sYXRpb246aXNvbGF0ZTt9LmNscy0ye2ZpbGw6I2M3MDUwNjt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPk9wZW5WWF9SR0JfTWF5MTY8L3RpdGxlPjxnIGlkPSJUTSIgY2xhc3M9ImNscy0xIj48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0xMjkwLjU5LDM0Ni4xOWgtNy4zNXYxOS4xMWgtNi40MlYzNDYuMTloLTcuMzV2LTUuNTJoMjEuMTF2NS41MmgwWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTg4LjE2IC0xMDMuNTcpIi8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMTI5My40NSwzNDAuNjdoOS40NWw0LjI0LDE2LjQyaDAuMDdsNC4yNC0xNi40Mmg5LjQ1djI0LjYzaC02di0xOC43aC0wLjA3bC01LjE4LDE4LjdoLTQuOWwtNS4xOC0xOC43aC0wLjA3djE4LjdoLTZWMzQwLjY3aDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtODguMTYgLTEwMy41NykiLz48L2c+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMjk0LDMzOC44Yy02OS43NC0yLjU1LTE2NC44OS0zNS40Ni0xODQuNjMtODMtMTcuMDctNDMuMjQtLjEzLTkzLjYsODAuMzctMTI5LjMsNDcuNzUtMjAuNTgsMTIwLTI2LjM4LDE3NS42My0yMS4xMSw3OSw3LjQ4LDE1NC4yLDQ5LjczLDE1NC4zLDQ5Ljg1djU5LjE5bC0wLjA2LDRBMzcxLjYyLDM3MS42MiwwLDAsMCw0NjQuNTEsMTc3Yy0yOC43OS0xNy40LTU1LjIxLTI5LjY5LTEwNy41Ny0zNC42OS0xMi4yNS0xLjE3LTMzLjEyLTQtNjYuOTEuODUtMTMuNjYsMi0zMi44OSwzLjQ2LTc2LjIsMjMuMTItMTQuMDksNi45LTI3LDE0LjMzLTM3LDIyLjkyLTUuMjUsNC41LTEyLjMxLDEwLjg0LTE3LjM3LDE2LjE4LTEyLjM1LDE2LTE4LjksMjgtMTUuNzcsNDkuOCwzLjYyLDE2LjM4LDEwLjY3LDI2LjY5LDMxLDQyLjM2LDguODEsNi43OSw5Ljg0LDYuNzUsMTMuNzQsOC44NCwzNi40MSwxOS40NSw2NS41LDI2LjYzLDEwNy4wNywzMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTg4LjE2IC0xMDMuNTcpIi8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMjk3LjcyLDE1MC41NGM2OS44OS0uMjgsMTY5LDI4LjY3LDE5NC44MSw3NS4yOEM1MTUuMTEsMjY4LjI0LDUwNC42OCwzMTkuMTcsNDI5LDM1OGMtNDUsMjIuNDUtMTE2LjMsMzEuMi0xNzIuNDYsMjguMTlDMTc2Ljc5LDM4Miw5Ni4zMywzNDIuOTEsOTYuMjIsMzQyLjc5bC03LjYxLTU5LTAuNDUtNHMyNy4zNiwyMS44OSw2MC4yNSwzOS4wNmMzMSwxNi4xOSw1OC44OSwyNy4zNiwxMTEuNzUsMzAuMjIsMTIuMzYsMC42NywzMy41NSwyLjY0LDY2LjYyLTMuNTcsMTMuMzctMi41MSwzMi4zNy00Ljc5LDczLTI2LjE1QzQxMywzMTEuODgsNDI0Ljg3LDMwNCw0MzMuNzYsMjk1QTIxNywyMTcsMCwwLDAsNDQ5LDI3OC4xNGMxMC4yNi0xNi40NywxNS4yNi0yOC43Miw5LjMzLTUwLjMyLTUuNzEtMTYuMTktMTQuMDctMjYuMTgtMzYuMzMtNDEtOS42Ni02LjQyLTEwLjY4LTYuMzQtMTQuODQtOC4yNi0zOC44MS0xNy45Mi02OC43NS0yMy44OS0xMTAuOS0yNy41OCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTg4LjE2IC0xMDMuNTcpIi8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNNTM4LjM1LDIzMy40MnYxNy41MWgwLjQyYTMxLjc4LDMxLjc4LDAsMCwxLDE2LjQ4LTE1LjY0QTYxLjU1LDYxLjU1LDAsMCwxLDU4MCwyMzAuNDFxMTUsMCwyNi4xLDUuNWE1My4yMyw1My4yMywwLDAsMSwxOC40OCwxNC44Nyw2Niw2NiwwLDAsMSwxMS4xMiwyMS42LDg4Ljc2LDg4Ljc2LDAsMCwxLDMuNzQsMjYsOTEuMzQsOTEuMzQsMCwwLDEtMy42MiwyNiw2MSw2MSwwLDAsMS0xMSwyMS4zNSw1MS42Miw1MS42MiwwLDAsMS0xOC40OSwxNC4zN3EtMTEuMTEsNS4yNC0yNS44NCw1LjI0YTY0LjI2LDY0LjI2LDAsMCwxLTEwLjYxLTEsNTkuMjQsNTkuMjQsMCwwLDEtMTEuNjEtMy4yNSw0NS4xOSw0NS4xOSwwLDAsMS0xMC44Ny02LjEzLDM0LDM0LDAsMCwxLTguNjEtOS42MmgtMC40MlY0MTJINTE2LjkzVjIzMy40MmgyMS40MlptNzYsNDUuOTNBNDcuNjEsNDcuNjEsMCwwLDAsNjA3LjEzLDI2NGEzNS4zOSwzNS4zOSwwLDAsMC0xMi40Ni0xMC43NCwzNy44MSwzNy44MSwwLDAsMC0xNy44MS00cS0xMC43MiwwLTE4LjE5LDQuMjRhMzYuMzUsMzYuMzUsMCwwLDAtMTIuMjEsMTEuMTEsNDYuMzQsNDYuMzQsMCwwLDAtNi44NSwxNS42MSw3NS44LDc1LjgsMCwwLDAsLjEyLDM2LjA4LDQ1LjU4LDQ1LjU4LDAsMCwwLDcuMSwxNS42LDM2LjA3LDM2LjA3LDAsMCwwLDEyLjU3LDEwLjg2cTcuNzQsNC4xNCwxOC43LDQuMTN0MTguMzEtNC4yM2EzNC4yLDM0LjIsMCwwLDAsMTEuODMtMTEuMjUsNDksNDksMCwwLDAsNi40OC0xNiw4NS41OSw4NS41OSwwLDAsMCwyLTE4LjQ4LDY2LjMsNjYuMywwLDAsMC0yLjM3LTE3LjYxIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtODguMTYgLTEwMy41NykiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik03NDguNjIsMzU0LjMzcS0xNC41MSwxMS0zNi41MywxMS0xNS41MSwwLTI2LjkxLTVhNTMuMTUsNTMuMTUsMCwwLDEtMTkuMTUtMTQsNTkuMjcsNTkuMjcsMCwwLDEtMTEuNjQtMjEuNDlBMTAzLjY2LDEwMy42NiwwLDAsMSw2NTAsMjk3LjYyYTc3LjMxLDc3LjMxLDAsMCwxLDQuNTEtMjcsNjQuNTUsNjQuNTUsMCwwLDEsMTIuNjQtMjEuMjQsNTcuNTEsNTcuNTEsMCwwLDEsMTkuMjktMTQsNTksNTksMCwwLDEsMjQuNDItNXExNy4yOSwwLDI4LjY3LDcuMTRhNTYuNTksNTYuNTksMCwwLDEsMTguMjksMTguMTUsNzEuNzEsNzEuNzEsMCwwLDEsOS41MiwyNCwxMDIuNjUsMTAyLjY1LDAsMCwxLDIuMTMsMjQuNzhINjcyLjcyYTUxLjI4LDUxLjI4LDAsMCwwLDIsMTYuMDhBMzYuNCwzNi40LDAsMCwwLDY4MiwzMzQuMDVhMzUuNjMsMzUuNjMsMCwwLDAsMTIuNzQsOS4zNSw0NCw0NCwwLDAsMCwxOC4yMiwzLjQ5cTEzLjQ5LDAsMjIuMS02LjI0dDExLjM2LTE5aDIxcS00LjI3LDIxLjcxLTE4Ljc3LDMyLjdtLTUuMTktODIuODlhMzYuMzcsMzYuMzcsMCwwLDAtNy43My0xMS41OSwzNi45MywzNi45MywwLDAsMC0xMS40Ny03LjcyLDM2LjIyLDM2LjIyLDAsMCwwLTE0LjU5LTIuODcsMzYuODYsMzYuODYsMCwwLDAtMTQuODUsMi44N0EzNC4zMiwzNC4zMiwwLDAsMCw2ODMuNDQsMjYwLDM3LjcyLDM3LjcyLDAsMCwwLDY3NiwyNzEuNTdhNDQuMDgsNDQuMDgsMCwwLDAtMy4yNSwxNC4wOWg3NC4wOWE0My43NSw0My43NSwwLDAsMC0zLjM4LTE0LjIyIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtODguMTYgLTEwMy41NykiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik04MDMuODIsMjM1LjUxVjI1NmgwLjRxMTMuMzEtMjMuNDksNDIuMjEtMjMuNTEsMTIuODEsMCwyMS4zNiwzLjUyYTM1LjA4LDM1LjA4LDAsMCwxLDEzLjgyLDkuNzVBMzYuMDgsMzYuMDgsMCwwLDEsODg5LDI2MC42NWE3OS45MSw3OS45MSwwLDAsMSwyLjE0LDE5LjE0djg1SDg2OS43NFYyNzcuMzRxMC0xMi03LTE5dC0xOS4yOS03YTQzLjU4LDQzLjU4LDAsMCwwLTE2LjkyLDMsMzEuNzQsMzEuNzQsMCwwLDAtMTEuOSw4LjUsMzYuNTUsMzYuNTUsMCwwLDAtNy4xNCwxMi44Nyw1Miw1MiwwLDAsMC0yLjM4LDE2LjEzdjczSDc4My42NlYyMzUuNTFoMjAuMTZaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtODguMTYgLTEwMy41NykiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik0xMDAyLjU4LDM2NS40MUg5NTIuMTlsLTY2LTIwMy4yNmg0Ni4xMmw0NS4yNywxNDIuOTFoMC41N2w0NS44My0xNDIuOTFIMTA3MFoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC04OC4xNiAtMTAzLjU3KSIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTExMzAuMTEsMjU4Ljk0bC02NS40OC05Ni43OWg1MS44MWwzOS44NSw2NC45MSw0MS4yOC02NC45MWg0OWwtNjUuMTksOTcuMDgsNzAuODgsMTA2LjE4SDExOTlsLTQ0LjQxLTcwLjMxLTQ1LjI2LDcwLjMxaC01MC4zOVoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC04OC4xNiAtMTAzLjU3KSIvPjwvc3ZnPg==" alt="OpenVX RGB" width="400">
</div>
</div>
<div class="paragraph">
<p>Copyright 2013-2019 The Khronos Group Inc.</p>
</div>
<div class="paragraph">
<p>This specification is protected by copyright laws and contains material
proprietary to Khronos.
Except as described by these terms, it or any components may not be
reproduced, republished, distributed, transmitted, displayed, broadcast or
otherwise exploited in any manner without the express prior written
permission of Khronos.</p>
</div>
<div class="paragraph">
<p>This specification has been created under the Khronos Intellectual Property
Rights Policy, which is Attachment A of the Khronos Group Membership
Agreement available at www.khronos.org/files/member_agreement.pdf.
Khronos Group grants a conditional copyright license to use and reproduce
the unmodified specification for any purpose, without fee or royalty, EXCEPT
no licenses to any patent, trademark or other intellectual property rights
are granted under these terms.
Parties desiring to implement the specification and make use of Khronos
trademarks in relation to that implementation, and receive reciprocal patent
license protection under the Khronos IP Policy must become Adopters and
confirm the implementation as conformant under the process defined by
Khronos for this specification; see <a href="https://www.khronos.org/adopters" class="bare">https://www.khronos.org/adopters</a>.</p>
</div>
<div class="paragraph">
<p>Khronos makes no, and expressly disclaims any, representations or
warranties, express or implied, regarding this specification, including,
without limitation: merchantability, fitness for a particular purpose,
non-infringement of any intellectual property, correctness, accuracy,
completeness, timeliness, and reliability.
Under no circumstances will Khronos, or any of its Promoters, Contributors
or Members, or their respective partners, officers, directors, employees,
agents or representatives be liable for any damages, whether direct,
indirect, special or consequential damages for lost revenues, lost profits,
or otherwise, arising from or in connection with these materials.</p>
</div>
<div class="paragraph">
<p>Khronos is a registered trademark, and OpenVX is a trademark of The Khronos
Group Inc.
OpenCL is a trademark of Apple Inc., used under license by Khronos.
All other product names, trademarks, and/or company names are used solely
for identification and belong to their respective owners.</p>
</div>
<div style="page-break-after: always;"></div>
<!-- toc disabled -->
</div>
</div>
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="sec_purpose">1.1. Purpose</h3>
<div class="paragraph">
<p>Enable multiple initiations of a given graph with different inputs and
outputs. Additionally, this extension provides a mechanism for the
application to execute a graph such that the application does not need to be
involved with data reconfiguration and starting processing of the graph for
each set of input/output data.</p>
</div>
</div>
<div class="sect2">
<h3 id="sec_acknowledge">1.2. Acknowledgements</h3>
<div class="paragraph">
<p>This specification would not be possible without the contributions from this
partial list of the following individuals from the Khronos Working Group and
the companies that they represented at the time:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Kedar Chitnis - Texas Instruments, Inc.</p>
</li>
<li>
<p>Jesse Villarreal - Texas Instruments, Inc.</p>
</li>
<li>
<p>Radhakrishna Giduthuri - Intel</p>
</li>
<li>
<p>Tomer Schwartz - Intel</p>
</li>
<li>
<p>Frank Brill - Cadence Design Systems</p>
</li>
<li>
<p>Thierry Lepley - Cadence Design Systems</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="sec_background">1.3. Background and Terminology</h3>
<div class="paragraph">
<p>This section introduces the concepts of graph pipelining, streaming and
batch processing before getting into the details of how OpenVX is extended
to support these features.</p>
</div>
<div class="sect3">
<h4 id="sec_pipelining">1.3.1. Graph Pipelining</h4>
<div class="paragraph">
<p>In order to demonstrate what is meant by pipelined execution, please refer
to the following example system which executes the simple graph in a
distributed manner:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgdmlld0JveD0iMCAwIDk1Ni4zNTUxNSAyOTUuODc1MjYiCiAgIGhlaWdodD0iNy44MjgzNjYzY20iCiAgIHdpZHRoPSIyNS4zMDM1NjRjbSIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgaWQ9InN2ZzEwIgogICB2ZXJzaW9uPSIxLjEiPjxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTE2Ij48cmRmOlJERj48Y2M6V29yawogICAgICAgICByZGY6YWJvdXQ9IiI+PGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+PGRjOnR5cGUKICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPjxkYzp0aXRsZT48L2RjOnRpdGxlPjwvY2M6V29yaz48L3JkZjpSREY+PC9tZXRhZGF0YT48ZGVmcwogICAgIGlkPSJkZWZzMTQiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMjYiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDI0IgogICAgICAgICBkPSJNIDAsMS4yMjA3ZS00IEggNzIwIFYgNTQwLjAwMDEyIEggMCBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0NCIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDIiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNjAiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDU4IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDc2IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg3NCIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg5MCIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoODgiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTA0IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgxMDIiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTE4IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgxMTYiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTMyIgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgxMzAiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTQ0IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgxNDIiCiAgICAgICAgIGQ9Ik0gLTcuMjA0ZS02LDU0MCBIIDcyMCBWIDAgSCAtNC42NTc1ZS01IiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGgxNTQiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDE1MiIKICAgICAgICAgZD0iTSAxLjk1MDJlLTUsNTQwIEggNzIwIFYgMS4yMjA3ZS00IEggLTEuOTg2OGUtNSIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTY0IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgxNjIiCiAgICAgICAgIGQ9Ik0gNy44ODFlLTYsNTQwIEggNzIwIFYgMCBIIC0zLjE0ODllLTUiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDE3NCIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoMTcyIgogICAgICAgICBkPSJNIC0yLjYyOThlLTUsNTQwIEggNzIwIFYgMS4yMjA3ZS00IEggLTYuNTY2OWUtNSIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTg0IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgxODIiCiAgICAgICAgIGQ9Ik0gNi45MDNlLTYsNTQwIEggNzIwIFYgMCBMIC0zLjI0NjdlLTUsNi4xMDM1ZS01IiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGgxOTQiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDE5MiIKICAgICAgICAgZD0iTSAtMS4yNDI0ZS01LDU0MCBIIDcyMCBWIDEuMjIwN2UtNCBIIC01LjE3OTRlLTUiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDIwNCIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoMjAyIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDIyNCIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoMjIyIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDIzNiIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoMjM0IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDI1MiIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoMjUwIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDI2NCIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoMjYyIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDI4MCIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoMjc4IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDI5MiIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoMjkwIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDMwNiIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoMzA0IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDMzNCIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoMzMyIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48L2RlZnM+PGcKICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLjMzMzMzMzMsMCwwLC0xLjMzMzMzMzMsOC45MjQxNzk0LDcyMS41MTA5MykiCiAgICAgaWQ9ImcxOCI+PHBhdGgKICAgICAgIGlkPSJwYXRoMzQiCiAgICAgICBzdHlsZT0iZmlsbDojZTZlNmU2O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAzNjQuNDIwMDUsNDc4LjI5OTk4IGggOTEuNDQgdiA0Ny42NCBoIC05MS40NCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDM2IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMzY0LjQyMDA1LDQ3OC4yOTk5OCBoIDkxLjQ0IHYgNDcuNjQgaCAtOTEuNDQgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzLjk5OTk0OSw1Ny45OTk5NzgpIgogICAgICAgaWQ9ImczOCI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDQpIgogICAgICAgICBpZD0iZzQwIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NDgiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOC4wMjQwMDAxN3B4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDM5NS4xNCw0MzcuNDIpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQ2IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTMuMDEzMzI4IDIyLjkyNjUyOSAzMi44OTM3OTkgNDIuODYxMDczIDQ3Ljk5NzkxMyI+Tm9kZSAwPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNTAiCiAgICAgICBzdHlsZT0iZmlsbDojYjNiM2IzO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSA0ODIuMDIwMDUsNDc4LjI5OTk4IGggOTEuMzIgdiA0Ny42NCBoIC05MS4zMiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDUyIgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNDgyLjAyMDA1LDQ3OC4yOTk5OCBoIDkxLjMyIHYgNDcuNjQgaCAtOTEuMzIgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzLjk5OTk0OSw1Ny45OTk5NzgpIgogICAgICAgaWQ9Imc1NCI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNjApIgogICAgICAgICBpZD0iZzU2Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NjQiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOC4wMjQwMDAxN3B4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDUxMi42OSw0MzcuNDIpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjYyIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTMuMDEzMzI4IDIyLjk2MjU3NiAzMi45ODM5MjEgNDIuOTMzMTY3IDQ4LjA3MDAwNyI+Tm9kZSAxPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNjYiCiAgICAgICBzdHlsZT0iZmlsbDojZmZjNWM1O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSA1OTMuODYwMDUsNDc4LjI5OTk4IGggOTEuNDQgdiA0Ny42NCBoIC05MS40NCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDY4IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNTkzLjg2MDA1LDQ3OC4yOTk5OCBoIDkxLjQ0IHYgNDcuNjQgaCAtOTEuNDQgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzLjk5OTk0OSw1Ny45OTk5NzgpIgogICAgICAgaWQ9Imc3MCI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNzYpIgogICAgICAgICBpZD0iZzcyIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0ODAiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOC4wMjQwMDAxN3B4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDYyNC41OCw0MzcuNDIpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3Bhbjc4IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTMuMDEzMzI4IDIyLjkyNjUyOSAzMi44OTM3OTkgNDIuODYxMDczIDQ3Ljk5NzkxMyI+Tm9kZSAyPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoODIiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAzMTkuMzAwMDUsNDMxLjM3OTk4IGggNTkuNzYgdiAyOC4zMiBoIC01OS43NiB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTMuOTk5OTQ5LDU3Ljk5OTk3OCkiCiAgICAgICBpZD0iZzg0Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg5MCkiCiAgICAgICAgIGlkPSJnODYiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ5NCIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE1Ljk2MDAwMDA0cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMzQwLjg3LDM4MS41NSkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuOTIiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCA0LjQzNjg4MDEgMTcuNzMxNTYgMjYuNjA1MzIgMzUuNDc5MDgiPkltYWdlPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoOTYiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA0MzguOTQwMDUsNDMxLjM3OTk4IGggNTkuNzYgdiAyOC4zMiBoIC01OS43NiB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTMuOTk5OTQ5LDU3Ljk5OTk3OCkiCiAgICAgICBpZD0iZzk4Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxMDQpIgogICAgICAgICBpZD0iZzEwMCI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDEwOCIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE1Ljk2MDAwMDA0cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNDYwLjYxLDM4MS41NSkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuMTA2IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgNC40MzY4ODAxIDE3LjczMTU2IDI2LjYwNTMyIDM1LjQ3OTA4Ij5JbWFnZTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDExMCIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDU0OC4xNDAwNSw0MzEuMzc5OTggaCA1OS43NiB2IDI4LjMyIGggLTU5Ljc2IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMy45OTk5NDksNTcuOTk5OTc4KSIKICAgICAgIGlkPSJnMTEyIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxMTgpIgogICAgICAgICBpZD0iZzExNCI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDEyMiIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE1Ljk2MDAwMDA0cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNTczLjA1LDM4MS41NSkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuMTIwIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTAuNjQ1MzIgMTUuOTYgMjEuMjc0Njc5IDMwLjE0ODQzOSI+QXJyYXk8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGgxMjQiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA2MzUuNjIwMDUsNDMxLjk3OTk4IGggNTkuNzYgdiAyOC4zMiBoIC01OS43NiB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTMuOTk5OTQ5LDU3Ljk5OTk3OCkiCiAgICAgICBpZD0iZzEyNiI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoMTMyKSIKICAgICAgICAgaWQ9ImcxMjgiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQxMzYiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxNS45NjAwMDAwNHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDY2MC41NSwzODIuMTgpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjEzNCIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDEwLjY0NTMyIDE1Ljk2IDIxLjI3NDY3OSAzMC4xNDg0MzkiPkFycmF5PC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMy45OTk5NDksNTcuOTk5OTc4KSIKICAgICAgIGlkPSJnMTM4Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxNDQpIgogICAgICAgICBpZD0iZzE0MCI+PHBhdGgKICAgICAgICAgICBpZD0icGF0aDE0NiIKICAgICAgICAgICBzdHlsZT0iZmlsbDojZGUwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGQ9Im0gMzYyLjYyLDQwMS43MyB2IDQyLjM5IGMgMCwwLjI4IDAuMjIsMC41IDAuNSwwLjUgaCAxNC4zMiB2IC0xIGggLTE0LjMyIGwgMC41LDAuNSB2IC00Mi4zOSB6IG0gOS4wNyw0Ni4zMiA2Ljc0LC0zLjkzIC02Ljc0LC0zLjkzIGMgLTAuMjQsLTAuMTQgLTAuNTQsLTAuMDYgLTAuNjgsMC4xOCAtMC4xNCwwLjI0IC0wLjA2LDAuNTQgMC4xOCwwLjY4IGwgNiwzLjUgdiAtMC44NiBsIC02LDMuNSBjIC0wLjI0LDAuMTQgLTAuMzIsMC40NCAtMC4xOCwwLjY4IDAuMTQsMC4yNCAwLjQ0LDAuMzIgMC42OCwwLjE4IHoiIC8+PC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzLjk5OTk0OSw1Ny45OTk5NzgpIgogICAgICAgaWQ9ImcxNDgiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDE1NCkiCiAgICAgICAgIGlkPSJnMTUwIj48cGF0aAogICAgICAgICAgIGlkPSJwYXRoMTU2IgogICAgICAgICAgIHN0eWxlPSJmaWxsOiNkZTAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgZD0ibSA0MjMuNTgsNDIwLjM2IHYgLTMyLjczIGMgMCwtMC4yNyAwLjIyLC0wLjUgMC41LC0wLjUgaCAyNy44NCB2IDEgaCAtMjcuODQgbCAwLjUsLTAuNSB2IDMyLjczIHogbSAyMi41OSwtMzYuNjYgNi43NCwzLjkzIC02Ljc0LDMuOTMgYyAtMC4yNCwwLjE0IC0wLjU0LDAuMDYgLTAuNjgsLTAuMTggLTAuMTQsLTAuMjMgLTAuMDYsLTAuNTQgMC4xOCwtMC42OCBsIDYsLTMuNSB2IDAuODYgbCAtNiwtMy41IGMgLTAuMjQsLTAuMTMgLTAuMzIsLTAuNDQgLTAuMTgsLTAuNjggMC4xNCwtMC4yNCAwLjQ0LC0wLjMyIDAuNjgsLTAuMTggeiIgLz48L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTMuOTk5OTQ5LDU3Ljk5OTk3OCkiCiAgICAgICBpZD0iZzE1OCI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoMTY0KSIKICAgICAgICAgaWQ9ImcxNjAiPjxwYXRoCiAgICAgICAgICAgaWQ9InBhdGgxNjYiCiAgICAgICAgICAgc3R5bGU9ImZpbGw6I2RlMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICBkPSJtIDQ4Mi4yNiw0MDEuNzMgdiA0Mi4zOSBjIDAsMC4yOCAwLjIyLDAuNSAwLjUsMC41IGggMTIuMTQgdiAtMSBoIC0xMi4xNCBsIDAuNSwwLjUgdiAtNDIuMzkgeiBtIDYuODksNDYuMzIgNi43NCwtMy45MyAtNi43NCwtMy45MyBjIC0wLjI0LC0wLjE0IC0wLjU0LC0wLjA2IC0wLjY4LDAuMTggLTAuMTQsMC4yNCAtMC4wNiwwLjU0IDAuMTgsMC42OCBsIDYsMy41IHYgLTAuODYgbCAtNiwzLjUgYyAtMC4yNCwwLjE0IC0wLjMyLDAuNDQgLTAuMTgsMC42OCAwLjE0LDAuMjQgMC40NCwwLjMyIDAuNjgsMC4xOCB6IiAvPjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMy45OTk5NDksNTcuOTk5OTc4KSIKICAgICAgIGlkPSJnMTY4Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxNzQpIgogICAgICAgICBpZD0iZzE3MCI+PHBhdGgKICAgICAgICAgICBpZD0icGF0aDE3NiIKICAgICAgICAgICBzdHlsZT0iZmlsbDojZGUwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGQ9Im0gNTQxLjE4LDQyMC4zNiB2IC0zMi43MyBjIDAsLTAuMjcgMC4yMiwtMC41IDAuNSwtMC41IGggMTkuNDYgdiAxIGggLTE5LjQ2IGwgMC41LC0wLjUgdiAzMi43MyB6IG0gMTQuMjIsLTM2LjY2IDYuNzQsMy45MyAtNi43NCwzLjkzIGMgLTAuMjQsMC4xNCAtMC41NSwwLjA2IC0wLjY5LC0wLjE4IC0wLjE0LC0wLjIzIC0wLjA2LC0wLjU0IDAuMTgsLTAuNjggbCA2LC0zLjUgdiAwLjg2IGwgLTYsLTMuNSBjIC0wLjI0LC0wLjEzIC0wLjMyLC0wLjQ0IC0wLjE4LC0wLjY4IDAuMTQsLTAuMjQgMC40NSwtMC4zMiAwLjY5LC0wLjE4IHoiIC8+PC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzLjk5OTk0OSw1Ny45OTk5NzgpIgogICAgICAgaWQ9ImcxNzgiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDE4NCkiCiAgICAgICAgIGlkPSJnMTgwIj48cGF0aAogICAgICAgICAgIGlkPSJwYXRoMTg2IgogICAgICAgICAgIHN0eWxlPSJmaWxsOiNkZTAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgZD0ibSA1OTEuNDYsNDAxLjczIHYgNDIuMzkgYyAwLDAuMjggMC4yMiwwLjUgMC41LDAuNSBoIDE0LjgzIHYgLTEgaCAtMTQuODMgbCAwLjUsMC41IHYgLTQyLjM5IHogbSA5LjU4LDQ2LjMyIDYuNzQsLTMuOTMgLTYuNzQsLTMuOTMgYyAtMC4yNCwtMC4xNCAtMC41NCwtMC4wNiAtMC42OCwwLjE4IC0wLjE0LDAuMjQgLTAuMDYsMC41NCAwLjE4LDAuNjggbCA2LDMuNSB2IC0wLjg2IGwgLTYsMy41IGMgLTAuMjQsMC4xNCAtMC4zMiwwLjQ0IC0wLjE4LDAuNjggMC4xNCwwLjI0IDAuNDQsMC4zMiAwLjY4LDAuMTggeiIgLz48L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTMuOTk5OTQ5LDU3Ljk5OTk3OCkiCiAgICAgICBpZD0iZzE4OCI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoMTk0KSIKICAgICAgICAgaWQ9ImcxOTAiPjxwYXRoCiAgICAgICAgICAgaWQ9InBhdGgxOTYiCiAgICAgICAgICAgc3R5bGU9ImZpbGw6I2RlMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICBkPSJtIDY1My4wMiw0MjAuMzYgdiAtOC45NiBjIDAsLTAuMjggMC4yMiwtMC41IDAuNSwtMC41IGggMjUuOTkgbCAtMC41LDAuNSB2IC03Ljk3IGggMSB2IDcuOTcgYyAwLDAuMjggLTAuMjMsMC41IC0wLjUsMC41IGggLTI1Ljk5IGwgMC41LC0wLjUgdiA4Ljk2IHogbSAyMi41NSwtMTEuMTggMy45NCwtNi43NCAzLjkzLDYuNzQgYyAwLjE0LDAuMjMgMC4wNiwwLjU0IC0wLjE4LDAuNjggLTAuMjQsMC4xNCAtMC41NSwwLjA2IC0wLjY5LC0wLjE4IGwgLTMuNSwtNiBoIDAuODcgbCAtMy41LDYgYyAtMC4xNCwwLjI0IC0wLjQ1LDAuMzIgLTAuNjksMC4xOCAtMC4yMywtMC4xNCAtMC4zMSwtMC40NSAtMC4xOCwtMC42OCB6IiAvPjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMy45OTk5NDksNTcuOTk5OTc4KSIKICAgICAgIGlkPSJnMTk4Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgyMDQpIgogICAgICAgICBpZD0iZzIwMCI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDIwOCIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNDY4LjE0LDMzMi42NCkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuMjA2IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTQuMDA0IDI0LjAxMTk5OSAzMy45NjYgNDMuOTczOTk5IDU1LjkyNTk5OSA2Ny44MDYgNzIuOTU0MDAyIDg2Ljk1OCA5Mi45NTIwMDMgMTAyLjk2IDExMi45MTQiPk9wZW5WWCBHcmFwaDwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDIxMCIKICAgICAgIHN0eWxlPSJmaWxsOiNkZTAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDguNTAwMDUxNyw0MjUuNDM5OTggMjAuMTAwMDAwMywyMC4xIHYgLTEwLjA1IEggMjgyLjA0MDA1IHYgMTAuMDUgbCAyMC4xLC0yMC4xIC0yMC4xLC0yMC4xIHYgMTAuMDUgSCAyOC42MDAwNTIgdiAtMTAuMDUgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgyMTIiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA4LjUwMDA1MTcsNDI1LjQzOTk4IDIwLjEwMDAwMDMsMjAuMSB2IC0xMC4wNSBIIDI4Mi4wNDAwNSB2IDEwLjA1IGwgMjAuMSwtMjAuMSAtMjAuMSwtMjAuMSB2IDEwLjA1IEggMjguNjAwMDUyIHYgLTEwLjA1IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMjE0IgogICAgICAgc3R5bGU9ImZpbGw6I2U2ZTZlNjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gNDQuMDIwMDUyLDQ3OC4yOTk5OCBoIDY1LjUxOTk5OCB2IDQ3LjY0IEggNDQuMDIwMDUyIFoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMjE2IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNDQuMDIwMDUyLDQ3OC4yOTk5OCBoIDY1LjUxOTk5OCB2IDQ3LjY0IEggNDQuMDIwMDUyIFoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMy45OTk5NDksNTcuOTk5OTc4KSIKICAgICAgIGlkPSJnMjE4Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgyMjQpIgogICAgICAgICBpZD0iZzIyMCI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDIyOCIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNzYuMTI4LDQ0OC4yMikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuMjI2IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgNS4wMDQwMDAyIDE3LjAxIj5JU1A8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzLjk5OTk0OSw1Ny45OTk5NzgpIgogICAgICAgaWQ9ImcyMzAiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDIzNikiCiAgICAgICAgIGlkPSJnMjMyIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0MjQwIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw3MC4wMDgsNDI2LjYpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjIzOCIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDEyLjk5NiAyOS4yODU5OTkiPkhXQTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDI0MiIKICAgICAgIHN0eWxlPSJmaWxsOiNiM2IzYjM7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDEyNi41ODAwNSw0NzguMjk5OTggaCA2NS41MiB2IDQ3LjY0IGggLTY1LjUyIHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMjQ0IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMTI2LjU4MDA1LDQ3OC4yOTk5OCBoIDY1LjUyIHYgNDcuNjQgaCAtNjUuNTIgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzLjk5OTk0OSw1Ny45OTk5NzgpIgogICAgICAgaWQ9ImcyNDYiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDI1MikiCiAgICAgICAgIGlkPSJnMjQ4Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0MjU2IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwxNTQuOCw0NDguMjIpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjI1NCIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDEyLjk5NiAyNS4wMDIwMDEiPkRTUDwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTMuOTk5OTQ5LDU3Ljk5OTk3OCkiCiAgICAgICBpZD0iZzI1OCI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoMjY0KSIKICAgICAgICAgaWQ9ImcyNjAiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQyNjgiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDE1NC4zMiw0MjYuNikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuMjY2IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTIuOTk2IDI1LjAwMjAwMSI+Q1BVPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoMjcwIgogICAgICAgc3R5bGU9ImZpbGw6I2ZmYzVjNTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMjA5Ljk4MDA1LDQ3OC4yOTk5OCBoIDY1LjQgdiA0Ny42NCBoIC02NS40IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMjcyIgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMjA5Ljk4MDA1LDQ3OC4yOTk5OCBoIDY1LjQgdiA0Ny42NCBoIC02NS40IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMy45OTk5NDksNTcuOTk5OTc4KSIKICAgICAgIGlkPSJnMjc0Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgyODApIgogICAgICAgICBpZD0iZzI3NiI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDI4NCIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMjM3LjYyLDQ0OC4yMikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuMjgyIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTIuOTk2IDI1LjAwMjAwMSI+Q1BVPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMy45OTk5NDksNTcuOTk5OTc4KSIKICAgICAgIGlkPSJnMjg2Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgyOTIpIgogICAgICAgICBpZD0iZzI4OCI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDI5NiIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4LjAyNDAwMDE3cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMjM3LjYyLDQyNi42MikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuMjk0IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTMuMDEzMzI4IDI0Ljk2MzI0Ij5DUFU8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGgyOTgiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA4MC45ODAwNTIsMzM0LjQxOTk4IGggODguOTE5OTk4IHYgNDcuNjQgSCA4MC45ODAwNTIgWiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEzLjk5OTk0OSw1Ny45OTk5NzgpIgogICAgICAgaWQ9ImczMDAiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDMwNikiCiAgICAgICAgIGlkPSJnMzAyIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0MzEwIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwxMDcuMDksMjkzLjU0KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW4zMDgiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCAxNC45OTQgMjUuMDAyMDAxIDM5Ljk5NTk5OCA0OS45MTQwMDEgNTUuOTA4MDAxIj5NZW1vcnk8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGgzMTIiCiAgICAgICBzdHlsZT0iZmlsbDojZGUwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSA2OC4zODAwNTIsNDY1LjY5OTk4IDEyLjYsMTIuNiAxMi41OTk5OTgsLTEyLjYgaCAtNi4zIHYgLTE1Ljk2IGggNi4zIGwgLTEyLjU5OTk5OCwtMTIuNiAtMTIuNiwxMi42IGggNi4zIHYgMTUuOTYgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgzMTQiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0Ojg7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDY4LjM4MDA1Miw0NjUuNjk5OTggMTIuNiwxMi42IDEyLjU5OTk5OCwtMTIuNiBoIC02LjMgdiAtMTUuOTYgaCA2LjMgbCAtMTIuNTk5OTk4LC0xMi42IC0xMi42LDEyLjYgaCA2LjMgdiAxNS45NiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDMxNiIKICAgICAgIHN0eWxlPSJmaWxsOiNkZTAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDE0OC4wNjAwNSw0NjUuNjk5OTggMTIuNiwxMi42IDEyLjYsLTEyLjYgaCAtNi4zIHYgLTE1Ljk2IGggNi4zIGwgLTEyLjYsLTEyLjYgLTEyLjYsMTIuNiBoIDYuMyB2IDE1Ljk2IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMzE4IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo4O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAxNDguMDYwMDUsNDY1LjY5OTk4IDEyLjYsMTIuNiAxMi42LC0xMi42IGggLTYuMyB2IC0xNS45NiBoIDYuMyBsIC0xMi42LC0xMi42IC0xMi42LDEyLjYgaCA2LjMgdiAxNS45NiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDMyMCIKICAgICAgIHN0eWxlPSJmaWxsOiNkZTAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDIzNC4yMjAwNSw0NjUuNjM5OTggMTIuNjYsMTIuNjYgMTIuNjYsLTEyLjY2IGggLTYuMzMgdiAtMTUuODQgaCA2LjMzIGwgLTEyLjY2LC0xMi42NiAtMTIuNjYsMTIuNjYgaCA2LjMzIHYgMTUuODQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgzMjIiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0Ojg7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDIzNC4yMjAwNSw0NjUuNjM5OTggMTIuNjYsMTIuNjYgMTIuNjYsLTEyLjY2IGggLTYuMzMgdiAtMTUuODQgaCA2LjMzIGwgLTEyLjY2LC0xMi42NiAtMTIuNjYsMTIuNjYgaCA2LjMzIHYgMTUuODQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgzMjQiCiAgICAgICBzdHlsZT0iZmlsbDojZGUwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAxMTMuOTgwMDUsNDA1LjE1OTk4IDEyLjY2LDEyLjY2IDEyLjY2LC0xMi42NiBoIC02LjMzIHYgLTE1Ljg0IGggNi4zMyBsIC0xMi42NiwtMTIuNjYgLTEyLjY2LDEyLjY2IGggNi4zMyB2IDE1Ljg0IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMzI2IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo4O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAxMTMuOTgwMDUsNDA1LjE1OTk4IDEyLjY2LDEyLjY2IDEyLjY2LC0xMi42NiBoIC02LjMzIHYgLTE1Ljg0IGggNi4zMyBsIC0xMi42NiwtMTIuNjYgLTEyLjY2LDEyLjY2IGggNi4zMyB2IDE1Ljg0IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMy45OTk5NDksNTcuOTk5OTc4KSIKICAgICAgIGlkPSJnMzI4Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgzMzQpIgogICAgICAgICBpZD0iZzMzMCI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDMzOCIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMjE4LjIxLDMwMy41NSkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuMzM2IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTIuMDA2IDIxLjk1OTk5OSI+U29DPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PC9nPjwvc3ZnPg==" alt="Fig1 Example SOC" width="800">
</div>
<div class="title">Figure 1. Example SoC and Distributed Graph</div>
</div>
<div class="paragraph">
<p>In this example, there are three compute units: an Image Signal Processor
(ISP) HWA, a Digital Signal Processor (DSP), and a CPU. The example graph
likewise, has three nodes: generically labelled Node 0, Node 1, and Node 2.
There could be more or less nodes than compute units, but here, the number
of nodes happens to be equal to the number of compute units. In this graph,
Node 0 is executed on the ISP, Node 1 is executed on the DSP, and Node 2 is
executed on the CPU. Without pipelining enabled, the execution timeline of
this graph is shown below:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgdmlld0JveD0iMCAwIDkwMS4yMzQzMSAyNjcuNzE1MjYiCiAgIGhlaWdodD0iNy4wODMyOTk2Y20iCiAgIHdpZHRoPSIyMy44NDUxNThjbSIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgaWQ9InN2ZzQwMTEiCiAgIHZlcnNpb249IjEuMSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNDAxNyI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48ZGM6dGl0bGU+PC9kYzp0aXRsZT48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczQwMTUiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDAyNyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDAyNSIKICAgICAgICAgZD0iTSAwLDEuMjIwN2UtNCBIIDcyMCBWIDU0MC4wMDAxMiBIIDAgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDA0NSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDA0MyIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0MDYxIgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0MDU5IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQwNzciCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQwNzUiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDA5NyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDA5NSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0MTEzIgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0MTExIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQxMzMiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQxMzEiCiAgICAgICAgIGQ9Ik0gLTIuMDllLTYsNTQwIEggNzIwIFYgMCBMIC0xLjE5MzNlLTUsNi4xMDM1ZS01IiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0MTQzIgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0MTQxIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQxNTUiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQxNTMiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDE2NyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDE2NSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0MTc5IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0MTc3IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQxOTEiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQxODkiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMzMzMzMzMywwLDAsLTEuMzMzMzMzMywtMy42ODM5MTQ5LDcxNS4yMzIxNykiCiAgICAgaWQ9Imc0MDE5Ij48cGF0aAogICAgICAgaWQ9InBhdGg0MDM1IgogICAgICAgc3R5bGU9ImZpbGw6I2Q5ZDlkOTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gNzQuNTI1NDU0LDQ3Mi4yNzA5MSBoIDkzLjU5OTk5NiB2IDI4LjA4IEggNzQuNTI1NDU0IFoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNDAzNyIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDc0LjUyNTQ1NCw0NzIuMjcwOTEgaCA5My41OTk5OTYgdiAyOC4wOCBIIDc0LjUyNTQ1NCBaIiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjAuNDU0NTQ2LDEzOS4wOTA5MSkiCiAgICAgICBpZD0iZzQwMzkiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQwNDUpIgogICAgICAgICBpZD0iZzQwNDEiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0MDQ5IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwxMDguMjQsMzQwLjU0KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40MDQ3IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTAuOTk4IDE2Ljk5MjAwMSAyNyA0MS45OTM5OTkgNTIuMDAxOTk5IDU3LjAwNjAwMSI+RnJhbWUgMTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDQwNTEiCiAgICAgICBzdHlsZT0iZmlsbDojN2Y3ZjdmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAxNzcuMjQ1NDUsNDMyLjE5MDkxIGggOTMuNDggdiAyOC4wOCBoIC05My40OCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQwNTMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAxNzcuMjQ1NDUsNDMyLjE5MDkxIGggOTMuNDggdiAyOC4wOCBoIC05My40OCB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjAuNDU0NTQ2LDEzOS4wOTA5MSkiCiAgICAgICBpZD0iZzQwNTUiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQwNjEpIgogICAgICAgICBpZD0iZzQwNTciPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0MDY1IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwyMTAuOTYsMzAwLjQ4KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40MDYzIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTAuOTk4IDE2Ljk5MjAwMSAyNyA0MS45OTM5OTkgNTIuMDAxOTk5IDU3LjAwNjAwMSI+RnJhbWUgMTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDQwNjciCiAgICAgICBzdHlsZT0iZmlsbDojZmZjNWM1O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAyODIuNzI1NDUsMzk0Ljg3MDkxIGggOTMuNiB2IDI4LjA4IGggLTkzLjYgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg0MDY5IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMjgyLjcyNTQ1LDM5NC44NzA5MSBoIDkzLjYgdiAyOC4wOCBoIC05My42IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMC40NTQ1NDYsMTM5LjA5MDkxKSIKICAgICAgIGlkPSJnNDA3MSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDA3NykiCiAgICAgICAgIGlkPSJnNDA3MyI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQwODEiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDMxNi40OSwyNjMuMDYpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQwNzkiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCAxMC45OTggMTYuOTkyMDAxIDI3IDQxLjk5Mzk5OSA1Mi4wMDE5OTkgNTcuMDA2MDAxIj5GcmFtZSAxPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNDA4MyIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNkZTAwMDA7c3Ryb2tlLXdpZHRoOjAuNzIwMDAwMDM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDc0LjQ2NTQ1NCw1MjAuOTMwOTEgdiAtMTcxLjEyIiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQwODUiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojZGUwMDAwO3N0cm9rZS13aWR0aDowLjcyMDAwMDAzO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMC41NDU0NTQsMzk0LjQ1MDkxIEggNjY0LjUxNTQ1IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQwODciCiAgICAgICBzdHlsZT0iZmlsbDojZDlkOWQ5O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAzOTAuODQ1NDUsNDcyLjUxMDkxIGggOTMuNDggdiAyNy45NiBoIC05My40OCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQwODkiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAzOTAuODQ1NDUsNDcyLjUxMDkxIGggOTMuNDggdiAyNy45NiBoIC05My40OCB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjAuNDU0NTQ2LDEzOS4wOTA5MSkiCiAgICAgICBpZD0iZzQwOTEiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQwOTcpIgogICAgICAgICBpZD0iZzQwOTMiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0MTAxIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw0MjQuNTgsMzQwLjY4KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40MDk5IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTAuOTk4IDE2Ljk5MjAwMSAyNyA0MS45OTM5OTkgNTIuMDAxOTk5IDU3LjAwNjAwMSI+RnJhbWUgMjwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDQxMDMiCiAgICAgICBzdHlsZT0iZmlsbDojN2Y3ZjdmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSA0OTYuMzI1NDUsNDMyLjU1MDkxIGggOTMuNiB2IDI4LjA4IGggLTkzLjYgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg0MTA1IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNDk2LjMyNTQ1LDQzMi41NTA5MSBoIDkzLjYgdiAyOC4wOCBoIC05My42IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMC40NTQ1NDYsMTM5LjA5MDkxKSIKICAgICAgIGlkPSJnNDEwNyI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDExMykiCiAgICAgICAgIGlkPSJnNDEwOSI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQxMTciCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDUzMC4wOSwzMDAuNzkpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQxMTUiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCAxMC45OTggMTYuOTkyMDAxIDI3IDQxLjk5Mzk5OSA1Mi4wMDE5OTkgNTcuMDA2MDAxIj5GcmFtZSAyPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNDExOSIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNkZTAwMDA7c3Ryb2tlLXdpZHRoOjAuNzIwMDAwMDM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDE3Ni45NDU0NSw1MTguMTcwOTEgdiAtMTIzLjc0IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQxMjEiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojZGUwMDAwO3N0cm9rZS13aWR0aDowLjcyMDAwMDAzO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAyODIuNjY1NDUsNTE0LjY5MDkxIHYgLTEyMy43NCIgLz48cGF0aAogICAgICAgaWQ9InBhdGg0MTIzIgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2RlMDAwMDtzdHJva2Utd2lkdGg6MC43MjAwMDAwMztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMzg5LjIyNTQ1LDUxOC42NTA5MSB2IC0xMjMuNzQiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNDEyNSIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNkZTAwMDA7c3Ryb2tlLXdpZHRoOjAuNzIwMDAwMDM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDQ5Ni4yNjU0NSw1MjIuMjUwOTEgdiAtMTIzLjc0IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjAuNDU0NTQ2LDEzOS4wOTA5MSkiCiAgICAgICBpZD0iZzQxMjciPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQxMzMpIgogICAgICAgICBpZD0iZzQxMjkiPjxwYXRoCiAgICAgICAgICAgaWQ9InBhdGg0MTM1IgogICAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNkZTAwMDA7c3Ryb2tlLXdpZHRoOjAuNzIwMDAwMDM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgICAgZD0ibSAxOTguODQsMjU1Ljg0IGMgMCwtNy44OSAtMS4wNywtMTQuMjggLTIuMzgsLTE0LjI4IGggLTQ3LjIgYyAtMS4zMSwwIC0yLjM4LC02LjM5IC0yLjM4LC0xNC4yOCAwLDcuODkgLTEuMDcsMTQuMjggLTIuMzgsMTQuMjggSCA5Ny4zIGMgLTEuMzE0LDAgLTIuMzgsNi4zOSAtMi4zOCwxNC4yOCIgLz48L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjAuNDU0NTQ2LDEzOS4wOTA5MSkiCiAgICAgICBpZD0iZzQxMzciPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQxNDMpIgogICAgICAgICBpZD0iZzQxMzkiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0MTQ3IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTUuOTYwMDAwMDRweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwxNTUuNzQsMjE4LjA5KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40MTQ1IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgOC44NzM3NjAyIDE3Ljc0NzUyIDMxLjA0MjIiPjMzbXM8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIwLjQ1NDU0NiwxMzkuMDkwOTEpIgogICAgICAgaWQ9Imc0MTQ5Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg0MTU1KSIKICAgICAgICAgaWQ9Imc0MTUxIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NDE1OSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMzUuNzEyLDM0MC4wMSkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDE1NyIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDUuMDA0MDAwMiAxNy4wMSI+SVNQPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMC40NTQ1NDYsMTM5LjA5MDkxKSIKICAgICAgIGlkPSJnNDE2MSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDE2NykiCiAgICAgICAgIGlkPSJnNDE2MyI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQxNzEiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDM2LjMxMiwzMDAuMSkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDE2OSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDEyLjk5NiAyNS4wMDIwMDEiPkRTUDwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjAuNDU0NTQ2LDEzOS4wOTA5MSkiCiAgICAgICBpZD0iZzQxNzMiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQxNzkpIgogICAgICAgICBpZD0iZzQxNzUiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0MTgzIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwzOC4yNTYsMjYyLjczKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40MTgxIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTIuOTk2IDI1LjAwMjAwMSI+Q1BVPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMC40NTQ1NDYsMTM5LjA5MDkxKSIKICAgICAgIGlkPSJnNDE4NSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDE5MSkiCiAgICAgICAgIGlkPSJnNDE4NyI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQxOTUiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxNS45NjAwMDAwNHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDYzOC4yNiwyNjIuNzgpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQxOTMiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCA0LjQzNjg4MDEgOC4wMjc4Nzk3IDIxLjMyMjU1OSI+dGltZTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjwvZz48L3N2Zz4=" alt="Fig2 Non pipelined" width="800">
</div>
<div class="title">Figure 2. Non-pipelined Execution</div>
</div>
<div class="paragraph">
<p>Assuming each node takes 33ms to execute, then the full graph takes 99ms to
execute. Without this extension, OpenVX requires that a second frame can not
start graph execution on this same graph until the first graph execution is
completed. This means that the maximum throughput of this example will be
one frame completing every 99ms. However, in this example, you can see that
each compute unit is only utilized no more than one-third of the time.
Furthermore, if the camera input produced a frame every 33ms, then every two
out of three frames would need to be &#8220;dropped&#8221; by the system since this
OpenVX graph implementation can not keep up with the input frame rate of the
camera.</p>
</div>
<div class="paragraph">
<p>Pipelining the graph exection will both increase the hardware utilization, and
increase the throughput of the OpenVX implementation.  These effects can be
seen in the timeline of a pipelined execution of the graph below:</p>
</div>
<div id="fig-pipelined-exec" class="imageblock text-center">
<div class="content">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgdmlld0JveD0iMCAwIDkwMS4yMDIzMSAyNjcuNTU1MjciCiAgIGhlaWdodD0iNy4wNzkwNjYzY20iCiAgIHdpZHRoPSIyMy44NDQzMTFjbSIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgaWQ9InN2ZzQxOTciCiAgIHZlcnNpb249IjEuMSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNDIwMyI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48ZGM6dGl0bGU+PC9kYzp0aXRsZT48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczQyMDEiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDIxMyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDIxMSIKICAgICAgICAgZD0iTSAwLDEuMjIwN2UtNCBIIDcyMCBWIDU0MC4wMDAxMiBIIDAgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDIzMSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDIyOSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0MjQ3IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0MjQ1IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQyNjMiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQyNjEiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDI3OSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDI3NyIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0Mjk1IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0MjkzIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQzMTEiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQzMDkiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDMyNyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDMyNSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0MzQzIgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0MzQxIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQzNTkiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQzNTciCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDM3OSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDM3NyIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0Mzk1IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0MzkzIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQ0MTEiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQ0MDkiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDQzMSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDQyOSIKICAgICAgICAgZD0iTSAtMS44NTdlLTYsNTQwIEggNzIwIFYgMCBIIC0xLjE3ZS01IiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0NDQxIgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0NDM5IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQ0NTMiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQ0NTEiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDQ2NSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDQ2MyIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0NDc3IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0NDc1IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQ0ODkiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQ0ODciCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMzMzMzMzMywwLDAsLTEuMzMzMzMzMywtMjIuNjI1MjUzLDcwMy4zNTU5MykiCiAgICAgaWQ9Imc0MjA1Ij48cGF0aAogICAgICAgaWQ9InBhdGg0MjIxIgogICAgICAgc3R5bGU9ImZpbGw6I2Q5ZDlkOTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gODguODI3NDYsNDYzLjQ4MzczIGggOTMuNDggdiAyNy45NiBoIC05My40OCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQyMjMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA4OC44Mjc0Niw0NjMuNDgzNzMgaCA5My40OCB2IDI3Ljk2IGggLTkzLjQ4IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC05LjE1MjU0MjQsMTMwLjQyMzczKSIKICAgICAgIGlkPSJnNDIyNSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDIzMSkiCiAgICAgICAgIGlkPSJnNDIyNyI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQyMzUiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDExMS4xNCwzNDAuMzQpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQyMzMiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCAxMC45OTggMTYuOTkyMDAxIDI3IDQxLjk5Mzk5OSA1Mi4wMDE5OTkgNTcuMDA2MDAxIj5GcmFtZSAxPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNDIzNyIKICAgICAgIHN0eWxlPSJmaWxsOiNkOWQ5ZDk7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDE5MS40Mjc0Niw0NjMuNDgzNzMgaCA5My42IHYgMjcuOTYgaCAtOTMuNiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQyMzkiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAxOTEuNDI3NDYsNDYzLjQ4MzczIGggOTMuNiB2IDI3Ljk2IGggLTkzLjYgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTkuMTUyNTQyNCwxMzAuNDIzNzMpIgogICAgICAgaWQ9Imc0MjQxIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg0MjQ3KSIKICAgICAgICAgaWQ9Imc0MjQzIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NDI1MSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMjEzLjg2LDM0MC4zNCkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDI0OSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDEwLjk5OCAxNi45OTIwMDEgMjcgNDEuOTkzOTk5IDUyLjAwMTk5OSA1Ny4wMDYwMDEiPkZyYW1lIDI8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg0MjUzIgogICAgICAgc3R5bGU9ImZpbGw6IzdmN2Y3ZjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMTkxLjQyNzQ2LDQyMy40MDM3MyBoIDkzLjYgdiAyOC4wOCBoIC05My42IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNDI1NSIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDE5MS40Mjc0Niw0MjMuNDAzNzMgaCA5My42IHYgMjguMDggaCAtOTMuNiB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtOS4xNTI1NDI0LDEzMC40MjM3MykiCiAgICAgICBpZD0iZzQyNTciPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQyNjMpIgogICAgICAgICBpZD0iZzQyNTkiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0MjY3IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwyMTMuODYsMzAwLjI5KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40MjY1IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTAuOTk4IDE2Ljk5MjAwMSAyNyA0MS45OTM5OTkgNTIuMDAxOTk5IDU3LjAwNjAwMSI+RnJhbWUgMTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDQyNjkiCiAgICAgICBzdHlsZT0iZmlsbDojN2Y3ZjdmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAyOTcuMDI3NDYsNDIzLjQwMzczIGggOTMuNDggdiAyOC4wOCBoIC05My40OCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQyNzEiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAyOTcuMDI3NDYsNDIzLjQwMzczIGggOTMuNDggdiAyOC4wOCBoIC05My40OCB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtOS4xNTI1NDI0LDEzMC40MjM3MykiCiAgICAgICBpZD0iZzQyNzMiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQyNzkpIgogICAgICAgICBpZD0iZzQyNzUiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0MjgzIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwzMTkuMzksMzAwLjI5KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40MjgxIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTAuOTk4IDE2Ljk5MjAwMSAyNyA0MS45OTM5OTkgNTIuMDAxOTk5IDU3LjAwNjAwMSI+RnJhbWUgMjwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDQyODUiCiAgICAgICBzdHlsZT0iZmlsbDojZDlkOWQ5O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAyOTcuMDI3NDYsNDYzLjQ4MzczIGggOTMuNDggdiAyNy45NiBoIC05My40OCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQyODciCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAyOTcuMDI3NDYsNDYzLjQ4MzczIGggOTMuNDggdiAyNy45NiBoIC05My40OCB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtOS4xNTI1NDI0LDEzMC40MjM3MykiCiAgICAgICBpZD0iZzQyODkiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQyOTUpIgogICAgICAgICBpZD0iZzQyOTEiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0Mjk5IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwzMTkuMzksMzQwLjM0KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40Mjk3IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTAuOTk4IDE2Ljk5MjAwMSAyNyA0MS45OTM5OTkgNTIuMDAxOTk5IDU3LjAwNjAwMSI+RnJhbWUgMzwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDQzMDEiCiAgICAgICBzdHlsZT0iZmlsbDojZmZjNWM1O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAyOTcuMDI3NDYsMzg1Ljk2MzczIGggOTMuNDggdiAyOC4wOCBoIC05My40OCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQzMDMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAyOTcuMDI3NDYsMzg1Ljk2MzczIGggOTMuNDggdiAyOC4wOCBoIC05My40OCB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtOS4xNTI1NDI0LDEzMC40MjM3MykiCiAgICAgICBpZD0iZzQzMDUiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQzMTEpIgogICAgICAgICBpZD0iZzQzMDciPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0MzE1IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwzMTkuMzksMjYyLjg3KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40MzEzIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTAuOTk4IDE2Ljk5MjAwMSAyNyA0MS45OTM5OTkgNTIuMDAxOTk5IDU3LjAwNjAwMSI+RnJhbWUgMTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDQzMTciCiAgICAgICBzdHlsZT0iZmlsbDojN2Y3ZjdmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSA0MDUuMDI3NDYsNDIzLjQwMzczIGggOTMuNiB2IDI4LjA4IGggLTkzLjYgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg0MzE5IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNDA1LjAyNzQ2LDQyMy40MDM3MyBoIDkzLjYgdiAyOC4wOCBoIC05My42IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC05LjE1MjU0MjQsMTMwLjQyMzczKSIKICAgICAgIGlkPSJnNDMyMSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDMyNykiCiAgICAgICAgIGlkPSJnNDMyMyI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQzMzEiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDQyNy40OSwzMDAuMjkpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQzMjkiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCAxMC45OTggMTYuOTkyMDAxIDI3IDQxLjk5Mzk5OSA1Mi4wMDE5OTkgNTcuMDA2MDAxIj5GcmFtZSAzPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNDMzMyIKICAgICAgIHN0eWxlPSJmaWxsOiNmZmM1YzU7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDQwNS4wMjc0NiwzODUuOTYzNzMgaCA5My42IHYgMjguMDggaCAtOTMuNiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQzMzUiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA0MDUuMDI3NDYsMzg1Ljk2MzczIGggOTMuNiB2IDI4LjA4IGggLTkzLjYgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTkuMTUyNTQyNCwxMzAuNDIzNzMpIgogICAgICAgaWQ9Imc0MzM3Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg0MzQzKSIKICAgICAgICAgaWQ9Imc0MzM5Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NDM0NyIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNDI3LjQ5LDI2Mi44NykiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDM0NSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDEwLjk5OCAxNi45OTIwMDEgMjcgNDEuOTkzOTk5IDUyLjAwMTk5OSA1Ny4wMDYwMDEiPkZyYW1lIDI8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg0MzQ5IgogICAgICAgc3R5bGU9ImZpbGw6I2ZmYzVjNTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gNTEwLjYyNzQ2LDM4NS40ODM3MyBoIDkzLjQ4IHYgMjguMDggaCAtOTMuNDggeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg0MzUxIgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNTEwLjYyNzQ2LDM4NS40ODM3MyBoIDkzLjQ4IHYgMjguMDggaCAtOTMuNDggeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTkuMTUyNTQyNCwxMzAuNDIzNzMpIgogICAgICAgaWQ9Imc0MzUzIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg0MzU5KSIKICAgICAgICAgaWQ9Imc0MzU1Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NDM2MyIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNTMyLjk5LDI2Mi40MikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDM2MSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDEwLjk5OCAxNi45OTIwMDEgMjcgNDEuOTkzOTk5IDUyLjAwMTk5OSA1Ny4wMDYwMDEiPkZyYW1lIDM8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg0MzY1IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2RlMDAwMDtzdHJva2Utd2lkdGg6MC43MjAwMDAwMztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gODguNzY3NDYsNTEyLjE0MzczIHYgLTE3MS4xMiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg0MzY3IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2RlMDAwMDtzdHJva2Utd2lkdGg6MC43MjAwMDAwMztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNDQuNzI3NDU4LDM4NS41NDM3MyBIIDY3OC42OTc0NiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg0MzY5IgogICAgICAgc3R5bGU9ImZpbGw6I2Q5ZDlkOTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gNDA1LjAyNzQ2LDQ2My42MDM3MyBoIDkzLjYgdiAyOC4wOCBoIC05My42IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNDM3MSIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDQwNS4wMjc0Niw0NjMuNjAzNzMgaCA5My42IHYgMjguMDggaCAtOTMuNiB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtOS4xNTI1NDI0LDEzMC40MjM3MykiCiAgICAgICBpZD0iZzQzNzMiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQzNzkpIgogICAgICAgICBpZD0iZzQzNzUiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0MzgzIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw0MjcuNDksMzQwLjUxKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40MzgxIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTAuOTk4IDE2Ljk5MjAwMSAyNyA0MS45OTM5OTkgNTIuMDAxOTk5IDU3LjAwNjAwMSI+RnJhbWUgNDwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDQzODUiCiAgICAgICBzdHlsZT0iZmlsbDojN2Y3ZjdmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSA1MTAuNjI3NDYsNDIzLjc2MzczIGggOTMuNDggdiAyNy45NiBoIC05My40OCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQzODciCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA1MTAuNjI3NDYsNDIzLjc2MzczIGggOTMuNDggdiAyNy45NiBoIC05My40OCB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtOS4xNTI1NDI0LDEzMC40MjM3MykiCiAgICAgICBpZD0iZzQzODkiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQzOTUpIgogICAgICAgICBpZD0iZzQzOTEiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0Mzk5IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw1MzIuOTksMzAwLjYpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQzOTciCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCAxMC45OTggMTYuOTkyMDAxIDI3IDQxLjk5Mzk5OSA1Mi4wMDE5OTkgNTcuMDA2MDAxIj5GcmFtZSA0PC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNDQwMSIKICAgICAgIHN0eWxlPSJmaWxsOiNkOWQ5ZDk7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDUxMC42Mjc0Niw0NjMuMjQzNzMgaCA5My40OCB2IDI4LjA4IGggLTkzLjQ4IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNDQwMyIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDUxMC42Mjc0Niw0NjMuMjQzNzMgaCA5My40OCB2IDI4LjA4IGggLTkzLjQ4IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC05LjE1MjU0MjQsMTMwLjQyMzczKSIKICAgICAgIGlkPSJnNDQwNSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDQxMSkiCiAgICAgICAgIGlkPSJnNDQwNyI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQ0MTUiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDUzMi45OSwzNDAuMikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDQxMyIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDEwLjk5OCAxNi45OTIwMDEgMjcgNDEuOTkzOTk5IDUyLjAwMTk5OSA1Ny4wMDYwMDEiPkZyYW1lIDU8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg0NDE3IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2RlMDAwMDtzdHJva2Utd2lkdGg6MC43MjAwMDAwMztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMTkxLjEyNzQ2LDUwOS4zODM3MyB2IC0xMjMuNzQiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNDQxOSIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNkZTAwMDA7c3Ryb2tlLXdpZHRoOjAuNzIwMDAwMDM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDI5Ni45Njc0Niw1MDUuOTAzNzMgdiAtMTIzLjc0IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQ0MjEiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojZGUwMDAwO3N0cm9rZS13aWR0aDowLjcyMDAwMDAzO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA0MDMuNDA3NDYsNTA5Ljc0MzczIHYgLTEyMy43NCIgLz48cGF0aAogICAgICAgaWQ9InBhdGg0NDIzIgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2RlMDAwMDtzdHJva2Utd2lkdGg6MC43MjAwMDAwMztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNTEwLjU2NzQ2LDUxMy4zNDM3MyB2IC0xMjMuNzQiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC05LjE1MjU0MjQsMTMwLjQyMzczKSIKICAgICAgIGlkPSJnNDQyNSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDQzMSkiCiAgICAgICAgIGlkPSJnNDQyNyI+PHBhdGgKICAgICAgICAgICBpZD0icGF0aDQ0MzMiCiAgICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2RlMDAwMDtzdHJva2Utd2lkdGg6MC43MjAwMDAwMztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgICBkPSJtIDIwMS43MiwyNTUuNiBjIDAsLTcuODkgLTEuMDcsLTE0LjI4IC0yLjM4LC0xNC4yOCBIIDE1Mi4yIGMgLTEuMzEsMCAtMi4zOCwtNi4zOSAtMi4zOCwtMTQuMjggMCw3Ljg5IC0xLjA3LDE0LjI4IC0yLjM4LDE0LjI4IEggMTAwLjMgYyAtMS4zMTQsMCAtMi4zOCw2LjM5IC0yLjM4LDE0LjI4IiAvPjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC05LjE1MjU0MjQsMTMwLjQyMzczKSIKICAgICAgIGlkPSJnNDQzNSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDQ0MSkiCiAgICAgICAgIGlkPSJnNDQzNyI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQ0NDUiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxNS45NjAwMDAwNHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDE1OC42NCwyMTcuOTIpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQ0NDMiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCA4Ljg3Mzc2MDIgMTcuNzQ3NTIgMzEuMDQyMiI+MzNtczwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtOS4xNTI1NDI0LDEzMC40MjM3MykiCiAgICAgICBpZD0iZzQ0NDciPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ0NTMpIgogICAgICAgICBpZD0iZzQ0NDkiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0NDU3IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwzOC42MTYsMzM5LjgyKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40NDU1IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgNS4wMDQwMDAyIDE3LjAxIj5JU1A8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTkuMTUyNTQyNCwxMzAuNDIzNzMpIgogICAgICAgaWQ9Imc0NDU5Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg0NDY1KSIKICAgICAgICAgaWQ9Imc0NDYxIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NDQ2OSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4LjAyNDAwMDE3cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMzkuMjE2LDI5OS45MykiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDQ2NyIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDEzLjAxMzMyOCAyNC45NjMyNCI+RFNQPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC05LjE1MjU0MjQsMTMwLjQyMzczKSIKICAgICAgIGlkPSJnNDQ3MSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDQ3NykiCiAgICAgICAgIGlkPSJnNDQ3MyI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQ0ODEiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDQxLjE2LDI2Mi41NikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDQ3OSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDEyLjk5NiAyNS4wMDIwMDEiPkNQVTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtOS4xNTI1NDI0LDEzMC40MjM3MykiCiAgICAgICBpZD0iZzQ0ODMiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ0ODkpIgogICAgICAgICBpZD0iZzQ0ODUiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0NDkzIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTUuOTg0MDAwMjFweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw2NDEuMTYsMjYyLjYxKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40NDkxIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgNC40NDM1NTIgOC4wMjM5Njc3IDIxLjMzODY0Ij50aW1lPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PC9nPjwvc3ZnPg==" alt="Fig3 Frame level pipelined" width="800">
</div>
<div class="title">Figure 3. Frame-Level Pipelined Execution</div>
</div>
<div class="paragraph">
<p>Here, the latency of the graph is still 99ms, but the throughput has been
increased to one frame completing every 33ms, allowing the graph to run
in real-time with the camera frame-rate.</p>
</div>
<div class="paragraph">
<p>Now, in this simple example, a lot of assumptions were made in order to
illustrate the concept. We assumed that each node took the same amount of
time, so pipelining looked like we went from 33% core utilization to 100%
core utilization. In practice, this ideal is almost never true. Processing
times will vary across both kernels and cores. So although pipelining may
bring about increased utilization and throughput, the actual frame rate will
be determined by the execution time of the pipeline stage with the longest
execution time.</p>
</div>
<div class="paragraph">
<p>In order to enable pipelining, the implementation must provide a way for the
application to update the input and output data for future executions of the
graph while previously scheduled graphs are still in the executing state.
Likewise, the implementation must allow scheduling and starting of graph
executions while previously scheduled graphs are still in the executing
state. The <a href="#sec_design_pipelining">Pipelining and Batch Processing</a> section introduces new APIs and gives
code examples for how this extension enables this basic pipelining support.
The <a href="#sec_design_event">Event handling</a> section extends the controllability and timing of
WHEN to exchange frames and schedule new frames using events.</p>
</div>
</div>
<div class="sect3">
<h4 id="sec_batch_processing">1.3.2. Graph Batch Processing</h4>
<div class="paragraph">
<p>Batch processing refers to the ability to execute a graph on a group or
batch of input and output references. Here the user provides a list of input
and output references and a single graph schedule call processes the data
without further intervention of the user application. When a batch of input
and output references is provided to the implementation, it allows the
implementation to potentially parallelize the execution of the graphs on
each input/output reference such that overall higher throughput and
performance is achieved as compared to sequentially executing the graph for
each input/output reference.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgdmlld0JveD0iMCAwIDg4MS45NTUyNiAyMjMuMzAxNzQiCiAgIGhlaWdodD0iNS45MDgxOTE3Y20iCiAgIHdpZHRoPSIyMy4zMzUwNjZjbSIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgaWQ9InN2ZzEwIgogICB2ZXJzaW9uPSIxLjEiPjxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTE2Ij48cmRmOlJERj48Y2M6V29yawogICAgICAgICByZGY6YWJvdXQ9IiI+PGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+PGRjOnR5cGUKICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPjxkYzp0aXRsZT48L2RjOnRpdGxlPjwvY2M6V29yaz48L3JkZjpSREY+PC9tZXRhZGF0YT48ZGVmcwogICAgIGlkPSJkZWZzMTQiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMjYiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDI0IgogICAgICAgICBkPSJNIDAsMS4yMjA3ZS00IEggNzIwIFYgNTQwLjAwMDEyIEggMCBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0NCIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDIiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNjAiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDU4IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDc2IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg3NCIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg4OCIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoODYiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTA2IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgxMDQiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTE4IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgxMTYiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTMwIgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgxMjgiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTQ2IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgxNDQiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTU4IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgxNTYiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTcwIgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgxNjgiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTg2IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgxODQiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTk4IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgxOTYiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMjM4IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgyMzYiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMjc4IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGgyNzYiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMzMzMzMzMywwLDAsLTEuMzMzMzMzMywtOS4zNzIzNjE1LDcxMy43MTQwOCkiCiAgICAgaWQ9ImcxOCI+PHBhdGgKICAgICAgIGlkPSJwYXRoMzQiCiAgICAgICBzdHlsZT0iZmlsbDojYjNiM2IzO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAyNDguOTAyNSwzODMuMDAyNSBoIDE4NC40NCB2IDExMS43MiBoIC0xODQuNDQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgzNiIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDI0OC45MDI1LDM4My4wMDI1IGggMTg0LjQ0IHYgMTExLjcyIGggLTE4NC40NCB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtOC40Mzc1MDAyLDE0LjA2MjUpIgogICAgICAgaWQ9ImczOCI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDQpIgogICAgICAgICBpZD0iZzQwIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NDgiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDMzMi44Myw0NjEuMjEpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQ2IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgOS4zMzYwMDA0IDEzLjMzMiAyMC4wMjggMjYuNzM2Ij5HcmFwaDwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDUwIgogICAgICAgc3R5bGU9ImZpbGw6I2ZmYzVjNTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMjc1LjMwMjUsNDMzLjg4MjUgaCAxMzEuNjQgdiAyOC42OCBoIC0xMzEuNjQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg1MiIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDI3NS4zMDI1LDQzMy44ODI1IGggMTMxLjY0IHYgMjguNjggaCAtMTMxLjY0IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC04LjQzNzUwMDIsMTQuMDYyNSkiCiAgICAgICBpZD0iZzU0Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg2MCkiCiAgICAgICAgIGlkPSJnNTYiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ2NCIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMjkxLjg5LDQyOS43MikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNjIiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCA1Ljg4MDAwMDEgMTEuNzYgMjAuNDI0IDI3LjA5NjAwMSAzMS4wOTE5OTkgMzUuMDQwMDAxIDM3LjcwMzk5OSA0My43MDM5OTkgNTIuMzIgNTkuMDI4IDYzLjAyMzk5OCA2OS42OTU5OTkgNzYuNDE2IDgwLjQxMjAwMyA4Ni40MTIwMDMgOTUuMDE1OTk5IDEwMS43MjQgMTA4LjQzMiI+dnhIYXJyaXNDb3JuZXJzTm9kZTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDY2IgogICAgICAgc3R5bGU9ImZpbGw6I2U2ZTZlNjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMjc1LjMwMjUsMzkzLjA4MjUgaCAxMzEuNjQgdiAyMS4zNiBoIC0xMzEuNjQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg2OCIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDI3NS4zMDI1LDM5My4wODI1IGggMTMxLjY0IHYgMjEuMzYgaCAtMTMxLjY0IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC04LjQzNzUwMDIsMTQuMDYyNSkiCiAgICAgICBpZD0iZzcwIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg3NikiCiAgICAgICAgIGlkPSJnNzIiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ4MCIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMzAwLjE3LDM4NS4yNykiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNzgiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCAzLjQ2Nzk5OTkgNi4xMzIgMTEuOTg4IDE4LjY5NTk5OSAyNS40MDM5OTkgMjguNjQzOTk5IDM1LjM1MjAwMSA0Mi4wNjAwMDEgNDguNzY4MDAyIDU1LjM2OCI+Zml4ZWQgbm9kZSA8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTguNDM3NTAwMiwxNC4wNjI1KSIKICAgICAgIGlkPSJnODIiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDg4KSIKICAgICAgICAgaWQ9Imc4NCI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDkyIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTJweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwzNTguNjEsMzg1LjI3KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW45MCIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDYuNzA4MDAwMiAxMy40MTYgMTcuNDEyMDAxIDI0LjA4NCAzNC4xNjQwMDEiPnBhcmFtczwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDk0IgogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMzQyLjIwMjUsNDE0LjQ3MjUgdiAxMy43MSBoIC0yLjI4IHYgLTEzLjcxIHogbSAyLjI4LDEyLjU3IC0zLjQyLDYuODQgLTMuNDIsLTYuODQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg5NiIKICAgICAgIHN0eWxlPSJmaWxsOiNlNmU2ZTY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDQ1Ny44MjI1LDQ0Ny4wODI1IGggODMuMjggdiAyNCBoIC04My4yOCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDk4IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNDU3LjgyMjUsNDQ3LjA4MjUgaCA4My4yOCB2IDI0IGggLTgzLjI4IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC04LjQzNzUwMDIsMTQuMDYyNSkiCiAgICAgICBpZD0iZzEwMCI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoMTA2KSIKICAgICAgICAgaWQ9ImcxMDIiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQxMTAiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDQ3NS4wMyw0NDAuNTkpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjEwOCIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDYgMTIuNzA4IDE2LjcwNCAyMy4zNzU5OTkgMzAuMDk2MDAxIDM0LjA5MTk5OSA0MC4wOTE5OTkgNDMuMTc1OTk5Ij5jb3JuZXJzICg8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTguNDM3NTAwMiwxNC4wNjI1KSIKICAgICAgIGlkPSJnMTEyIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxMTgpIgogICAgICAgICBpZD0iZzExNCI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDEyMiIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNTIyLjE5LDQ0MC41OSkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuMTIwIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgNi43MDgwMDAyIDEwLjcwNCI+YXJyPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC04LjQzNzUwMDIsMTQuMDYyNSkiCiAgICAgICBpZD0iZzEyNCI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoMTMwKSIKICAgICAgICAgaWQ9ImcxMjYiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQxMzQiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDUzNi44Myw0NDAuNTkpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjEzMiIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIj4pPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoMTM2IgogICAgICAgc3R5bGU9ImZpbGw6I2U2ZTZlNjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMTQxLjE0MjUsNDU2LjQ0MjUgaCA4My4yOCB2IDI0IGggLTgzLjI4IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMTM4IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMTQxLjE0MjUsNDU2LjQ0MjUgaCA4My4yOCB2IDI0IGggLTgzLjI4IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC04LjQzNzUwMDIsMTQuMDYyNSkiCiAgICAgICBpZD0iZzE0MCI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoMTQ2KSIKICAgICAgICAgaWQ9ImcxNDIiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQxNTAiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDE2Mi44OSw0NDkuOTMpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjE0OCIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDIuNjY0IDkuMzM2MDAwNCAxNi4wNjgwMDEgMjIuNzc1OTk5IDI2LjExMiAyOS4yNTYwMDEiPmlucHV0ICg8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTguNDM3NTAwMiwxNC4wNjI1KSIKICAgICAgIGlkPSJnMTUyIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxNTgpIgogICAgICAgICBpZD0iZzE1NCI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDE2MiIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMTk2LjEzLDQ0OS45MykiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuMTYwIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMi42NjQgMTIuNzA4Ij5pbWc8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTguNDM3NTAwMiwxNC4wNjI1KSIKICAgICAgIGlkPSJnMTY0Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxNzApIgogICAgICAgICBpZD0iZzE2NiI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDE3NCIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMjE1LjQ1LDQ0OS45MykiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuMTcyIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPik8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGgxNzYiCiAgICAgICBzdHlsZT0iZmlsbDojZTZlNmU2O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAxNDEuMTQyNSwzOTMuNTYyNSBoIDgzLjI4IHYgMzcuMiBoIC04My4yOCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDE3OCIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDE0MS4xNDI1LDM5My41NjI1IGggODMuMjggdiAzNy4yIGggLTgzLjI4IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC04LjQzNzUwMDIsMTQuMDYyNSkiCiAgICAgICBpZD0iZzE4MCI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoMTg2KSIKICAgICAgICAgaWQ9ImcxODIiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQxOTAiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDE2OS40OSw0MDAuODcpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjE4OCIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDYgOS4zMzYwMDA0IDEzLjMzMiAyMC4wMjggMjYuNzM2IDMzLjMzNTk5OSAzNi42NzIwMDEgNDMuNDAzOTk5Ij5zdHJlbmd0aCA8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTguNDM3NTAwMiwxNC4wNjI1KSIKICAgICAgIGlkPSJnMTkyIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxOTgpIgogICAgICAgICBpZD0iZzE5NCI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDIwMiIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMTcxLjE3LDM4Ni40NykiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuMjAwIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMy45OTYwMDAxIDkuOTk2MDAwMyAxNS45OTYgMjIuNjY3OTk5IDI1LjMzMjAwMSAzMi4wMjggMzYuMDIzOTk4Ij4oc2NhbGFyKTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDIwNCIKICAgICAgIHN0eWxlPSJmaWxsOiNlNmU2ZTY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDU2OS45MDI1LDQ5NC43MjI1IGggODMuNCB2IDEwLjA4IGggLTgzLjQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgyMDYiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA1NjkuOTAyNSw0OTQuNzIyNSBoIDgzLjQgdiAxMC4wOCBoIC04My40IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMjA4IgogICAgICAgc3R5bGU9ImZpbGw6I2U2ZTZlNjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gNTY5LjkwMjUsNDgwLjgwMjUgaCA4My40IHYgMTAuMDggaCAtODMuNCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDIxMCIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDU2OS45MDI1LDQ4MC44MDI1IGggODMuNCB2IDEwLjA4IGggLTgzLjQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgyMTIiCiAgICAgICBzdHlsZT0iZmlsbDojZTZlNmU2O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSA1NjkuOTAyNSw0NjYuODgyNSBoIDgzLjQgdiAxMC4yIGggLTgzLjQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgyMTQiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA1NjkuOTAyNSw0NjYuODgyNSBoIDgzLjQgdiAxMC4yIGggLTgzLjQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgyMTYiCiAgICAgICBzdHlsZT0iZmlsbDojZTZlNmU2O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSA1NjkuOTAyNSw0NTIuODQyNSBoIDgzLjQgdiAxMC4yIGggLTgzLjQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgyMTgiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA1NjkuOTAyNSw0NTIuODQyNSBoIDgzLjQgdiAxMC4yIGggLTgzLjQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgyMjAiCiAgICAgICBzdHlsZT0iZmlsbDojZTZlNmU2O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSA1NjkuOTAyNSw0MzkuMTYyNSBoIDgzLjQgdiAxMC4wOCBoIC04My40IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMjIyIgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNTY5LjkwMjUsNDM5LjE2MjUgaCA4My40IHYgMTAuMDggaCAtODMuNCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDIyNCIKICAgICAgIHN0eWxlPSJmaWxsOiNlNmU2ZTY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDU2OS45MDI1LDQyNS4xMjI1IGggODMuNCB2IDEwLjA4IGggLTgzLjQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgyMjYiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA1NjkuOTAyNSw0MjUuMTIyNSBoIDgzLjQgdiAxMC4wOCBoIC04My40IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMjI4IgogICAgICAgc3R5bGU9ImZpbGw6I2U2ZTZlNjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gNTY5LjkwMjUsNDExLjMyMjUgaCA4My40IHYgMTAuMDggaCAtODMuNCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDIzMCIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDU2OS45MDI1LDQxMS4zMjI1IGggODMuNCB2IDEwLjA4IGggLTgzLjQgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTguNDM3NTAwMiwxNC4wNjI1KSIKICAgICAgIGlkPSJnMjMyIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgyMzgpIgogICAgICAgICBpZD0iZzIzNCI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDI0MiIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNTg2Ljk3LDQ5OC40NikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuMjQwIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgNi43MDgwMDAyIDEzLjQxNiAxNi43NTIwMDEgMjMuNDgzOTk5IDMwLjE5MTk5OSAzMy41MjggMzYuNTUxOTk4IDQzLjI1OTk5OCA0OS45Njc5OTkgNTMuMzA0MDAxIDU5LjMwNDAwMSI+b3V0cHV0IGJhdGNoPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoMjQ0IgogICAgICAgc3R5bGU9ImZpbGw6I2U2ZTZlNjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMjIuMjIyNSw0OTQuNzIyNSBoIDgzLjI4IHYgMTAuMDggaCAtODMuMjggeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgyNDYiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAyMi4yMjI1LDQ5NC43MjI1IGggODMuMjggdiAxMC4wOCBoIC04My4yOCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDI0OCIKICAgICAgIHN0eWxlPSJmaWxsOiNlNmU2ZTY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDIyLjIyMjUsNDgwLjgwMjUgaCA4My4yOCB2IDEwLjA4IGggLTgzLjI4IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMjUwIgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMjIuMjIyNSw0ODAuODAyNSBoIDgzLjI4IHYgMTAuMDggaCAtODMuMjggeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgyNTIiCiAgICAgICBzdHlsZT0iZmlsbDojZTZlNmU2O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAyMi4yMjI1LDQ2Ni44ODI1IGggODMuMjggdiAxMC4yIGggLTgzLjI4IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMjU0IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMjIuMjIyNSw0NjYuODgyNSBoIDgzLjI4IHYgMTAuMiBoIC04My4yOCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDI1NiIKICAgICAgIHN0eWxlPSJmaWxsOiNlNmU2ZTY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDIyLjIyMjUsNDUyLjg0MjUgaCA4My4yOCB2IDEwLjIgaCAtODMuMjggeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgyNTgiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAyMi4yMjI1LDQ1Mi44NDI1IGggODMuMjggdiAxMC4yIGggLTgzLjI4IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMjYwIgogICAgICAgc3R5bGU9ImZpbGw6I2U2ZTZlNjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMjIuMjIyNSw0MzkuMTYyNSBoIDgzLjI4IHYgMTAuMDggaCAtODMuMjggeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgyNjIiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAyMi4yMjI1LDQzOS4xNjI1IGggODMuMjggdiAxMC4wOCBoIC04My4yOCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDI2NCIKICAgICAgIHN0eWxlPSJmaWxsOiNlNmU2ZTY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDIyLjIyMjUsNDI1LjEyMjUgaCA4My4yOCB2IDEwLjA4IGggLTgzLjI4IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMjY2IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMjIuMjIyNSw0MjUuMTIyNSBoIDgzLjI4IHYgMTAuMDggaCAtODMuMjggeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgyNjgiCiAgICAgICBzdHlsZT0iZmlsbDojZTZlNmU2O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAyMi4yMjI1LDQxMS4zMjI1IGggODMuMjggdiAxMC4wOCBoIC04My4yOCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDI3MCIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDIyLjIyMjUsNDExLjMyMjUgaCA4My4yOCB2IDEwLjA4IGggLTgzLjI4IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC04LjQzNzUwMDIsMTQuMDYyNSkiCiAgICAgICBpZD0iZzI3MiI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoMjc4KSIKICAgICAgICAgaWQ9ImcyNzQiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQyODIiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDQyLjg2NCw0OTguNDYpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjI4MCIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDIuNjY0IDkuMzM2MDAwNCAxNi4wNjgwMDEgMjIuNzc1OTk5IDI2LjExMiAyOS4yNTYwMDEgMzUuOTY0MDAxIDQyLjY3MjAwMSA0Ni4wMDc5OTkgNTIuMDA3OTk5Ij5pbnB1dCBiYXRjaDwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDI4NCIKICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDIyNC40MjI1LDQ2OS41ODI1IGggMTguNjkgdiAtMi4yOCBoIC0xOC42OSB6IG0gMTcuNTUsMi4yOCA2Ljg0LC0zLjQyIC02Ljg0LC0zLjQyIHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMjg2IgogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMjI0LjQyMjUsNDEzLjMwMjUgaCAxOC42OSB2IC0yLjI4IGggLTE4LjY5IHogbSAxNy41NSwyLjI4IDYuODQsLTMuNDIgLTYuODQsLTMuNDIgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGgyODgiCiAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgZD0ibSA0MzMuMzQyNSw0NjAuMjIyNSBoIDE4LjY5IHYgLTIuMjggaCAtMTguNjkgeiBtIDE3LjU1LDIuMjggNi44NCwtMy40MiAtNi44NCwtMy40MiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDI5MCIKICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDU0MS4xMDI1LDQ2MC4yMjI1IGggMTguNjkgdiAtMi4yOCBoIC0xOC42OSB6IG0gMTcuNTUsMi4yOCA2Ljg0LC0zLjQyIC02Ljg0LC0zLjQyIHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoMjkyIgogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMTA5Ljk0MjUsNDY5LjU4MjUgaCAyNS40MSB2IC0yLjI4IGggLTI1LjQxIHogbSAyNC4yNywyLjI4IDYuODQsLTMuNDIgLTYuODQsLTMuNDIgeiIgLz48L2c+PC9zdmc+" alt="Fig4 Batch processing" width="800">
</div>
<div class="title">Figure 4. Graph Batch Processing</div>
</div>
<div class="paragraph">
<p>The <a href="#sec_design_pipelining">Pipelining and Batch Processing</a> section introduces new APIs and gives code
examples for how this extension enables batch processing support.</p>
</div>
</div>
<div class="sect3">
<h4 id="sec_streaming">1.3.3. Graph Streaming</h4>
<div class="paragraph">
<p>Graph streaming refers to the ability of the OpenVX implementation to
automatically handle graph input and output updates and
re-schedule each frame without intervention from the application.
The concept of graph streaming is orthogonal to graph pipelining.
Pipelining can be enabled or disabled on a graph which has streaming
enabled or disabled, and vice-versa.</p>
</div>
<div class="paragraph">
<p>In order to enable graph streaming, the implementation must provide a way
for the application to enter and exit this streaming mode.  Additionally,
the implementation must somehow manage the input and output swapping
with upstream and downstream components outside of the OpenVX implementation.
This can be handled with the concept of SOURCE nodes and SINK nodes.</p>
</div>
<div class="paragraph">
<p>A SOURCE node is a node which coordinates the supply of input
into the graph from upstream components (such as a camera), and the SINK
node is a node which coordinates the handoff of output from the graph
into downstream components (such as a display).</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgdmlld0JveD0iMCAwIDc4Ni40MzUyMSAyMjQuMjk4MTUiCiAgIGhlaWdodD0iNS45MzQ1NTUxY20iCiAgIHdpZHRoPSIyMC44MDc3NjZjbSIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgaWQ9InN2ZzQ0OTUiCiAgIHZlcnNpb249IjEuMSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNDUwMSI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48ZGM6dGl0bGU+PC9kYzp0aXRsZT48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczQ0OTkiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDUxMSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDUwOSIKICAgICAgICAgZD0iTSAwLDEuMjIwN2UtNCBIIDcyMCBWIDU0MC4wMDAxMiBIIDAgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDUyOSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDUyNyIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0NTQ1IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0NTQzIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQ1NjEiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQ1NTkiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDU3NSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDU3MyIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0NTg5IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0NTg3IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQ2MDMiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQ2MDEiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDYxNyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDYxNSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0NjI5IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0NjI3IgogICAgICAgICBkPSJNIC0xLjk4MWUtNiw1NDAgSCA3MjAgViAwIEggLTIuMTY2NmUtNSIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDYzOSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDYzNyIKICAgICAgICAgZD0iTSA0LjU5M2UtNiw1NDAgSCA3MjAgViAxLjIyMDdlLTQgSCAtMS41MDkyZS01IiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0NjQ5IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0NjQ3IgogICAgICAgICBkPSJNIC03LjAyN2UtNiw1NDAgSCA3MjAgViAwIEggLTIuNjcxMmUtNSIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDY1OSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDY1NyIKICAgICAgICAgZD0iTSAtNS44MTZlLTYsNTQwIEggNzIwIFYgMS4yMjA3ZS00IEggLTQuNTE4NmUtNSIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDY2OSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDY2NyIKICAgICAgICAgZD0iTSAtOC4wMDZlLTYsNTQwIEggNzIwIFYgMCBMIC00LjczNzZlLTUsNi4xMDM1ZS01IiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0Njc5IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0Njc3IgogICAgICAgICBkPSJNIC01LjY2N2UtNiw1NDAgSCA3MjAgViAxLjIyMDdlLTQgSCAtNC41MDM3ZS01IiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0Njg5IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0Njg3IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQ3MDUiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQ3MDMiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDcxNyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDcxNSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0NzI5IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0NzI3IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQ3NDEiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQ3MzkiCiAgICAgICAgIGQ9Ik0gMS40NzllLTYsNTQwIEggNzIwIFYgMS4yMjA3ZS00IEggLTguMzY0ZS02IiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0NzU1IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0NzUzIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQ3NjciCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQ3NjUiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMzMzMzMzMywwLDAsLTEuMzMzMzMzMywtNy40MTI4NjgyLDcxNS44NDk0OSkiCiAgICAgaWQ9Imc0NTAzIj48cGF0aAogICAgICAgaWQ9InBhdGg0NTE5IgogICAgICAgc3R5bGU9ImZpbGw6I2U2ZTZlNjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMTMzLjc5Mjg4LDQ3NC4wNTM5IGggOTEuNDQgdiA0Ny42NCBoIC05MS40NCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQ1MjEiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAxMzMuNzkyODgsNDc0LjA1MzkgaCA5MS40NCB2IDQ3LjY0IGggLTkxLjQ0IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01Mi42MjcxMiwxNjcuMDMzOSkiCiAgICAgICBpZD0iZzQ1MjMiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ1MjkpIgogICAgICAgICBpZD0iZzQ1MjUiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0NTMzIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwyMDMuMDksMzI0LjE0KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40NTMxIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTIuOTk2IDIyLjkxNCAzMi45MjIwMDEgNDIuODQgNDcuOTg3OTk5Ij5Ob2RlIDA8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg0NTM1IgogICAgICAgc3R5bGU9ImZpbGw6I2IzYjNiMztmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMjUxLjM5Mjg4LDQ3NC4wNTM5IGggOTEuMzIgdiA0Ny42NCBoIC05MS4zMiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQ1MzciCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAyNTEuMzkyODgsNDc0LjA1MzkgaCA5MS4zMiB2IDQ3LjY0IGggLTkxLjMyIHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01Mi42MjcxMiwxNjcuMDMzOSkiCiAgICAgICBpZD0iZzQ1MzkiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ1NDUpIgogICAgICAgICBpZD0iZzQ1NDEiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0NTQ5IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwzMjAuNjQsMzI0LjE0KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40NTQ3IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTIuOTk2IDIyLjkxNCAzMi45MjIwMDEgNDIuODQgNDcuOTg3OTk5Ij5Ob2RlIDE8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg0NTUxIgogICAgICAgc3R5bGU9ImZpbGw6I2ZmYzVjNTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMzYzLjIzMjg4LDQ3NC4wNTM5IGggOTEuMzIgdiA0Ny42NCBoIC05MS4zMiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQ1NTMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAzNjMuMjMyODgsNDc0LjA1MzkgaCA5MS4zMiB2IDQ3LjY0IGggLTkxLjMyIHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01Mi42MjcxMiwxNjcuMDMzOSkiCiAgICAgICBpZD0iZzQ1NTUiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ1NjEpIgogICAgICAgICBpZD0iZzQ1NTciPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0NTY1IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw0MzIuNTMsMzI0LjE0KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40NTYzIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMTIuOTk2IDIyLjkxNCAzMi45MjIwMDEgNDIuODQgNDcuOTg3OTk5Ij5Ob2RlIDI8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg0NTY3IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gODguNTUyODc2LDQyNy4xMzM5IGggNTkuODgwMDA0IHYgMjguMzIgSCA4OC41NTI4NzYgWiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTUyLjYyNzEyLDE2Ny4wMzM5KSIKICAgICAgIGlkPSJnNDU2OSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDU3NSkiCiAgICAgICAgIGlkPSJnNDU3MSI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQ1NzkiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxNS45NjAwMDAwNHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDE0OC44MiwyNjguMjcpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQ1NzciCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCA0LjQzNjg4MDEgMTcuNzMxNTYgMjYuNjA1MzIgMzUuNDc5MDgiPkltYWdlPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNDU4MSIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDIwOC4zMTI4OCw0MjcuMTMzOSBoIDU5Ljc2IHYgMjguMzIgaCAtNTkuNzYgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTUyLjYyNzEyLDE2Ny4wMzM5KSIKICAgICAgIGlkPSJnNDU4MyI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDU4OSkiCiAgICAgICAgIGlkPSJnNDU4NSI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQ1OTMiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxNS45NjAwMDAwNHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDI2OC41NiwyNjguMjcpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQ1OTEiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCA0LjQzNjg4MDEgMTcuNzMxNTYgMjYuNjA1MzIgMzUuNDc5MDgiPkltYWdlPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNDU5NSIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDMxNy41MTI4OCw0MjcuMTMzOSBoIDU5Ljc2IHYgMjguMzIgaCAtNTkuNzYgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTUyLjYyNzEyLDE2Ny4wMzM5KSIKICAgICAgIGlkPSJnNDU5NyI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDYwMykiCiAgICAgICAgIGlkPSJnNDU5OSI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQ2MDciCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxNS45NjAwMDAwNHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDM4MSwyNjguMjcpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQ2MDUiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCAxMC42NDUzMiAxNS45NiAyMS4yNzQ2NzkgMzAuMTQ4NDM5Ij5BcnJheTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDQ2MDkiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA0MDQuOTkyODgsNDI3LjczMzkgaCA1OS43NiB2IDI4LjQ0IGggLTU5Ljc2IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01Mi42MjcxMiwxNjcuMDMzOSkiCiAgICAgICBpZD0iZzQ2MTEiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ2MTcpIgogICAgICAgICBpZD0iZzQ2MTMiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0NjIxIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTUuOTYwMDAwMDRweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw0NjUuMjYsMjY4LjkpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQ2MTkiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCA0LjQzNjg4MDEgMTcuNzMxNTYgMjYuNjA1MzIgMzUuNDc5MDgiPkltYWdlPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01Mi42MjcxMiwxNjcuMDMzOSkiCiAgICAgICBpZD0iZzQ2MjMiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ2MjkpIgogICAgICAgICBpZD0iZzQ2MjUiPjxwYXRoCiAgICAgICAgICAgaWQ9InBhdGg0NjMxIgogICAgICAgICAgIHN0eWxlPSJmaWxsOiNkZTAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgZD0ibSAxNzAuNSwyODguNTcgdiA0Mi4zOSBjIDAsMC4yOCAwLjIyLDAuNSAwLjUsMC41IGggMTQuMzIgdiAtMSBIIDE3MSBsIDAuNSwwLjUgdiAtNDIuMzkgeiBtIDkuMDcsNDYuMzIgNi43NCwtMy45MyAtNi43NCwtMy45MyBjIC0wLjIzLC0wLjE0IC0wLjU0LC0wLjA2IC0wLjY4LDAuMTggLTAuMTQsMC4yNCAtMC4wNiwwLjU0IDAuMTgsMC42OCBsIDYsMy41IHYgLTAuODYgbCAtNiwzLjUgYyAtMC4yNCwwLjE0IC0wLjMyLDAuNDQgLTAuMTgsMC42OCAwLjE0LDAuMjQgMC40NSwwLjMyIDAuNjgsMC4xOCB6IiAvPjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01Mi42MjcxMiwxNjcuMDMzOSkiCiAgICAgICBpZD0iZzQ2MzMiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ2MzkpIgogICAgICAgICBpZD0iZzQ2MzUiPjxwYXRoCiAgICAgICAgICAgaWQ9InBhdGg0NjQxIgogICAgICAgICAgIHN0eWxlPSJmaWxsOiNkZTAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgZD0ibSAyMzEuNTgsMzA3LjA4IHYgLTMyLjczIGMgMCwtMC4yNyAwLjIyLC0wLjUgMC41LC0wLjUgaCAyNy44NCB2IDEgaCAtMjcuODQgbCAwLjUsLTAuNSB2IDMyLjczIHogbSAyMi41OSwtMzYuNjYgNi43NCwzLjkzIC02Ljc0LDMuOTMgYyAtMC4yNCwwLjE0IC0wLjU0LDAuMDYgLTAuNjgsLTAuMTggLTAuMTQsLTAuMjMgLTAuMDYsLTAuNTQgMC4xOCwtMC42OCBsIDYsLTMuNSB2IDAuODYgbCAtNiwtMy41IGMgLTAuMjQsLTAuMTMgLTAuMzIsLTAuNDQgLTAuMTgsLTAuNjggMC4xNCwtMC4yNCAwLjQ0LC0wLjMyIDAuNjgsLTAuMTggeiIgLz48L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNTIuNjI3MTIsMTY3LjAzMzkpIgogICAgICAgaWQ9Imc0NjQzIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg0NjQ5KSIKICAgICAgICAgaWQ9Imc0NjQ1Ij48cGF0aAogICAgICAgICAgIGlkPSJwYXRoNDY1MSIKICAgICAgICAgICBzdHlsZT0iZmlsbDojZGUwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGQ9Im0gMjkwLjI2LDI4OC41NyB2IDQyLjM5IGMgMCwwLjI4IDAuMjIsMC41IDAuNSwwLjUgaCAxMi4xNCB2IC0xIGggLTEyLjE0IGwgMC41LDAuNSB2IC00Mi4zOSB6IG0gNi44OSw0Ni4zMiA2Ljc0LC0zLjkzIC02Ljc0LC0zLjkzIGMgLTAuMjQsLTAuMTQgLTAuNTQsLTAuMDYgLTAuNjgsMC4xOCAtMC4xNCwwLjI0IC0wLjA2LDAuNTQgMC4xOCwwLjY4IGwgNiwzLjUgdiAtMC44NiBsIC02LDMuNSBjIC0wLjI0LDAuMTQgLTAuMzIsMC40NCAtMC4xOCwwLjY4IDAuMTQsMC4yNCAwLjQ0LDAuMzIgMC42OCwwLjE4IHoiIC8+PC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTUyLjYyNzEyLDE2Ny4wMzM5KSIKICAgICAgIGlkPSJnNDY1MyI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDY1OSkiCiAgICAgICAgIGlkPSJnNDY1NSI+PHBhdGgKICAgICAgICAgICBpZD0icGF0aDQ2NjEiCiAgICAgICAgICAgc3R5bGU9ImZpbGw6I2RlMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICBkPSJtIDM0OS4wNiwzMDcuMDggdiAtMzIuNzMgYyAwLC0wLjI3IDAuMjIsLTAuNSAwLjUsLTAuNSBoIDE5LjQ2IHYgMSBoIC0xOS40NiBsIDAuNSwtMC41IHYgMzIuNzMgeiBtIDE0LjIyLC0zNi42NiA2Ljc0LDMuOTMgLTYuNzQsMy45MyBjIC0wLjI0LDAuMTQgLTAuNTUsMC4wNiAtMC42OSwtMC4xOCAtMC4xNCwtMC4yMyAtMC4wNiwtMC41NCAwLjE4LC0wLjY4IGwgNiwtMy41IHYgMC44NiBsIC02LC0zLjUgYyAtMC4yNCwtMC4xMyAtMC4zMiwtMC40NCAtMC4xOCwtMC42OCAwLjE0LC0wLjI0IDAuNDUsLTAuMzIgMC42OSwtMC4xOCB6IiAvPjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01Mi42MjcxMiwxNjcuMDMzOSkiCiAgICAgICBpZD0iZzQ2NjMiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ2NjkpIgogICAgICAgICBpZD0iZzQ2NjUiPjxwYXRoCiAgICAgICAgICAgaWQ9InBhdGg0NjcxIgogICAgICAgICAgIHN0eWxlPSJmaWxsOiNkZTAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgZD0ibSAzOTkuNDYsMjg4LjU3IHYgNDIuMzkgYyAwLDAuMjggMC4yMiwwLjUgMC41LDAuNSBoIDE0LjgzIHYgLTEgaCAtMTQuODMgbCAwLjUsMC41IHYgLTQyLjM5IHogbSA5LjU4LDQ2LjMyIDYuNzQsLTMuOTMgLTYuNzQsLTMuOTMgYyAtMC4yNCwtMC4xNCAtMC41NCwtMC4wNiAtMC42OCwwLjE4IC0wLjE0LDAuMjQgLTAuMDYsMC41NCAwLjE4LDAuNjggbCA2LDMuNSB2IC0wLjg2IGwgLTYsMy41IGMgLTAuMjQsMC4xNCAtMC4zMiwwLjQ0IC0wLjE4LDAuNjggMC4xNCwwLjI0IDAuNDQsMC4zMiAwLjY4LDAuMTggeiIgLz48L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNTIuNjI3MTIsMTY3LjAzMzkpIgogICAgICAgaWQ9Imc0NjczIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg0Njc5KSIKICAgICAgICAgaWQ9Imc0Njc1Ij48cGF0aAogICAgICAgICAgIGlkPSJwYXRoNDY4MSIKICAgICAgICAgICBzdHlsZT0iZmlsbDojZGUwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIGQ9Im0gNDYxLjAyLDMwNy4wOCB2IC04Ljk2IGMgMCwtMC4yOCAwLjIyLC0wLjUgMC41LC0wLjUgaCAyNS45OSBsIC0wLjUsMC41IHYgLTcuOTcgaCAxIHYgNy45NyBjIDAsMC4yOCAtMC4yMywwLjUgLTAuNSwwLjUgaCAtMjUuOTkgbCAwLjUsLTAuNSB2IDguOTYgeiBtIDIyLjU1LC0xMS4xOCAzLjk0LC02Ljc0IDMuOTMsNi43NCBjIDAuMTQsMC4yMyAwLjA2LDAuNTQgLTAuMTgsMC42OCAtMC4yNCwwLjE0IC0wLjU1LDAuMDYgLTAuNjksLTAuMTggbCAtMy41LC02IGggMC44NyBsIC0zLjUsNiBjIC0wLjE0LDAuMjQgLTAuNDUsMC4zMiAtMC42OSwwLjE4IC0wLjIzLC0wLjE0IC0wLjMxLC0wLjQ1IC0wLjE4LC0wLjY4IHoiIC8+PC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTUyLjYyNzEyLDE2Ny4wMzM5KSIKICAgICAgIGlkPSJnNDY4MyI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDY4OSkiCiAgICAgICAgIGlkPSJnNDY4NSI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQ2OTMiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDI3Ni4xLDIxOS4zOCkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDY5MSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDE0LjAwNCAyNC4wMTE5OTkgMzMuOTY2IDQzLjk3Mzk5OSA1NS45MjU5OTkgNjcuODA2IDcyLjk1NDAwMiA4Ni45NTggOTIuOTUyMDAzIDEwMi45NiAxMTIuOTE0Ij5PcGVuVlggR3JhcGg8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg0Njk1IgogICAgICAgc3R5bGU9ImZpbGw6I2ZmYzVjNTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMjAuNzUyODgsNDc0LjA1MzkgaCA4MC4xNiB2IDQ3LjY0IGggLTgwLjE2IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNDY5NyIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDIwLjc1Mjg4LDQ3NC4wNTM5IGggODAuMTYgdiA0Ny42NCBoIC04MC4xNiB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNTIuNjI3MTIsMTY3LjAzMzkpIgogICAgICAgaWQ9Imc0Njk5Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg0NzA1KSIKICAgICAgICAgaWQ9Imc0NzAxIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NDcwOSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsOTQuMzQ0LDM0MC44MikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDcwNyIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDguMDI3OTk5OSAxNC43MzYgMjEuNDQ0IDI1LjQ0MDAwMSAzMS40NDAwMDEgMzguMTEyIj5Tb3VyY2UgPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01Mi42MjcxMiwxNjcuMDMzOSkiCiAgICAgICBpZD0iZzQ3MTEiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ3MTcpIgogICAgICAgICBpZD0iZzQ3MTMiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0NzIxIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTJweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw5OS4wMjQsMzI2LjQyKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40NzE5IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgOC42NjM5OTk2IDE1LjMzNiAyMi4wNjgwMDEiPk5vZGU8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTUyLjYyNzEyLDE2Ny4wMzM5KSIKICAgICAgIGlkPSJnNDcyMyI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDcyOSkiCiAgICAgICAgIGlkPSJnNDcyNSI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQ3MzMiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDg5LjMwNCwzMTIuMDIpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQ3MzEiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCAzLjk5NjAwMDEgOS45OTYwMDAzIDE2LjY2Nzk5OSAyNi43NDc5OTkgMzMuNDU2MDAxIDM3LjQ1MiA0NC4xMjQwMDEiPihjYW1lcmEpPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01Mi42MjcxMiwxNjcuMDMzOSkiCiAgICAgICBpZD0iZzQ3MzUiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ3NDEpIgogICAgICAgICBpZD0iZzQ3MzciPjxwYXRoCiAgICAgICAgICAgaWQ9InBhdGg0NzQzIgogICAgICAgICAgIHN0eWxlPSJmaWxsOiNkZTAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgZD0ibSAxMTIuOSwzMDcuMDggdiAtMzIuNzMgYyAwLC0wLjI3IDAuMjIsLTAuNSAwLjUsLTAuNSBoIDI2Ljc5IHYgMSBIIDExMy40IGwgMC41LC0wLjUgdiAzMi43MyB6IG0gMjEuNTUsLTM2LjY2IDYuNzQsMy45MyAtNi43NCwzLjkzIGMgLTAuMjQsMC4xNCAtMC41NSwwLjA2IC0wLjY5LC0wLjE4IC0wLjE0LC0wLjIzIC0wLjA2LC0wLjU0IDAuMTgsLTAuNjggbCA2LC0zLjUgdiAwLjg2IGwgLTYsLTMuNSBjIC0wLjI0LC0wLjEzIC0wLjMyLC0wLjQ0IC0wLjE4LC0wLjY4IDAuMTQsLTAuMjQgMC40NSwtMC4zMiAwLjY5LC0wLjE4IHoiIC8+PC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg0NzQ1IgogICAgICAgc3R5bGU9ImZpbGw6I2ZmYzVjNTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gNTAwLjAzMjg4LDQ3NC4wNTM5IGggODAuMTYgdiA0Ny42NCBoIC04MC4xNiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDQ3NDciCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA1MDAuMDMyODgsNDc0LjA1MzkgaCA4MC4xNiB2IDQ3LjY0IGggLTgwLjE2IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01Mi42MjcxMiwxNjcuMDMzOSkiCiAgICAgICBpZD0iZzQ3NDkiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ3NTUpIgogICAgICAgICBpZD0iZzQ3NTEiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0NzU5IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTJweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw1NjUuMDgsMzMzLjYyKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40NzU3IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgOC4wMjc5OTk5IDEwLjY5MiAxNy4zNjQgMjMuMzY0IDI2LjYyOCAzNS4yOTIgNDEuOTY0MDAxIDQ4LjY5NTk5OSI+U2luayBOb2RlPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01Mi42MjcxMiwxNjcuMDMzOSkiCiAgICAgICBpZD0iZzQ3NjEiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ3NjcpIgogICAgICAgICBpZD0iZzQ3NjMiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0NzcxIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTJweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw1NzAuMTIsMzE5LjIyKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40NzY5IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgMy45OTYwMDAxIDEwLjY2OCAxMy4zMzIgMTkuMzMyMDAxIDI2LjAyOCAyOC42OTE5OTkgMzUuMzYzOTk4IDQxLjI2ODAwMiI+KGRpc3BsYXkpPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNDc3MyIKICAgICAgIHN0eWxlPSJmaWxsOiNkZTAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDQ2NC42OTI4OCw0NDEuNTQzOSBoIDE3LjYzIGMgMC4yOCwwIDAuNSwwLjIzIDAuNSwwLjUgdiA1NS45NSBsIC0wLjUsLTAuNSBoIDE2LjY1IHYgMSBoIC0xNi42NSBjIC0wLjI3LDAgLTAuNSwtMC4yMiAtMC41LC0wLjUgdiAtNTUuOTUgbCAwLjUsMC41IGggLTE3LjYzIHogbSAyOC41Myw1Mi41MiA2Ljc0LDMuOTMgLTYuNzQsMy45MyBjIC0wLjI0LDAuMTQgLTAuNTUsMC4wNiAtMC42OCwtMC4xOCAtMC4xNCwtMC4yNCAtMC4wNiwtMC41NCAwLjE4LC0wLjY4IGwgNiwtMy41IHYgMC44NiBsIC02LC0zLjUgYyAtMC4yNCwtMC4xNCAtMC4zMiwtMC40NCAtMC4xOCwtMC42OCAwLjEzLC0wLjI0IDAuNDQsLTAuMzIgMC42OCwtMC4xOCB6IiAvPjwvZz48L3N2Zz4=" alt="Fig5 Source sink" width="800">
</div>
<div class="title">Figure 5. Source/Sink Nodes added for Graph Streaming</div>
</div>
<div class="paragraph">
<p>The <a href="#sec_design_streaming">Streaming</a> section introduces new APIs and gives code
examples for how this extension enables this basic streaming support.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="page_design">2. Design Overview</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="data_references">2.1. Data reference</h3>
<div class="paragraph">
<p>In this extension, the term <em>data reference</em> is used frequently. In this
section we define this term.</p>
</div>
<div class="paragraph">
<p>Data references are OpenVX references to any of the OpenVX data types listed
below,</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VX_TYPE_LUT</code></p>
</li>
<li>
<p><code>VX_TYPE_DISTRIBUTION</code></p>
</li>
<li>
<p><code>VX_TYPE_PYRAMID</code></p>
</li>
<li>
<p><code>VX_TYPE_THRESHOLD</code></p>
</li>
<li>
<p><code>VX_TYPE_MATRIX</code></p>
</li>
<li>
<p><code>VX_TYPE_CONVOLUTION</code></p>
</li>
<li>
<p><code>VX_TYPE_SCALAR</code></p>
</li>
<li>
<p><code>VX_TYPE_ARRAY</code></p>
</li>
<li>
<p><code>VX_TYPE_IMAGE</code></p>
</li>
<li>
<p><code>VX_TYPE_REMAP</code></p>
</li>
<li>
<p><code>VX_TYPE_OBJECT_ARRAY</code></p>
</li>
<li>
<p><code>VX_TYPE_TENSOR</code> (OpenVX 1.2 and above)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The APIs which operate on data references take as input a <code>vx_reference</code>
type. An application can pass any of the above defined data type references
to such an API.</p>
</div>
</div>
<div class="sect2">
<h3 id="sec_design_pipelining">2.2. Pipelining and Batch Processing</h3>
<div class="paragraph">
<p>Pipelining and Batch Processing APIs allow an application to construct a
graph which can be executed in a pipelined fashion (see <a href="#sec_pipelining">Graph Pipelining</a>),
or batch processing fashion (see <a href="#sec_batch_processing">Graph Batch Processing</a>).</p>
</div>
<div class="sect3">
<h4 id="sec_design_queue">2.2.1. Graph Parameter Queues</h4>
<div class="paragraph">
<p>The concept of OpenVX &#8220;Graph Parameters&#8221; is defined in the main OpenVX
spec as a means to expose external ports of a graph. Graph parameters enable
the abstraction of the remaining graph ports which are not connected as
graph parameters. Since graph pipelining and batching is concerned primarily
with controlling the flow of data to and from the graph, OpenVX graph
parameters provide a useful construct for enabling pipelining and batching.</p>
</div>
<div class="paragraph">
<p>This extension introduces the concept of <em>graph parameter queueing</em> to
enable assigning multiple data objects to a graph parameter (either at once,
or spaced in time) without needing to wait for the previous graph
completion(s). At runtime, the application can utilize the
<code><a href="#vxGraphParameterEnqueueReadyRef">vxGraphParameterEnqueueReadyRef</a></code> function to enqueue a number of data
references into a graph parameter to be used by the graph. Likewise, the
application can use the <code><a href="#vxGraphParameterDequeueDoneRef">vxGraphParameterDequeueDoneRef</a></code> function to
dequeue a number of data references from a graph parameter after the graph
is done using them (thus, making them available for the application). The
<code><a href="#vxGraphParameterCheckDoneRef">vxGraphParameterCheckDoneRef</a></code> function is a non-blocking call that can
be used to determine if there are references available for dequeuing, and if
so, how many.</p>
</div>
<div class="paragraph">
<p>In order for the implementation to know which graph parameters it needs to
support queuing on, the application should configure this by calling
<code><a href="#vxSetGraphScheduleConfig">vxSetGraphScheduleConfig</a></code> before calling <code>vxVerifyGraph</code> or
<code>vxScheduleGraph</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="sec_graph_schedule_config">2.2.2. Graph Schedule Configuration</h4>
<div class="paragraph">
<p>The graph schedule configuration function (<code><a href="#vxSetGraphScheduleConfig">vxSetGraphScheduleConfig</a></code>)
allows users to enable enqueuing of multiple input and output references to
a graph parameter. It also allows users to control how the graph gets
scheduled based on the references enqueued by the user.</p>
</div>
<div class="paragraph">
<p>The <em>graph_schedule_mode</em> parameter defines two modes of graph scheduling:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code><a href="#VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL">VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</a></code></p>
<div class="ulist">
<ul>
<li>
<p>Here the application enqueues the references to be processed at a graph
parameter</p>
</li>
<li>
<p>Later when application calls <code>vxScheduleGraph</code>, all the previously
enqueued references get processed.</p>
</li>
<li>
<p>Enqueuing multiple references and calling a single
<code>vxScheduleGraph</code> allows implementation flexibility to optimize the
execution of the multiple graph executions based on the number of the
enqueued references.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code><a href="#VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO">VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</a></code></p>
<div class="ulist">
<ul>
<li>
<p>Here also, the user enqueues the references that they want to process
at a graph parameter</p>
</li>
<li>
<p>However here user does not explicitly call <code>vxScheduleGraph</code></p>
</li>
<li>
<p><code>vxVerifyGraph</code> <em>must</em> be called in this mode (since
<code>vxScheduleGraph</code> is not called).</p>
</li>
<li>
<p>The implementation automatically triggers graph execution when it has
enough enqueued references to start a graph execution</p>
</li>
<li>
<p>Enqueuing multiple references without calling <code>vxScheduleGraph</code>
allows the implementation to start a graph execution as soon as minimal
input or output references are available.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>In both of these modes, <code>vxProcessGraph</code> is not allowed. The next two
sections show how the graph schedule configuration, along with reference
enqueue and dequeue is used to realize the graph pipelining and batch
processing use-cases.</p>
</div>
</div>
<div class="sect3">
<h4 id="sec_queue">2.2.3. Example Graph pipelining application</h4>
<div class="paragraph">
<p>Graph pipelining allow users to schedule a graph multiple times, without
having to wait for a graph execution to complete. Each such execution of the
graph operates on different input or output references.</p>
</div>
<div class="paragraph">
<p>In a typical pipeline execution model, there is a pipe-up phase where new
inputs are enqueued and graph is scheduled multiple times until the pipeline
is full. Once the pipeline is full, then outputs begin to be filled as often
as inputs are enqueued (as shown in <a href="#fig-pipelined-exec">Frame-Level Pipelined Execution</a>).</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgdmlld0JveD0iMCAwIDcyNy4xMjIzNSAyNzMuMjg4ODUiCiAgIGhlaWdodD0iNy4yMzA3NjczY20iCiAgIHdpZHRoPSIxOS4yMzg0NDVjbSIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgaWQ9InN2ZzQ3NzUiCiAgIHZlcnNpb249IjEuMSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNDc4MSI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48ZGM6dGl0bGU+PC9kYzp0aXRsZT48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczQ3NzkiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDc5MSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDc4OSIKICAgICAgICAgZD0iTSAwLDEuMjIwN2UtNCBIIDcyMCBWIDU0MC4wMDAxMiBIIDAgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDgwOSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDgwNyIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0ODI1IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0ODIzIgogICAgICAgICBkPSJNIC0xLjg1N2UtNiw1NDAgSCA3MjAgViAwIEggLTEuMTdlLTUiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQ4MzUiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQ4MzMiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDg0NyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDg0NSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0ODU5IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0ODU3IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQ4NzEiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQ4NjkiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDg4MyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDg4MSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0ODk1IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0ODkzIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQ5MTEiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQ5MDkiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDkyNyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDkyNSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0OTQzIgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0OTQxIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDQ5NTkiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDQ5NTciCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNDk3NSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNDk3MyIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg0OTkxIgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg0OTg5IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDUwMDMiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDUwMDEiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNTAxNSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNTAxMyIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg1MDMxIgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg1MDI5IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDUwNDciCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDUwNDUiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNTA2MyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNTA2MSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg1MDc5IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg1MDc3IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDUwOTUiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDUwOTMiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNTExMSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNTEwOSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg1MTI3IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg1MTI1IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDUxMzkiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDUxMzciCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNTE1MSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNTE0OSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg1MTY3IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg1MTY1IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDUxNzkiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDUxNzciCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNTE5MSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNTE4OSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg1MjA3IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg1MjA1IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDUyMjMiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDUyMjEiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNTIzOSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNTIzNyIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg1MjU1IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg1MjUzIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDUyNzEiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDUyNjkiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNTI4NyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNTI4NSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg1Mjk5IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg1Mjk3IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDUzMTEiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDUzMDkiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNTMyNyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNTMyNSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg1MzM5IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg1MzM3IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDUzNTEiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDUzNDkiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNTM2NyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNTM2NSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg1Mzc5IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg1Mzc3IgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDUzOTEiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDUzODkiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNTQwNyIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNTQwNSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg1NDE5IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg1NDE3IgogICAgICAgICBkPSJNIDUuMzM0ZS02LDU0MCBIIDcyMCBWIDAgSCAtMS40MzUxZS01IiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg1NDI5IgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg1NDI3IgogICAgICAgICBkPSJNIDEuODAwMWUtNSw1NDAgSCA3MjAgViAwIEwgLTIuMTM2OWUtNSw2LjEwMzVlLTUiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDU0MzkiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDU0MzciCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoNTQ1MSIKICAgICAgIGNsaXBQYXRoVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aAogICAgICAgICBzdHlsZT0iY2xpcC1ydWxlOmV2ZW5vZGQiCiAgICAgICAgIGlkPSJwYXRoNTQ0OSIKICAgICAgICAgZD0iTSAxLjA3MjllLTUsMCBIIDcyMC4wMDAwMSBWIDU0MCBIIDEuMDcyOWUtNSBaIiAvPjwvY2xpcFBhdGg+PGNsaXBQYXRoCiAgICAgICBpZD0iY2xpcFBhdGg1NDYzIgogICAgICAgY2xpcFBhdGhVbml0cz0idXNlclNwYWNlT25Vc2UiPjxwYXRoCiAgICAgICAgIHN0eWxlPSJjbGlwLXJ1bGU6ZXZlbm9kZCIKICAgICAgICAgaWQ9InBhdGg1NDYxIgogICAgICAgICBkPSJNIDEuMDcyOWUtNSwwIEggNzIwLjAwMDAxIFYgNTQwIEggMS4wNzI5ZS01IFoiIC8+PC9jbGlwUGF0aD48Y2xpcFBhdGgKICAgICAgIGlkPSJjbGlwUGF0aDU0NzUiCiAgICAgICBjbGlwUGF0aFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGgKICAgICAgICAgc3R5bGU9ImNsaXAtcnVsZTpldmVub2RkIgogICAgICAgICBpZD0icGF0aDU0NzMiCiAgICAgICAgIGQ9Ik0gMS4wNzI5ZS01LDAgSCA3MjAuMDAwMDEgViA1NDAgSCAxLjA3MjllLTUgWiIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMzMzMzMzMywwLDAsLTEuMzMzMzMzMywtNC4zMjAxNjgyLDcxNy4wMTAxOCkiCiAgICAgaWQ9Imc0NzgzIj48cGF0aAogICAgICAgaWQ9InBhdGg0Nzk5IgogICAgICAgc3R5bGU9ImZpbGw6I2Q5ZDlkOTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gNzUuMDk4NjQ3LDQ3NC45MjQ0MiBoIDM2LjM2MDAwMyB2IDI3Ljk2IEggNzUuMDk4NjQ3IFoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNDgwMSIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDc1LjA5ODY0Nyw0NzQuOTI0NDIgaCAzNi4zNjAwMDMgdiAyNy45NiBIIDc1LjA5ODY0NyBaIiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzQ4MDMiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ4MDkpIgogICAgICAgICBpZD0iZzQ4MDUiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0ODEzIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwxMTEsMzQwLjM0KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40ODExIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPjE8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg0ODE1IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2RlMDAwMDtzdHJva2Utd2lkdGg6MC43MjAwMDAwMztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNzUuMDM4NjQ3LDUyMy41ODQ0MiB2IC0xNzEuMTIiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNDgxNyIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNkZTAwMDA7c3Ryb2tlLXdpZHRoOjAuNzIwMDAwMDM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMwLjk5ODY0NCwzOTYuOTg0NDIgSCA1MzQuNDA4NjUiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMi44ODEzNTYsMTQxLjg2NDQyKSIKICAgICAgIGlkPSJnNDgxOSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDgyNSkiCiAgICAgICAgIGlkPSJnNDgyMSI+PHBhdGgKICAgICAgICAgICBpZD0icGF0aDQ4MjciCiAgICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2RlMDAwMDtzdHJva2Utd2lkdGg6MC43MjAwMDAwMztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgICBkPSJtIDE4Ni42LDI1NS42IGMgMCwtNy44OSAtMS4wNywtMTQuMjggLTIuMzgsLTE0LjI4IGggLTM5LjU4IGMgLTEuMzEsMCAtMi4zOCwtNi4zOSAtMi4zOCwtMTQuMjggMCw3Ljg5IC0xLjA3LDE0LjI4IC0yLjM4LDE0LjI4IEggMTAwLjMgYyAtMS4zMTQsMCAtMi4zOCw2LjM5IC0yLjM4LDE0LjI4IiAvPjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMi44ODEzNTYsMTQxLjg2NDQyKSIKICAgICAgIGlkPSJnNDgyOSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDgzNSkiCiAgICAgICAgIGlkPSJnNDgzMSI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQ4MzkiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxNC4wMzk5OTk5NnB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDEyMy4yNiwyMDkuODgpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQ4MzciCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCA5LjM1OTk5OTcgMTIuNDcyMiAyMC4yNzM3NiI+UGlwZTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzQ4NDEiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ4NDcpIgogICAgICAgICBpZD0iZzQ4NDMiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0ODUxIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTQuMDM5OTk5OTZweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwxNTEuMzQsMjA5Ljg4KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40ODQ5IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPi08L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc0ODUzIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg0ODU5KSIKICAgICAgICAgaWQ9Imc0ODU1Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NDg2MyIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE0LjAzOTk5OTk2cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMTU2LjAyLDIwOS44OCkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDg2MSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDcuODAwMDAwMiI+dXA8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc0ODY1Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg0ODcxKSIKICAgICAgICAgaWQ9Imc0ODY3Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NDg3NSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMzguNjE2LDMzOS44MikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDg3MyIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDUuMDA0MDAwMiAxNy4wMSI+SVNQPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMi44ODEzNTYsMTQxLjg2NDQyKSIKICAgICAgIGlkPSJnNDg3NyI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDg4MykiCiAgICAgICAgIGlkPSJnNDg3OSI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQ4ODciCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOC4wMjQwMDAxN3B4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDM5LjIxNiwyOTkuOTMpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQ4ODUiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCAxMy4wMTMzMjggMjQuOTYzMjQiPkRTUDwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzQ4ODkiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDQ4OTUpIgogICAgICAgICBpZD0iZzQ4OTEiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ0ODk5IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw0MS4xNiwyNjIuNTYpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQ4OTciCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCAxMi45OTYgMjUuMDAyMDAxIj5DUFU8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg0OTAxIgogICAgICAgc3R5bGU9ImZpbGw6I2Q5ZDlkOTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMTE5LjczODY1LDQ3NC45MjQ0MiBoIDM2LjM2IHYgMjcuOTYgaCAtMzYuMzYgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg0OTAzIgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMTE5LjczODY1LDQ3NC45MjQ0MiBoIDM2LjM2IHYgMjcuOTYgaCAtMzYuMzYgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc0OTA1Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg0OTExKSIKICAgICAgICAgaWQ9Imc0OTA3Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NDkxNSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMTU1LjY2LDM0MC4zNCkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDkxMyIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIj4yPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNDkxNyIKICAgICAgIHN0eWxlPSJmaWxsOiNkOWQ5ZDk7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDE2NC40OTg2NSw0NzQuNjg0NDIgaCAzNi4zNiB2IDI4LjA4IGggLTM2LjM2IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNDkxOSIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDE2NC40OTg2NSw0NzQuNjg0NDIgaCAzNi4zNiB2IDI4LjA4IGggLTM2LjM2IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMi44ODEzNTYsMTQxLjg2NDQyKSIKICAgICAgIGlkPSJnNDkyMSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDkyNykiCiAgICAgICAgIGlkPSJnNDkyMyI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQ5MzEiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDIwMC40MiwzNDAuMikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDkyOSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIj4zPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNDkzMyIKICAgICAgIHN0eWxlPSJmaWxsOiNkOWQ5ZDk7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDIwOS44NTg2NSw0NzQuNjg0NDIgaCAzNi4zNiB2IDI4LjA4IGggLTM2LjM2IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNDkzNSIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDIwOS44NTg2NSw0NzQuNjg0NDIgaCAzNi4zNiB2IDI4LjA4IGggLTM2LjM2IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMi44ODEzNTYsMTQxLjg2NDQyKSIKICAgICAgIGlkPSJnNDkzNyI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDk0MykiCiAgICAgICAgIGlkPSJnNDkzOSI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQ5NDciCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDI0NS44NiwzNDAuMikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDk0NSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIj40PC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNDk0OSIKICAgICAgIHN0eWxlPSJmaWxsOiNkOWQ5ZDk7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDI1NC40OTg2NSw0NzQuOTI0NDIgaCAzNi4zNiB2IDI3Ljk2IGggLTM2LjM2IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNDk1MSIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDI1NC40OTg2NSw0NzQuOTI0NDIgaCAzNi4zNiB2IDI3Ljk2IGggLTM2LjM2IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMi44ODEzNTYsMTQxLjg2NDQyKSIKICAgICAgIGlkPSJnNDk1MyI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDk1OSkiCiAgICAgICAgIGlkPSJnNDk1NSI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQ5NjMiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDI4Ni41NiwzNDAuMzQpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjQ5NjEiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCI+4oCmPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNDk2NSIKICAgICAgIHN0eWxlPSJmaWxsOiNkOWQ5ZDk7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDI5OS4xMzg2NSw0NzQuNjg0NDIgaCAzNi4zNiB2IDI4LjA4IGggLTM2LjM2IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNDk2NyIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDI5OS4xMzg2NSw0NzQuNjg0NDIgaCAzNi4zNiB2IDI4LjA4IGggLTM2LjM2IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMi44ODEzNTYsMTQxLjg2NDQyKSIKICAgICAgIGlkPSJnNDk2OSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNDk3NSkiCiAgICAgICAgIGlkPSJnNDk3MSI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDQ5NzkiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDMzMS4yMiwzNDAuMikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNDk3NyIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIj7igKY8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg0OTgxIgogICAgICAgc3R5bGU9ImZpbGw6I2Q5ZDlkOTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMzQzLjQxODY1LDQ3NC4zMjQ0MiBoIDM2LjI0IHYgMjguMDggaCAtMzYuMjQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg0OTgzIgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMzQzLjQxODY1LDQ3NC4zMjQ0MiBoIDM2LjI0IHYgMjguMDggaCAtMzYuMjQgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc0OTg1Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg0OTkxKSIKICAgICAgICAgaWQ9Imc0OTg3Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NDk5NSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMzc0LjY5LDM0Mi4xKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW40OTkzIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPk48L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc0OTk3Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1MDAzKSIKICAgICAgICAgaWQ9Imc0OTk5Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NTAwNyIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMzgzLjMzLDM0Mi4xKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MDA1IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPi08L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc1MDA5Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1MDE1KSIKICAgICAgICAgaWQ9Imc1MDExIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NTAxOSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMzg3LjI5LDM0Mi4xKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MDE3IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPjE8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg1MDIxIgogICAgICAgc3R5bGU9ImZpbGw6I2Q5ZDlkOTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMzg3LjgxODY1LDQ3My45NjQ0MiBoIDM2LjM2IHYgMjguMDggaCAtMzYuMzYgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg1MDIzIgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMzg3LjgxODY1LDQ3My45NjQ0MiBoIDM2LjM2IHYgMjguMDggaCAtMzYuMzYgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc1MDI1Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1MDMxKSIKICAgICAgICAgaWQ9Imc1MDI3Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NTAzNSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNDI0LjU4LDM0MS43MSkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNTAzMyIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIj5OPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNTAzNyIKICAgICAgIHN0eWxlPSJmaWxsOiM3ZjdmN2Y7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDExOS43Mzg2NSw0MzUuOTI0NDIgaCAzNi4zNiB2IDI4LjA4IGggLTM2LjM2IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNTAzOSIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDExOS43Mzg2NSw0MzUuOTI0NDIgaCAzNi4zNiB2IDI4LjA4IGggLTM2LjM2IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMi44ODEzNTYsMTQxLjg2NDQyKSIKICAgICAgIGlkPSJnNTA0MSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNTA0NykiCiAgICAgICAgIGlkPSJnNTA0MyI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDUwNTEiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDE1NS42NiwzMDEuMzcpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjUwNDkiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCI+MTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDUwNTMiCiAgICAgICBzdHlsZT0iZmlsbDojN2Y3ZjdmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAxNjQuMzc4NjUsNDM1LjkyNDQyIGggMzYuMzYgdiAyOC4wOCBoIC0zNi4zNiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDUwNTUiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAxNjQuMzc4NjUsNDM1LjkyNDQyIGggMzYuMzYgdiAyOC4wOCBoIC0zNi4zNiB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzUwNTciPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDUwNjMpIgogICAgICAgICBpZD0iZzUwNTkiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ1MDY3IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwyMDAuMzMsMzAxLjM3KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MDY1IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPjI8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg1MDY5IgogICAgICAgc3R5bGU9ImZpbGw6IzdmN2Y3ZjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMjA5LjEzODY1LDQzNS44MDQ0MiBoIDM2LjM2IHYgMjcuOTYgaCAtMzYuMzYgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg1MDcxIgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMjA5LjEzODY1LDQzNS44MDQ0MiBoIDM2LjM2IHYgMjcuOTYgaCAtMzYuMzYgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc1MDczIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1MDc5KSIKICAgICAgICAgaWQ9Imc1MDc1Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NTA4MyIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMjQ1LjA5LDMwMS4yKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MDgxIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPjM8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg1MDg1IgogICAgICAgc3R5bGU9ImZpbGw6IzdmN2Y3ZjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMjU0LjQ5ODY1LDQzNS44MDQ0MiBoIDM2LjM2IHYgMjcuOTYgaCAtMzYuMzYgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg1MDg3IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMjU0LjQ5ODY1LDQzNS44MDQ0MiBoIDM2LjM2IHYgMjcuOTYgaCAtMzYuMzYgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc1MDg5Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1MDk1KSIKICAgICAgICAgaWQ9Imc1MDkxIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NTA5OSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMjg2LjU0LDMwMS4yKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MDk3IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPuKApjwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDUxMDEiCiAgICAgICBzdHlsZT0iZmlsbDojN2Y3ZjdmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAyOTkuMTM4NjUsNDM1LjkyNDQyIGggMzYuMzYgdiAyOC4wOCBoIC0zNi4zNiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDUxMDMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAyOTkuMTM4NjUsNDM1LjkyNDQyIGggMzYuMzYgdiAyOC4wOCBoIC0zNi4zNiB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzUxMDUiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDUxMTEpIgogICAgICAgICBpZD0iZzUxMDciPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ1MTE1IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwzMzEuMjIsMzAxLjM3KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MTEzIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPuKApjwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDUxMTciCiAgICAgICBzdHlsZT0iZmlsbDojN2Y3ZjdmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAzNDMuODk4NjUsNDM1LjgwNDQyIGggMzYuMjQgdiAyNy45NiBoIC0zNi4yNCB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDUxMTkiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAzNDMuODk4NjUsNDM1LjgwNDQyIGggMzYuMjQgdiAyNy45NiBoIC0zNi4yNCB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzUxMjEiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDUxMjcpIgogICAgICAgICBpZD0iZzUxMjMiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ1MTMxIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTJweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwzNzUuMTcsMzAzLjQ4KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MTI5IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPk48L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc1MTMzIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1MTM5KSIKICAgICAgICAgaWQ9Imc1MTM1Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NTE0MyIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMzgzLjgxLDMwMy40OCkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNTE0MSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIj4tPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMi44ODEzNTYsMTQxLjg2NDQyKSIKICAgICAgIGlkPSJnNTE0NSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNTE1MSkiCiAgICAgICAgIGlkPSJnNTE0NyI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDUxNTUiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDM4Ny43NywzMDMuNDgpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjUxNTMiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCI+MjwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDUxNTciCiAgICAgICBzdHlsZT0iZmlsbDojN2Y3ZjdmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAzODguMDU4NjUsNDM1LjMyNDQyIGggMzYuMzYgdiAyOC4wOCBoIC0zNi4zNiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDUxNTkiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAzODguMDU4NjUsNDM1LjMyNDQyIGggMzYuMzYgdiAyOC4wOCBoIC0zNi4zNiB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzUxNjEiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDUxNjcpIgogICAgICAgICBpZD0iZzUxNjMiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ1MTcxIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTIuMDI0MDAwMTdweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw0MTkuMzUsMzAzLjEyKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MTY5IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPk48L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc1MTczIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1MTc5KSIKICAgICAgICAgaWQ9Imc1MTc1Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NTE4MyIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEyLjAyNDAwMDE3cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNDI3Ljk5LDMwMy4xMikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNTE4MSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIj4tPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMi44ODEzNTYsMTQxLjg2NDQyKSIKICAgICAgIGlkPSJnNTE4NSI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNTE5MSkiCiAgICAgICAgIGlkPSJnNTE4NyI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDUxOTUiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMi4wMjQwMDAxN3B4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDQzMS45NSwzMDMuMTIpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjUxOTMiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCI+MTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDUxOTciCiAgICAgICBzdHlsZT0iZmlsbDojN2Y3ZjdmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSA0MzIuNDU4NjUsNDM0Ljk2NDQyIGggMzYuMzYgdiAyOC4wOCBoIC0zNi4zNiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDUxOTkiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA0MzIuNDU4NjUsNDM0Ljk2NDQyIGggMzYuMzYgdiAyOC4wOCBoIC0zNi4zNiB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzUyMDEiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDUyMDcpIgogICAgICAgICBpZD0iZzUyMDMiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ1MjExIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTJweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw0NjkuMjUsMzAyLjc0KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MjA5IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPk48L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg1MjEzIgogICAgICAgc3R5bGU9ImZpbGw6I2ZmYzVjNTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMTY0LjczODY1LDM5OC42MDQ0MiBoIDM2LjM2IHYgMjguMDggaCAtMzYuMzYgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg1MjE1IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMTY0LjczODY1LDM5OC42MDQ0MiBoIDM2LjM2IHYgMjguMDggaCAtMzYuMzYgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc1MjE3Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1MjIzKSIKICAgICAgICAgaWQ9Imc1MjE5Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NTIyNyIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE4cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMjAwLjY2LDI2NC4wMikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNTIyNSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIj4xPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PHBhdGgKICAgICAgIGlkPSJwYXRoNTIyOSIKICAgICAgIHN0eWxlPSJmaWxsOiNmZmM1YzU7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmUiCiAgICAgICBkPSJtIDIwOS4zNzg2NSwzOTguNjA0NDIgaCAzNi4zNiB2IDI4LjA4IGggLTM2LjM2IHoiIC8+PHBhdGgKICAgICAgIGlkPSJwYXRoNTIzMSIKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNhMzAwMDA7c3Ryb2tlLXdpZHRoOjIuMDM5OTk5OTY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDIwOS4zNzg2NSwzOTguNjA0NDIgaCAzNi4zNiB2IDI4LjA4IGggLTM2LjM2IHoiIC8+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMi44ODEzNTYsMTQxLjg2NDQyKSIKICAgICAgIGlkPSJnNTIzMyI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNTIzOSkiCiAgICAgICAgIGlkPSJnNTIzNSI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDUyNDMiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDI0NS4zMywyNjQuMDIpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjUyNDEiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCI+MjwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDUyNDUiCiAgICAgICBzdHlsZT0iZmlsbDojZmZjNWM1O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAyNTQuMTM4NjUsMzk4LjQ4NDQyIGggMzYuMzYgdiAyNy45NiBoIC0zNi4zNiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDUyNDciCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAyNTQuMTM4NjUsMzk4LjQ4NDQyIGggMzYuMzYgdiAyNy45NiBoIC0zNi4zNiB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzUyNDkiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDUyNTUpIgogICAgICAgICBpZD0iZzUyNTEiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ1MjU5IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwyODYuMTMsMjYzLjg4KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MjU3IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPuKApjwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDUyNjEiCiAgICAgICBzdHlsZT0iZmlsbDojZmZjNWM1O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAyOTkuNDk4NjUsMzk4LjQ4NDQyIGggMzYuMzYgdiAyNy45NiBoIC0zNi4zNiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDUyNjMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAyOTkuNDk4NjUsMzk4LjQ4NDQyIGggMzYuMzYgdiAyNy45NiBoIC0zNi4zNiB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzUyNjUiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDUyNzEpIgogICAgICAgICBpZD0iZzUyNjciPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ1Mjc1IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MThweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwzMzEuNTQsMjYzLjg4KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MjczIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPuKApjwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxwYXRoCiAgICAgICBpZD0icGF0aDUyNzciCiAgICAgICBzdHlsZT0iZmlsbDojZmZjNWM1O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICAgICAgZD0ibSAzNDQuMTM4NjUsMzk4LjYwNDQyIGggMzYuMzYgdiAyOC4wOCBoIC0zNi4zNiB6IiAvPjxwYXRoCiAgICAgICBpZD0icGF0aDUyNzkiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojYTMwMDAwO3N0cm9rZS13aWR0aDoyLjAzOTk5OTk2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAzNDQuMTM4NjUsMzk4LjYwNDQyIGggMzYuMzYgdiAyOC4wOCBoIC0zNi4zNiB6IiAvPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzUyODEiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDUyODcpIgogICAgICAgICBpZD0iZzUyODMiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ1MjkxIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTIuMDI0MDAwMTdweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwzNzUuNSwyNjYuMzMpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjUyODkiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCI+TjwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzUyOTMiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDUyOTkpIgogICAgICAgICBpZD0iZzUyOTUiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ1MzAzIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTIuMDI0MDAwMTdweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwzODQuMTQsMjY2LjMzKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MzAxIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPi08L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc1MzA1Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1MzExKSIKICAgICAgICAgaWQ9Imc1MzA3Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NTMxNSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEyLjAyNDAwMDE3cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsMzg4LjEsMjY2LjMzKSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MzEzIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPjM8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg1MzE3IgogICAgICAgc3R5bGU9ImZpbGw6I2ZmYzVjNTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gMzg4Ljg5ODY1LDM5OC40ODQ0MiBoIDM2LjI0IHYgMjcuOTYgaCAtMzYuMjQgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg1MzE5IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMzg4Ljg5ODY1LDM5OC40ODQ0MiBoIDM2LjI0IHYgMjcuOTYgaCAtMzYuMjQgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc1MzIxIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1MzI3KSIKICAgICAgICAgaWQ9Imc1MzIzIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NTMzMSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNDIwLjE3LDI2Ni4xNikiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNTMyOSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIj5OPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMi44ODEzNTYsMTQxLjg2NDQyKSIKICAgICAgIGlkPSJnNTMzMyI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNTMzOSkiCiAgICAgICAgIGlkPSJnNTMzNSI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDUzNDMiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDQyOC44MSwyNjYuMTYpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjUzNDEiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCI+LTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzUzNDUiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDUzNTEpIgogICAgICAgICBpZD0iZzUzNDciPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ1MzU1IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTJweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw0MzIuNzcsMjY2LjE2KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MzUzIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPjI8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg1MzU3IgogICAgICAgc3R5bGU9ImZpbGw6I2ZmYzVjNTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gNDMzLjA1ODY1LDM5OC4wMDQ0MiBoIDM2LjM2IHYgMjguMDggaCAtMzYuMzYgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg1MzU5IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNDMzLjA1ODY1LDM5OC4wMDQ0MiBoIDM2LjM2IHYgMjguMDggaCAtMzYuMzYgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc1MzYxIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1MzY3KSIKICAgICAgICAgaWQ9Imc1MzYzIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NTM3MSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNDY0LjM1LDI2NS43OCkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNTM2OSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIj5OPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMi44ODEzNTYsMTQxLjg2NDQyKSIKICAgICAgIGlkPSJnNTM3MyI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNTM3OSkiCiAgICAgICAgIGlkPSJnNTM3NSI+PHRleHQKICAgICAgICAgICBpZD0idGV4dDUzODMiCiAgICAgICAgICAgc3R5bGU9ImZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtZmFtaWx5OkFyaWFsOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246QXJpYWxNVDt3cml0aW5nLW1vZGU6bHItdGI7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLDQ3Mi45OSwyNjUuNzgpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjUzODEiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCI+LTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzUzODUiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDUzOTEpIgogICAgICAgICBpZD0iZzUzODciPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ1Mzk1IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTJweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw0NzYuOTUsMjY1Ljc4KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41MzkzIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPjE8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48cGF0aAogICAgICAgaWQ9InBhdGg1Mzk3IgogICAgICAgc3R5bGU9ImZpbGw6I2ZmYzVjNTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgIGQ9Im0gNDc3LjQ1ODY1LDM5Ny42NDQ0MiBoIDM2LjM2IHYgMjguMDggaCAtMzYuMzYgeiIgLz48cGF0aAogICAgICAgaWQ9InBhdGg1Mzk5IgogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2EzMDAwMDtzdHJva2Utd2lkdGg6Mi4wMzk5OTk5NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNDc3LjQ1ODY1LDM5Ny42NDQ0MiBoIDM2LjM2IHYgMjguMDggaCAtMzYuMzYgeiIgLz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc1NDAxIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1NDA3KSIKICAgICAgICAgaWQ9Imc1NDAzIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NTQxMSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjEycHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNTE0LjI1LDI2NS4zOSkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNTQwOSIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIj5OPC90c3Bhbj48L3RleHQ+CjwvZz48L2c+PGcKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMi44ODEzNTYsMTQxLjg2NDQyKSIKICAgICAgIGlkPSJnNTQxMyI+PGcKICAgICAgICAgY2xpcC1wYXRoPSJ1cmwoI2NsaXBQYXRoNTQxOSkiCiAgICAgICAgIGlkPSJnNTQxNSI+PHBhdGgKICAgICAgICAgICBpZD0icGF0aDU0MjEiCiAgICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2RlMDAwMDtzdHJva2Utd2lkdGg6MC43MjAwMDAwMztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgICBkPSJtIDQ1MS42OCwyNTQuNjQgYyAwLC03Ljg5IC0xLjA3LC0xNC4yOCAtMi4zOCwtMTQuMjggSCAzMjEuNTIgYyAtMS4zMSwwIC0yLjM4LC02LjM5IC0yLjM4LC0xNC4yOCAwLDcuODkgLTEuMDcsMTQuMjggLTIuMzgsMTQuMjggSCAxODguOTggYyAtMS4zMSwwIC0yLjM4LDYuMzkgLTIuMzgsMTQuMjgiIC8+PC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc1NDIzIj48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1NDI5KSIKICAgICAgICAgaWQ9Imc1NDI1Ij48cGF0aAogICAgICAgICAgIGlkPSJwYXRoNTQzMSIKICAgICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojZGUwMDAwO3N0cm9rZS13aWR0aDowLjcyMDAwMDAzO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICAgIGQ9Im0gNTM3LjcyLDI1NC4yOCBjIDAsLTcuOTIgLTEuMDcsLTE0LjM0IC0yLjM5LC0xNC4zNCBoIC0zOC4xMiBjIC0xLjMyLDAgLTIuMzksLTYuNDIgLTIuMzksLTE0LjM0IDAsNy45MiAtMS4wNywxNC4zNCAtMi4zOSwxNC4zNCBoIC0zOC4xMiBjIC0xLjMyLDAgLTIuMzksNi40MiAtMi4zOSwxNC4zNCIgLz48L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzU0MzMiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDU0MzkpIgogICAgICAgICBpZD0iZzU0MzUiPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ1NDQzIgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTQuMDM5OTk5OTZweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSwyOTcuNywyMDguNDIpIj48dHNwYW4KICAgICAgICAgICAgIGlkPSJ0c3BhbjU0NDEiCiAgICAgICAgICAgICB5PSIwIgogICAgICAgICAgICAgeD0iMCA5LjM2NDY4MDMgMTIuNDgxNTYgMjAuMjg3OCAyOC4wOTQwNCAzMS4yMTA5MiAzNC4zMjc4MDEgNDIuMTM0MDQxIj5QaXBlbGluZTwvdHNwYW4+PC90ZXh0Pgo8L2c+PC9nPjxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjIuODgxMzU2LDE0MS44NjQ0MikiCiAgICAgICBpZD0iZzU0NDUiPjxnCiAgICAgICAgIGNsaXAtcGF0aD0idXJsKCNjbGlwUGF0aDU0NTEpIgogICAgICAgICBpZD0iZzU0NDciPjx0ZXh0CiAgICAgICAgICAgaWQ9InRleHQ1NDU1IgogICAgICAgICAgIHN0eWxlPSJmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MTQuMDM5OTk5OTZweDtmb250LWZhbWlseTpBcmlhbDstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkFyaWFsTVQ7d3JpdGluZy1tb2RlOmxyLXRiO2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwtMSw0NjYuMzIsMjA3Ljg5KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41NDUzIgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAgOS4zNTk5OTk3IDEyLjQ3MjIgMjAuMjczNzYiPlBpcGU8L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc1NDU3Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1NDYzKSIKICAgICAgICAgaWQ9Imc1NDU5Ij48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NTQ2NyIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE0LjAzOTk5OTk2cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNDk0LjQsMjA3Ljg5KSI+PHRzcGFuCiAgICAgICAgICAgICBpZD0idHNwYW41NDY1IgogICAgICAgICAgICAgeT0iMCIKICAgICAgICAgICAgIHg9IjAiPi08L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyLjg4MTM1NiwxNDEuODY0NDIpIgogICAgICAgaWQ9Imc1NDY5Ij48ZwogICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGg1NDc1KSIKICAgICAgICAgaWQ9Imc1NDcxIj48dGV4dAogICAgICAgICAgIGlkPSJ0ZXh0NTQ3OSIKICAgICAgICAgICBzdHlsZT0iZm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zaXplOjE0LjAzOTk5OTk2cHg7Zm9udC1mYW1pbHk6QXJpYWw7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpBcmlhbE1UO3dyaXRpbmctbW9kZTpsci10YjtmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEsNDk5LjA4LDIwNy44OSkiPjx0c3BhbgogICAgICAgICAgICAgaWQ9InRzcGFuNTQ3NyIKICAgICAgICAgICAgIHk9IjAiCiAgICAgICAgICAgICB4PSIwIDcuODA2MjQwMSAxNS42MTI0OCAyNS41NjY4MzkiPmRvd248L3RzcGFuPjwvdGV4dD4KPC9nPjwvZz48L2c+PC9zdmc+" alt="Fig6 Phases of pipeline" width="800">
</div>
<div class="title">Figure 6. 3 Phases of pipeline: pipe-up, pipeline, and pipe-down</div>
</div>
<div class="paragraph">
<p>In order for the graph to be executed in a pipelined fashion, the steps
outlined below need to be followed by an application:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a graph and add nodes to the graph as usual.</p>
</li>
<li>
<p>For data references which need to be enqueued and dequeued by the
application, add them as graph parameters.</p>
</li>
<li>
<p>Call <code><a href="#vxSetGraphScheduleConfig">vxSetGraphScheduleConfig</a></code> with the parameters as follows:</p>
<div class="ulist">
<ul>
<li>
<p>Set scheduling mode
(<code><a href="#VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL">VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</a></code>
or
<code><a href="#VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO">VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</a></code>).</p>
</li>
<li>
<p>List the graph parameters on which enqueue / dequeue operations are
required.</p>
</li>
<li>
<p>For these parameters specify the list of references that could be
enqueued later.</p>
</li>
</ul>
</div>
</li>
<li>
<p>All other data references created in, and associated with, the graph are
made specific to the graph. A data reference can be made specific to a
graph by either creating it as virtual or by exporting and re-importing
the graph using the import/export extension.</p>
</li>
<li>
<p>Delays in the graph, if any, MUST be set to auto-age using
<code>vxRegisterAutoAging</code>.</p>
</li>
<li>
<p>Verify the graph using <code>vxVerifyGraph</code>.</p>
</li>
<li>
<p>Now data reference enqueue / dequeue can be done on associated graph
parameters using <code><a href="#vxGraphParameterEnqueueReadyRef">vxGraphParameterEnqueueReadyRef</a></code> and
<code><a href="#vxGraphParameterDequeueDoneRef">vxGraphParameterDequeueDoneRef</a></code>.</p>
</li>
<li>
<p>Graph execution on enqueued parameters depends on the scheduling mode
chosen:</p>
<div class="ulist">
<ul>
<li>
<p><code><a href="#VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL">VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</a></code>:
User manually schedules the graph on the full set of all enqueued
parameters by calling <code>vxScheduleGraph</code>. This gives more control to
the application to limit when the graph execution on enqueued
parameters can begin.</p>
</li>
<li>
<p><code><a href="#VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO">VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</a></code>:
Implementation automatically schedules graph as long as enough data is
enqueued to it. This gives more control to the implementation to decide
when the graph execution on enqueued parameters can begin.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code><a href="#vxGraphParameterCheckDoneRef">vxGraphParameterCheckDoneRef</a></code> can be used to determine when to
dequeue graph parameters for completed graph executions.</p>
</li>
<li>
<p>In order to gracefully end graph pipelining, the application should
cease enqueing graph parameters, and call <code>vxWaitGraph</code> to wait for
the in-flight graph executions to complete. When the call returns, call
<code><a href="#vxGraphParameterDequeueDoneRef">vxGraphParameterDequeueDoneRef</a></code> on all the graph parameters to
return control of the buffers to the application.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following code offers an example of the process outlined above, using
<code><a href="#VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO">VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</a></code>
scheduling mode.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="comment">/*
 * index of graph parameter data reference which is used to provide input to the graph
 */</span>
<span class="preprocessor">#define</span> GRAPH_PARAMETER_IN  (<span class="integer">0</span>u)
<span class="comment">/*
 * index of graph parameter data reference which is used to provide output to the graph
 */</span>
<span class="preprocessor">#define</span> GRAPH_PARAMETER_OUT (<span class="integer">1</span>u)
<span class="comment">/*
 * max parameters to this graph
 */</span>
<span class="preprocessor">#define</span> GRAPH_PARAMETER_MAX (<span class="integer">2</span>u)

<span class="comment">/*
 * Utility API used to add a graph parameter from a node, node parameter index
 */</span>
<span class="directive">void</span> add_graph_parameter_by_node_index(vx_graph graph, vx_node node,
                                       vx_uint32 node_parameter_index)
{
    vx_parameter parameter = vxGetParameterByIndex(node, node_parameter_index);
    vxAddParameterToGraph(graph, parameter);
    vxReleaseParameter(&amp;parameter);
}

<span class="comment">/*
 * Utility API used to create graph with graph parameter for input and output
 *
 * The following graph is created,
 * IN_IMG -&gt; EXTRACT_NODE -&gt; TMP_IMG -&gt; CONVERT_DEPTH_NODE -&gt; OUT_IMG
 *                                          ^
 *                                          |
 *                                      SHIFT_SCALAR
 *
 * IN_IMG and OUT_IMG are graph parameters.
 * TMP_IMG is a virtual image
 */</span>
<span class="directive">static</span> vx_graph create_graph(vx_context context, vx_uint32 width, vx_uint32 height)
{
    vx_graph graph;
    vx_node n0, n1;
    vx_image tmp_img;
    vx_int32 shift;
    vx_scalar s0;

    graph = vxCreateGraph(context);

    <span class="comment">/* create intermediate virtual image */</span>
    tmp_img = vxCreateVirtualImage(graph, <span class="integer">0</span>, <span class="integer">0</span>, VX_DF_IMAGE_VIRT);

    <span class="comment">/* create first node, input is NULL this will be made as graph parameter */</span>
    n0 = vxChannelExtractNode(graph, <span class="predefined-constant">NULL</span>, VX_CHANNEL_G, tmp_img);

    <span class="comment">/* create a scalar object required for second node */</span>
    shift = <span class="integer">8</span>;
    s0 = vxCreateScalar(context, VX_TYPE_INT32, &amp;shift);

    <span class="comment">/* create second node, output is NULL since this will be made as graph parameter
     */</span>
    n1 = vxConvertDepthNode(graph, tmp_img, <span class="predefined-constant">NULL</span>, VX_CONVERT_POLICY_SATURATE, s0);

    <span class="comment">/* add graph parameters */</span>
    add_graph_parameter_by_node_index(graph, n0, <span class="integer">0</span>);
    add_graph_parameter_by_node_index(graph, n1, <span class="integer">1</span>);

    vxReleaseScalar(&amp;s0);
    vxReleaseNode(&amp;n0);
    vxReleaseNode(&amp;n1);
    vxReleaseImage(&amp;tmp_img);

    <span class="keyword">return</span> graph;
}

<span class="comment">/*
 * Utility API used to fill data and enqueue input to graph
 */</span>
<span class="directive">static</span> <span class="directive">void</span> enqueue_input(vx_graph graph,
                          vx_uint32 width, vx_uint32 height, vx_image in_img)
{
    vx_rectangle_t rect = { <span class="integer">0</span>, <span class="integer">0</span>, width, height};
    vx_imagepatch_addressing_t imagepatch_addr;
    vx_map_id map_id;
    <span class="directive">void</span> *user_ptr;

    <span class="keyword">if</span>(in_img!=<span class="predefined-constant">NULL</span>)
    {
        <span class="comment">/* Fill input data using Copy/Map/SwapHandles */</span>
        vxMapImagePatch(in_img, &amp;rect, <span class="integer">0</span>, &amp;map_id, &amp;imagepatch_addr, &amp;user_ptr,
                        VX_WRITE_ONLY, VX_MEMORY_TYPE_NONE, VX_NOGAP_X);
        <span class="comment">/* ... */</span>
        vxUnmapImagePatch(in_img, map_id);
        vxGraphParameterEnqueueReadyRef(graph, GRAPH_PARAMETER_IN,
                                        (vx_reference*)&amp;in_img, <span class="integer">1</span>);
    }
}

<span class="comment">/*
 * Utility API used to fill input to graph
 */</span>
<span class="directive">static</span> <span class="directive">void</span> dequeue_input(vx_graph graph, vx_image *in_img)
{
    vx_uint32 num_refs;

    *in_img = <span class="predefined-constant">NULL</span>;

    <span class="comment">/* Get consumed input reference */</span>
    vxGraphParameterDequeueDoneRef(graph, GRAPH_PARAMETER_IN,
                                   (vx_reference*)in_img, <span class="integer">1</span>, &amp;num_refs);
}

<span class="comment">/*
 * Utility API used to enqueue output to graph
 */</span>
<span class="directive">static</span> <span class="directive">void</span> enqueue_output(vx_graph graph, vx_image out_img)
{
    <span class="keyword">if</span>(out_img!=<span class="predefined-constant">NULL</span>)
    {
        vxGraphParameterEnqueueReadyRef(graph, GRAPH_PARAMETER_OUT,
                                        (vx_reference*)&amp;out_img, <span class="integer">1</span>);
    }
}

<span class="directive">static</span> vx_bool is_output_available(vx_graph graph)
{
    vx_uint32 num_refs;

    vxGraphParameterCheckDoneRef(graph, GRAPH_PARAMETER_OUT, &amp;num_refs);

    <span class="keyword">return</span> (num_refs &gt; <span class="integer">0</span>);
}

<span class="comment">/*
 * Utility API used to dequeue output and consume it
 */</span>
<span class="directive">static</span> <span class="directive">void</span> dequeue_output(vx_graph graph,
                           vx_uint32 width, vx_uint32 height, vx_image *out_img)
{
    vx_rectangle_t rect = { <span class="integer">0</span>, <span class="integer">0</span>, width, height};
    vx_imagepatch_addressing_t imagepatch_addr;
    vx_map_id map_id;
    <span class="directive">void</span> *user_ptr;
    vx_uint32 num_refs;

    *out_img = <span class="predefined-constant">NULL</span>;

    <span class="comment">/* Get output reference and consume new data,
     * waits until a reference is available
     */</span>
    vxGraphParameterDequeueDoneRef(graph, GRAPH_PARAMETER_OUT,
                                   (vx_reference*)out_img, <span class="integer">1</span>, &amp;num_refs);
    <span class="keyword">if</span>(*out_img!=<span class="predefined-constant">NULL</span>)
    {
        <span class="comment">/* Consume output data using Copy/Map/SwapHandles */</span>
        vxMapImagePatch(*out_img, &amp;rect, <span class="integer">0</span>, &amp;map_id, &amp;imagepatch_addr, &amp;user_ptr,
                        VX_READ_ONLY, VX_MEMORY_TYPE_NONE, VX_NOGAP_X);
        <span class="comment">/* ... */</span>
        vxUnmapImagePatch(*out_img, map_id);
    }
}

<span class="comment">/* Max number of input references */</span>
<span class="preprocessor">#define</span> GRAPH_PARAMETER_IN_MAX_REFS   (<span class="integer">2</span>u)
<span class="comment">/* Max number of output references */</span>
<span class="preprocessor">#define</span> GRAPH_PARAMETER_OUT_MAX_REFS   (<span class="integer">2</span>u)

<span class="comment">/* execute graph in a pipelined manner
 */</span>
<span class="directive">void</span> vx_khr_pipelining()
{
    vx_uint32 width = <span class="integer">640</span>, height = <span class="integer">480</span>, i;
    vx_context context;
    vx_graph graph;
    vx_image in_refs[GRAPH_PARAMETER_IN_MAX_REFS];
    vx_image out_refs[GRAPH_PARAMETER_IN_MAX_REFS];
    vx_image in_img, out_img;
    vx_graph_parameter_queue_params_t graph_parameters_queue_params_list[GRAPH_PARAMETER_MAX];

    context = vxCreateContext();
    graph = create_graph(context, width, height);

    create_data_refs(context, in_refs, out_refs, GRAPH_PARAMETER_IN_MAX_REFS,
                     GRAPH_PARAMETER_OUT_MAX_REFS, width, height);

    graph_parameters_queue_params_list[<span class="integer">0</span>].graph_parameter_index =
            GRAPH_PARAMETER_IN;
    graph_parameters_queue_params_list[<span class="integer">0</span>].refs_list_size =
            GRAPH_PARAMETER_IN_MAX_REFS;
    graph_parameters_queue_params_list[<span class="integer">0</span>].refs_list =
            (vx_reference*)&amp;in_refs[<span class="integer">0</span>];
    graph_parameters_queue_params_list[<span class="integer">1</span>].graph_parameter_index =
            GRAPH_PARAMETER_OUT;
    graph_parameters_queue_params_list[<span class="integer">1</span>].refs_list_size =
            GRAPH_PARAMETER_OUT_MAX_REFS;
    graph_parameters_queue_params_list[<span class="integer">1</span>].refs_list =
            (vx_reference*)&amp;out_refs[<span class="integer">0</span>];

    vxSetGraphScheduleConfig(graph,
            VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO,
            GRAPH_PARAMETER_MAX,
            graph_parameters_queue_params_list
            );

    vxVerifyGraph(graph);

    <span class="comment">/* enqueue input and output to trigger graph */</span>
    <span class="keyword">for</span>(i=<span class="integer">0</span>; i&lt;GRAPH_PARAMETER_IN_MAX_REFS; i++)
    {
        enqueue_input(graph, width, height, in_refs[i]);
    }
    <span class="keyword">for</span>(i=<span class="integer">0</span>; i&lt;GRAPH_PARAMETER_OUT_MAX_REFS; i++)
    {
        enqueue_output(graph, out_refs[i]);
    }

    <span class="keyword">while</span>(<span class="integer">1</span>)
    {
        <span class="comment">/* wait for input to be available, dequeue it -
         * BLOCKs until input can be dequeued
         */</span>
        dequeue_input(graph, &amp;in_img);

        <span class="comment">/* wait for output to be available, dequeue output and process it -
         * BLOCKs until output can be dequeued
         */</span>
        dequeue_output(graph, width, height, &amp;out_img);

        <span class="comment">/* recycle input - fill new data and re-enqueue*/</span>
        enqueue_input(graph, width, height, in_img);

        <span class="comment">/* recycle output */</span>
        enqueue_output(graph, out_img);

        <span class="keyword">if</span>(CheckExit())
        {
            <span class="comment">/* App wants to exit, break from main loop */</span>
            <span class="keyword">break</span>;
        }
    }

    <span class="comment">/*
     * wait until all previous graph executions have completed
     */</span>
    vxWaitGraph(graph);

    <span class="comment">/* flush output references, only required
     * if need to consume last few references
     */</span>
    <span class="keyword">while</span>( is_output_available(graph) )
    {
      dequeue_output(graph, width, height, &amp;out_img);
    }

    vxReleaseGraph(&amp;graph);
    release_data_refs(in_refs, out_refs, GRAPH_PARAMETER_IN_MAX_REFS,
                      GRAPH_PARAMETER_OUT_MAX_REFS);
    vxReleaseContext(&amp;context);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec_batch_processing_app">2.2.4. Example Batch processing application</h4>
<div class="paragraph">
<p>In order for the graph to be executed in batch processing mode, the steps
outlined below need to be followed by an application:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a graph and add nodes to the graph as usual.</p>
</li>
<li>
<p>For data references which need to be &#8220;batched&#8221; by the application, add
them as graph parameters.</p>
</li>
<li>
<p>Call <code><a href="#vxSetGraphScheduleConfig">vxSetGraphScheduleConfig</a></code> with the parameters as follows:</p>
<div class="ulist">
<ul>
<li>
<p>Set scheduling mode
(<code><a href="#VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL">VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</a></code>
or
<code><a href="#VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO">VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</a></code>).</p>
</li>
<li>
<p>List the graph parameters which will be batch processed.</p>
</li>
<li>
<p>For these parameters specify the list of references that could be
enqueued later for batch processing.</p>
</li>
</ul>
</div>
</li>
<li>
<p>All other data references created in, and associated with the graph are
made specific to the graph. A data reference can be made specific to a
graph by either creating it as virtual or by exporting and re-importing
the graph using the import/export extension.</p>
</li>
<li>
<p>Delays in the graph, if any, MUST be set to auto-age using
<code>vxRegisterAutoAging</code>.</p>
</li>
<li>
<p>Verify the graph using <code>vxVerifyGraph</code>.</p>
</li>
<li>
<p>To execute the graph:</p>
<div class="ulist">
<ul>
<li>
<p>Enqueue the data references which need to be processed in a batch using
<code><a href="#vxGraphParameterEnqueueReadyRef">vxGraphParameterEnqueueReadyRef</a></code>.</p>
</li>
<li>
<p>If scheduling mode was set to
<code><a href="#VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL">VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</a></code>,
use <code>vxScheduleGraph</code> to trigger the batch processing.</p>
</li>
<li>
<p>Use <code>vxWaitGraph</code> to wait for the batch processing to complete.</p>
</li>
<li>
<p>Dequeue the processed data references using
<code><a href="#vxGraphParameterDequeueDoneRef">vxGraphParameterDequeueDoneRef</a></code>.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following code offers an example of the process outlined above using
<code><a href="#VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL">VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</a></code>
scheduling mode.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="comment">/* Max batch size supported by application */</span>
<span class="preprocessor">#define</span> GRAPH_PARAMETER_MAX_BATCH_SIZE  (<span class="integer">10</span>u)

<span class="comment">/* execute graph in a batch-processing manner
 */</span>
<span class="directive">void</span> vx_khr_batch_processing()
{
    vx_uint32 width = <span class="integer">640</span>, height = <span class="integer">480</span>, actual_batch_size;
    vx_context context;
    vx_graph graph;
    vx_image in_refs[GRAPH_PARAMETER_MAX_BATCH_SIZE];
    vx_image out_refs[GRAPH_PARAMETER_MAX_BATCH_SIZE];
    vx_graph_parameter_queue_params_t graph_parameters_queue_params_list[GRAPH_PARAMETER_MAX];

    context = vxCreateContext();
    graph = create_graph(context, width, height);

    create_data_refs(context, in_refs, out_refs, GRAPH_PARAMETER_MAX_BATCH_SIZE,
                     GRAPH_PARAMETER_MAX_BATCH_SIZE, width, height);

    graph_parameters_queue_params_list[<span class="integer">0</span>].graph_parameter_index = GRAPH_PARAMETER_IN;
    graph_parameters_queue_params_list[<span class="integer">0</span>].refs_list_size =
            GRAPH_PARAMETER_MAX_BATCH_SIZE;
    graph_parameters_queue_params_list[<span class="integer">0</span>].refs_list = (vx_reference*)&amp;in_refs[<span class="integer">0</span>];
    graph_parameters_queue_params_list[<span class="integer">1</span>].graph_parameter_index = GRAPH_PARAMETER_OUT;
    graph_parameters_queue_params_list[<span class="integer">1</span>].refs_list_size =
            GRAPH_PARAMETER_MAX_BATCH_SIZE;
    graph_parameters_queue_params_list[<span class="integer">1</span>].refs_list = (vx_reference*)&amp;out_refs[<span class="integer">0</span>];

    vxSetGraphScheduleConfig(graph,
            VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL,
            GRAPH_PARAMETER_MAX,
            graph_parameters_queue_params_list
            );

    vxVerifyGraph(graph);

    <span class="keyword">while</span>(<span class="integer">1</span>)
    {
        <span class="comment">/* read next batch of input and output */</span>
        get_input_output_batch(in_refs, out_refs,
                GRAPH_PARAMETER_MAX_BATCH_SIZE,
                &amp;actual_batch_size);

        vxGraphParameterEnqueueReadyRef(graph,
            GRAPH_PARAMETER_IN,
            (vx_reference*)&amp;in_refs[<span class="integer">0</span>],
            actual_batch_size);

        vxGraphParameterEnqueueReadyRef(
            graph,
            GRAPH_PARAMETER_OUT,
            (vx_reference*)&amp;out_refs[<span class="integer">0</span>],
            actual_batch_size);

        <span class="comment">/* trigger processing of previously enqueued input and output */</span>
        vxScheduleGraph(graph);
        <span class="comment">/* wait for the batch processing to complete */</span>
        vxWaitGraph(graph);

        <span class="comment">/* dequeue the processed input and output data */</span>
        vxGraphParameterDequeueDoneRef(graph,
            GRAPH_PARAMETER_IN,
            (vx_reference*)&amp;in_refs[<span class="integer">0</span>],
            GRAPH_PARAMETER_MAX_BATCH_SIZE,
            &amp;actual_batch_size);

        vxGraphParameterDequeueDoneRef(
            graph,
            GRAPH_PARAMETER_OUT,
            (vx_reference*)&amp;out_refs[<span class="integer">0</span>],
            GRAPH_PARAMETER_MAX_BATCH_SIZE,
            &amp;actual_batch_size);

        <span class="keyword">if</span>(CheckExit())
        {
            <span class="comment">/* App wants to exit, break from main loop */</span>
            <span class="keyword">break</span>;
        }
    }

    vxReleaseGraph(&amp;graph);
    release_data_refs(in_refs, out_refs, GRAPH_PARAMETER_MAX_BATCH_SIZE,
                      GRAPH_PARAMETER_MAX_BATCH_SIZE);
    vxReleaseContext(&amp;context);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec_design_streaming">2.3. Streaming</h3>
<div class="paragraph">
<p>OpenVX APIs allow a user to construct a graph with source nodes and sink
nodes. A source node is a node which internally sources and outputs data to
one or more data references.  A camera capture node is an example of a
source node. A sink node is a node which takes one or more
data references as input but has no output data references. A display
node is an example of a sink node.  For such a graph, graph
execution can be started in streaming mode, wherein, user intervention is
not needed to re-schedule the graph each time.</p>
</div>
<div class="sect3">
<h4 id="sec_sourcesink">2.3.1. Source/sink user nodes</h4>
<div class="paragraph">
<p>Source/sink user nodes are implemented using the existing user kernel OpenVX
API.</p>
</div>
<div class="paragraph">
<p>The following is an example of streaming user source node where the
data references are coming from a vendor specific capture device component:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="directive">static</span> vx_status user_node_source_validate(
                vx_node node,
                <span class="directive">const</span> vx_reference parameters[],
                vx_uint32 num,
                vx_meta_format metas[])
{
    <span class="comment">/* if any verification checks do here */</span>
    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="directive">static</span> vx_status user_node_source_init(
                vx_node node,
                <span class="directive">const</span> vx_reference parameters[],
                vx_uint32 num)
{
    vx_image img = (vx_image)parameters[<span class="integer">0</span>];
    vx_uint32 width, height, i;
    vx_enum df;

    vxQueryImage(img, VX_IMAGE_WIDTH, &amp;width, <span class="keyword">sizeof</span>(vx_uint32));
    vxQueryImage(img, VX_IMAGE_HEIGHT, &amp;height, <span class="keyword">sizeof</span>(vx_uint32));
    vxQueryImage(img, VX_IMAGE_FORMAT, &amp;df, <span class="keyword">sizeof</span>(vx_enum));

    CaptureDeviceOpen(&amp;capture_dev, width, height, df);
    <span class="comment">/* allocate images for priming the capture device.
     * Typically capture devices need some image references to be
     * primed in order to start capturing data.
     */</span>
    CaptureDeviceAllocHandles(capture_dev, capture_refs_prime,
                              MAX_CAPTURE_REFS_PRIME);
    <span class="comment">/* prime image references to capture device */</span>
    <span class="keyword">for</span>(i=<span class="integer">0</span>; i&lt;MAX_CAPTURE_REFS_PRIME; i++)
    {
        CaptureDeviceSwapHandles(capture_dev, capture_refs_prime[i], <span class="predefined-constant">NULL</span>);
    }
    <span class="comment">/* start capturing data to primed image references */</span>
    CaptureDeviceStart(capture_dev);

    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="directive">static</span> vx_status user_node_source_run(
                    vx_node node,
                    vx_reference parameters[],
                    vx_uint32 num)
{
    vx_reference empty_ref, full_ref;

    empty_ref = parameters[<span class="integer">0</span>];

    <span class="comment">/* swap a 'empty' image reference with a captured image reference filled with data
     * If this is one of the first few calls to CaptureDeviceSwapHandle, then full_buf
     * would be one of the image references primed during user_node_source_init
     */</span>
    CaptureDeviceSwapHandles(capture_dev, empty_ref, &amp;full_ref);

    parameters[<span class="integer">0</span>] = full_ref;

    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="directive">static</span> vx_status user_node_source_deinit(
                    vx_node node,
                    <span class="directive">const</span> vx_reference parameters[],
                    vx_uint32 num)
{
    CaptureDeviceStop(capture_dev);
    CaptureDeviceFreeHandles(capture_dev, capture_refs_prime, MAX_CAPTURE_REFS_PRIME);
    CaptureDeviceClose(&amp;capture_dev);

    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="comment">/* Add user node as streaming node */</span>
<span class="directive">static</span> <span class="directive">void</span> user_node_source_add(vx_context context)
{
    vxAllocateUserKernelId(context, &amp;user_node_source_kernel_id);

    user_node_source_kernel = vxAddUserKernel(
            context,
            <span class="string"><span class="delimiter">&quot;</span><span class="content">user_kernel.source</span><span class="delimiter">&quot;</span></span>,
            user_node_source_kernel_id,
            (vx_kernel_f)user_node_source_run,
            <span class="integer">1</span>,
            user_node_source_validate,
            user_node_source_init,
            user_node_source_deinit
            );

    vxAddParameterToKernel(user_node_source_kernel,
        <span class="integer">0</span>,
        VX_OUTPUT,
        VX_TYPE_IMAGE,
        VX_PARAMETER_STATE_REQUIRED
        );

    vxFinalizeKernel(user_node_source_kernel);
}

<span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span>
<span class="directive">static</span> <span class="directive">void</span> user_node_source_remove()
{
    vxRemoveKernel(user_node_source_kernel);
}

<span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span>
<span class="directive">static</span> vx_node user_node_source_create_node(vx_graph graph, vx_image output)
{
    vx_node node = <span class="predefined-constant">NULL</span>;

    node = vxCreateGenericNode(graph, user_node_source_kernel);
    vxSetParameterByIndex(node, <span class="integer">0</span>, (vx_reference)output);

    <span class="keyword">return</span> node;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Likewise, the following is an example of streaming user sink node where the
data references are going to a vendor specific display device component:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span>
<span class="directive">static</span> vx_status user_node_sink_validate(
                    vx_node node,
                    <span class="directive">const</span> vx_reference parameters[],
                    vx_uint32 num,
                    vx_meta_format metas[])
{
    <span class="comment">/* if any verification checks do here */</span>
    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="directive">static</span> vx_status user_node_sink_init(
                    vx_node node,
                    <span class="directive">const</span> vx_reference parameters[],
                    vx_uint32 num)
{
    vx_image img = (vx_image)parameters[<span class="integer">0</span>];
    vx_uint32 width, height;
    vx_enum df;

    vxQueryImage(img, VX_IMAGE_WIDTH, &amp;width, <span class="keyword">sizeof</span>(vx_uint32));
    vxQueryImage(img, VX_IMAGE_HEIGHT, &amp;height, <span class="keyword">sizeof</span>(vx_uint32));
    vxQueryImage(img, VX_IMAGE_FORMAT, &amp;df, <span class="keyword">sizeof</span>(vx_enum));

    DisplayDeviceOpen(&amp;display_dev, width, height, df);
    <span class="comment">/* allocate images for priming the display device.
     * Typically display devices need to retain one or more
     * filled buffers until a new filled buffer is given.
     */</span>
    DisplayDeviceAllocHandles(display_dev, display_refs_prime,
                              MAX_DISPLAY_REFS_PRIME);
    <span class="comment">/* prime image references to display device */</span>
    <span class="keyword">for</span>(i=<span class="integer">0</span>; i&lt;MAX_DISPLAY_REFS_PRIME; i++)
    {
        DisplayDeviceSwapHandles(display_dev, display_refs_prime[i], <span class="predefined-constant">NULL</span>);
    }

    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="directive">static</span> vx_status user_node_sink_run(
                    vx_node node,
                    vx_reference parameters[],
                    vx_uint32 num)
{
    vx_reference new_ref, old_ref;

    new_ref = parameters[<span class="integer">0</span>];

    <span class="comment">/* Swap input reference with reference currently held by display
     * Return parameters to framework to be recycled
     * for subsequent graph execution
     */</span>
    DisplayDeviceSwapHandles(display_dev, new_ref, &amp;old_ref);

    parameters[<span class="integer">0</span>] = old_ref;

    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="directive">static</span> vx_status user_node_sink_deinit(
                    vx_node node,
                    <span class="directive">const</span> vx_reference parameters[],
                    vx_uint32 num)
{
    DisplayDeviceFreeHandles(display_dev, display_refs_prime, MAX_DISPLAY_REFS_PRIME);
    DisplayDeviceClose(&amp;display_dev);

    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="comment">/* Add user node as streaming node */</span>
<span class="directive">static</span> <span class="directive">void</span> user_node_sink_add(vx_context context)
{
    vxAllocateUserKernelId(context, &amp;user_node_sink_kernel_id);

    user_node_sink_kernel = vxAddUserKernel(
            context,
            <span class="string"><span class="delimiter">&quot;</span><span class="content">user_kernel.sink</span><span class="delimiter">&quot;</span></span>,
            user_node_sink_kernel_id,
            (vx_kernel_f)user_node_sink_run,
            <span class="integer">1</span>,
            user_node_sink_validate,
            user_node_sink_init,
            user_node_sink_deinit
            );

    vxAddParameterToKernel(user_node_sink_kernel,
        <span class="integer">0</span>,
        VX_INPUT,
        VX_TYPE_IMAGE,
        VX_PARAMETER_STATE_REQUIRED
        );

    vxFinalizeKernel(user_node_sink_kernel);
}

<span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span>
<span class="directive">static</span> <span class="directive">void</span> user_node_sink_remove()
{
    vxRemoveKernel(user_node_sink_kernel);
}

<span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span>
<span class="directive">static</span> vx_node user_node_sink_create_node(vx_graph graph, vx_image input)
{
    vx_node node = <span class="predefined-constant">NULL</span>;

    node = vxCreateGenericNode(graph, user_node_sink_kernel);
    vxSetParameterByIndex(node, <span class="integer">0</span>, (vx_reference)input);

    <span class="keyword">return</span> node;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In both these examples, the user node &#8220;swaps&#8221; the reference provided by the
implementation with another &#8220;compatible&#8221; reference. This allows user nodes
to implement zero-copy capture and display functions.</p>
</div>
</div>
<div class="sect3">
<h4 id="sec_source_pipeup">2.3.2. Kernel Pipeup</h4>
<div class="paragraph">
<p>In the previous section, the source and sink nodes were responsible for creating
&#8220;compatible&#8221; references for &#8220;swapping&#8221; to implement zero-copy functions.
In this section, we introduce an alternative method wherein the framework
creates the required reference copies, and passes them to the user nodes.</p>
</div>
<div class="paragraph">
<p>This can be done with the addition of the following new attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="#VX_KERNEL_PIPEUP_OUTPUT_DEPTH">VX_KERNEL_PIPEUP_OUTPUT_DEPTH</a></code>, <code><a href="#VX_KERNEL_PIPEUP_INPUT_DEPTH">VX_KERNEL_PIPEUP_INPUT_DEPTH</a></code>: These attributes
may be set when registering the kernel (between the call to vxAddUserKernel and vxFinalizeKernel) using the vxSetKernelAttribute function.  It is used to
notify the framework what the pipeup depth is for this kernel.  <code><a href="#VX_KERNEL_PIPEUP_OUTPUT_DEPTH">VX_KERNEL_PIPEUP_OUTPUT_DEPTH</a></code> is used for source
nodes and <code><a href="#VX_KERNEL_PIPEUP_INPUT_DEPTH">VX_KERNEL_PIPEUP_INPUT_DEPTH</a></code> is used for sink nodes.</p>
</li>
<li>
<p><code><a href="#VX_NODE_STATE">VX_NODE_STATE</a></code>: This attribute may be queried by the execution function of the kernel to determine
which state the node is in.  The options are: <code><a href="#VX_NODE_STATE_STEADY">VX_NODE_STATE_STEADY</a></code> and <code><a href="#VX_NODE_STATE_PIPEUP">VX_NODE_STATE_PIPEUP</a></code>.
If the <code><a href="#VX_KERNEL_PIPEUP_OUTPUT_DEPTH">VX_KERNEL_PIPEUP_OUTPUT_DEPTH</a></code> or <code><a href="#VX_KERNEL_PIPEUP_INPUT_DEPTH">VX_KERNEL_PIPEUP_INPUT_DEPTH</a></code>
attribute has been set to a value greater than 1, then node state
will start in the <code><a href="#VX_NODE_STATE_PIPEUP">VX_NODE_STATE_PIPEUP</a></code> state the first time the graph is executed after vxVerifyGraph is called.</p>
<div class="ulist">
<ul>
<li>
<p>In the case of <code><a href="#VX_KERNEL_PIPEUP_OUTPUT_DEPTH">VX_KERNEL_PIPEUP_OUTPUT_DEPTH</a></code> (source nodes):</p>
<div class="ulist">
<ul>
<li>
<p><code><a href="#VX_NODE_STATE_PIPEUP">VX_NODE_STATE_PIPEUP</a></code> : In this state, the during the first execution of the graph, the framework calls the
execution callback of the node associated with this kernel
(pipeup_depth - 1) times before it 'expects' a valid output and calls nodes dependent on the output.
During this state, the framework provides the same set of input parameters for each call, but provides
different set of output parameters for each call.</p>
</li>
<li>
<p><code><a href="#VX_NODE_STATE_STEADY">VX_NODE_STATE_STEADY</a></code> : After the kernel has been called (pipeup_depth - 1) times, it transitions to
<code><a href="#VX_NODE_STATE_STEADY">VX_NODE_STATE_STEADY</a></code> state.  Kernels which don&#8217;t set the <code><a href="#VX_KERNEL_PIPEUP_OUTPUT_DEPTH">VX_KERNEL_PIPEUP_OUTPUT_DEPTH</a></code> attribute, or set it
to 1, will start in this state. During this state, output parameters returned from the execution callback will be passed to dependent nodes.  If the
kernel had primed its output buffers using the <code><a href="#VX_KERNEL_PIPEUP_OUTPUT_DEPTH">VX_KERNEL_PIPEUP_OUTPUT_DEPTH</a></code> attribute, the kernel may return
a set of output parameters that was given during a previous execution of the callback instead of the ones given
during the current execution.</p>
</li>
</ul>
</div>
</li>
<li>
<p>In the case of <code><a href="#VX_KERNEL_PIPEUP_INPUT_DEPTH">VX_KERNEL_PIPEUP_INPUT_DEPTH</a></code> (sink nodes):</p>
<div class="ulist">
<ul>
<li>
<p><code><a href="#VX_NODE_STATE_PIPEUP">VX_NODE_STATE_PIPEUP</a></code> : In this state, the framework executes the graph
(pipeup_depth - 1) times before it 'expects' any consumed inputs from this node to be returned to the framework.</p>
</li>
<li>
<p><code><a href="#VX_NODE_STATE_STEADY">VX_NODE_STATE_STEADY</a></code> : After the graph has been called (pipeup_depth - 1) times, it transitions to
<code><a href="#VX_NODE_STATE_STEADY">VX_NODE_STATE_STEADY</a></code> state.  Kernels which don&#8217;t set the <code><a href="#VX_KERNEL_PIPEUP_INPUT_DEPTH">VX_KERNEL_PIPEUP_INPUT_DEPTH</a></code> attribute, or set it
to 1, will start in this state. During this state, input parameters returned from the execution callback will be recycled and filled by upstream nodes.  If the
kernel had retained its input buffers using the <code><a href="#VX_KERNEL_PIPEUP_INPUT_DEPTH">VX_KERNEL_PIPEUP_INPUT_DEPTH</a></code> attribute, the kernel may return
a set of input parameters that was given during a previous execution of the callback instead of the ones given
during the current execution.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following is an example of a streaming user source node which uses these attributes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="directive">static</span> vx_status user_node_source_init(
                vx_node node,
                <span class="directive">const</span> vx_reference parameters[],
                vx_uint32 num)
{
    vx_image img = (vx_image)parameters[<span class="integer">0</span>];
    vx_uint32 width, height, i;
    vx_enum df;

    vxQueryImage(img, VX_IMAGE_WIDTH, &amp;width, <span class="keyword">sizeof</span>(vx_uint32));
    vxQueryImage(img, VX_IMAGE_HEIGHT, &amp;height, <span class="keyword">sizeof</span>(vx_uint32));
    vxQueryImage(img, VX_IMAGE_FORMAT, &amp;df, <span class="keyword">sizeof</span>(vx_enum));

    CaptureDeviceOpen(&amp;capture_dev, width, height, df);

    <span class="comment">/* start capturing data (actual start happens later when it gets references) */</span>
    CaptureDeviceStart(capture_dev);

    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="directive">static</span> vx_status user_node_source_run(
                    vx_node node,
                    vx_reference parameters[],
                    vx_uint32 num)
{
    uint32_t state;
    vx_reference empty_ref, full_ref;

    vxQueryNode(node, VX_NODE_STATE, &amp;state, <span class="keyword">sizeof</span>(state));

    empty_ref = parameters[<span class="integer">0</span>];

    <span class="keyword">if</span> (state == VX_NODE_STATE_STEADY)
    {
        <span class="comment">/* swap a 'empty' image reference with a captured image reference filled with data
         * If this is one of the first few calls to CaptureDeviceSwapHandle, then full_buf
         * would be one of the image references primed during VX_NODE_STATE_PIPEUP
         */</span>
        CaptureDeviceSwapHandles(capture_dev, empty_ref, &amp;full_ref);
    }
    <span class="keyword">else</span>
    {
        <span class="comment">/* prime image reference to capture device */</span>
        CaptureDeviceSwapHandles(capture_dev, empty_ref, <span class="predefined-constant">NULL</span>);
    }

    parameters[<span class="integer">0</span>] = full_ref;

    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="directive">static</span> vx_status user_node_source_deinit(
                    vx_node node,
                    <span class="directive">const</span> vx_reference parameters[],
                    vx_uint32 num)
{
    CaptureDeviceStop(capture_dev);
    CaptureDeviceClose(&amp;capture_dev);

    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="comment">/* Add user node as streaming node */</span>
<span class="directive">static</span> <span class="directive">void</span> user_node_source_add(vx_context context)
{
    vx_uint32 pipeup_depth = <span class="integer">3</span>;

    vxAllocateUserKernelId(context, &amp;user_node_source_kernel_id);

    user_node_source_kernel = vxAddUserKernel(
            context,
            <span class="string"><span class="delimiter">&quot;</span><span class="content">user_kernel.source</span><span class="delimiter">&quot;</span></span>,
            user_node_source_kernel_id,
            (vx_kernel_f)user_node_source_run,
            <span class="integer">1</span>,
            user_node_source_validate,
            user_node_source_init,
            user_node_source_deinit
            );

    vxAddParameterToKernel(user_node_source_kernel,
        <span class="integer">0</span>,
        VX_OUTPUT,
        VX_TYPE_IMAGE,
        VX_PARAMETER_STATE_REQUIRED
        );

    vxSetKernelAttribute(user_node_source_kernel, VX_KERNEL_PIPEUP_DEPTH,
                         &amp;pipeup_depth, <span class="keyword">sizeof</span>(pipeup_depth));

    vxFinalizeKernel(user_node_source_kernel);
}

<span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span>
<span class="directive">static</span> <span class="directive">void</span> user_node_source_remove()
{
    vxRemoveKernel(user_node_source_kernel);
}

<span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span>
<span class="directive">static</span> vx_node user_node_source_create_node(vx_graph graph, vx_image output)
{
    vx_node node = <span class="predefined-constant">NULL</span>;

    node = vxCreateGenericNode(graph, user_node_source_kernel);
    vxSetParameterByIndex(node, <span class="integer">0</span>, (vx_reference)output);

    <span class="keyword">return</span> node;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Likewise, the following is an example of streaming user sink node which uses these attributes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span>
<span class="directive">static</span> vx_status user_node_sink_validate(
                    vx_node node,
                    <span class="directive">const</span> vx_reference parameters[],
                    vx_uint32 num,
                    vx_meta_format metas[])
{
    <span class="comment">/* if any verification checks do here */</span>
    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="directive">static</span> vx_status user_node_sink_init(
                    vx_node node,
                    <span class="directive">const</span> vx_reference parameters[],
                    vx_uint32 num)
{
    vx_image img = (vx_image)parameters[<span class="integer">0</span>];
    vx_uint32 width, height;
    vx_enum df;

    vxQueryImage(img, VX_IMAGE_WIDTH, &amp;width, <span class="keyword">sizeof</span>(vx_uint32));
    vxQueryImage(img, VX_IMAGE_HEIGHT, &amp;height, <span class="keyword">sizeof</span>(vx_uint32));
    vxQueryImage(img, VX_IMAGE_FORMAT, &amp;df, <span class="keyword">sizeof</span>(vx_enum));

    DisplayDeviceOpen(&amp;display_dev, width, height, df);

    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="directive">static</span> vx_status user_node_sink_run(
                    vx_node node,
                    vx_reference parameters[],
                    vx_uint32 num)
{
    uint32_t state;
    vx_reference new_ref, old_ref = <span class="predefined-constant">NULL</span>;

    vxQueryNode(node, VX_NODE_STATE, &amp;state, <span class="keyword">sizeof</span>(state));

    new_ref = parameters[<span class="integer">0</span>];

    <span class="keyword">if</span> (state == VX_NODE_STATE_STEADY)
    {
        <span class="comment">/* Swap input reference with reference currently held by display
         * Return parameters to framework to be recycled
         * for subsequent graph execution
         */</span>
        DisplayDeviceSwapHandles(display_dev, new_ref, &amp;old_ref);
    }
    <span class="keyword">else</span>
    {
        <span class="comment">/* Send image reference to display device without getting one in return*/</span>
        DisplayDeviceSwapHandles(display_dev, new_ref, <span class="predefined-constant">NULL</span>);
    }

    parameters[<span class="integer">0</span>] = old_ref;

    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="directive">static</span> vx_status user_node_sink_deinit(
                    vx_node node,
                    <span class="directive">const</span> vx_reference parameters[],
                    vx_uint32 num)
{
    DisplayDeviceClose(&amp;display_dev);

    <span class="keyword">return</span> VX_SUCCESS;
}

<span class="comment">/* Add user node as streaming node */</span>
<span class="directive">static</span> <span class="directive">void</span> user_node_sink_add(vx_context context)
{
    vx_uint32 pipeup_depth = <span class="integer">2</span>;

    vxAllocateUserKernelId(context, &amp;user_node_sink_kernel_id);

    user_node_sink_kernel = vxAddUserKernel(
            context,
            <span class="string"><span class="delimiter">&quot;</span><span class="content">user_kernel.sink</span><span class="delimiter">&quot;</span></span>,
            user_node_sink_kernel_id,
            (vx_kernel_f)user_node_sink_run,
            <span class="integer">1</span>,
            user_node_sink_validate,
            user_node_sink_init,
            user_node_sink_deinit
            );

    vxAddParameterToKernel(user_node_sink_kernel,
        <span class="integer">0</span>,
        VX_INPUT,
        VX_TYPE_IMAGE,
        VX_PARAMETER_STATE_REQUIRED
        );

    vxSetKernelAttribute(user_node_sink_kernel, VX_KERNEL_PIPEUP_DEPTH,
                         &amp;pipeup_depth, <span class="keyword">sizeof</span>(pipeup_depth));

    vxFinalizeKernel(user_node_sink_kernel);
}

<span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span>
<span class="directive">static</span> <span class="directive">void</span> user_node_sink_remove()
{
    vxRemoveKernel(user_node_sink_kernel);
}

<span class="comment">/* Boiler plate code of standard OpenVX API, nothing specific to streaming API */</span>
<span class="directive">static</span> vx_node user_node_sink_create_node(vx_graph graph, vx_image input)
{
    vx_node node = <span class="predefined-constant">NULL</span>;

    node = vxCreateGenericNode(graph, user_node_sink_kernel);
    vxSetParameterByIndex(node, <span class="integer">0</span>, (vx_reference)input);

    <span class="keyword">return</span> node;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec_triggering">2.3.3. Graph streaming application</h4>
<div class="paragraph">
<p>To execute a graph in streaming mode, the following steps need to followed
by an application:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create a graph with source and sink nodes.</p>
</li>
<li>
<p>All data references created in and associated with the graph are made
specific to the graph. A data reference can be made specific to a graph
by either creating it as virtual or by exporting and re-importing the
graph using the import/export extension.</p>
</li>
<li>
<p>Enable the streaming mode of graph execution using
<code><a href="#vxEnableGraphStreaming">vxEnableGraphStreaming</a></code>, optionally setting the trigger node. This
must be called prior to verifying the graph.</p>
</li>
<li>
<p>Verify the graph using <code>vxVerifyGraph</code></p>
</li>
<li>
<p>Start the streaming mode of graph execution using
<code><a href="#vxStartGraphStreaming">vxStartGraphStreaming</a></code></p>
</li>
<li>
<p>Now the graph gets re-scheduled continuously until the user application
calls vxStopGraphStreaming.</p>
<div class="ulist">
<ul>
<li>
<p>The implementation automatically decides the re-schedule trigger
condition.</p>
</li>
</ul>
</div>
</li>
<li>
<p>A user application may need to stop streaming from external control, or
internal feedback.</p>
<div class="ulist">
<ul>
<li>
<p>External control can be the end user changing modes or states, which
prompts the application to call vxStopGraphStreaming.</p>
</li>
<li>
<p>Internal feedback can be due to end of stream or an error condition
detected within its node execution.</p>
<div class="ulist">
<ul>
<li>
<p>In the case of an error condition detected, the user node should
return an appropriate error status. When any error status is detected
by the framework, the framework should trigger the VX_EVENT_NODE_ERROR
event to signal that the node execution has experienced an error.
The application can choose to monitor such an event and take appropriate
action, which may include stopping the continuous graph execution by
calling vxStopGraphStreaming.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>In all cases, the continuous mode of graph execution is stopped at an
implementation-defined logical boundary (e.g. after all previous graph
executions have completed).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example code demonstrates how one can use these APIs in an
application,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="comment">/*
 * Utility API used to create graph with source and sink nodes
 */</span>
<span class="directive">static</span> vx_graph create_graph(vx_context context, vx_uint32 width, vx_uint32 height)
{
    vx_graph graph;
    vx_node n0, n1, node_source, node_sink;
    vx_image in_img, tmp_img, out_img;
    vx_int32 shift;
    vx_scalar s0;

    graph = vxCreateGraph(context);

    in_img = vxCreateVirtualImage(graph, width, height, VX_DF_IMAGE_RGB);

    <span class="comment">/* create source node */</span>
    node_source = user_node_source_create_node(graph, in_img);

    <span class="comment">/* Enable streaming */</span>
    vxEnableGraphStreaming(graph, node_source);

    <span class="comment">/* create intermediate virtual image */</span>
    tmp_img = vxCreateVirtualImage(graph, <span class="integer">0</span>, <span class="integer">0</span>, VX_DF_IMAGE_VIRT);

    <span class="comment">/* create first node, input is NULL since this will be made as graph parameter */</span>
    n0 = vxChannelExtractNode(graph, in_img, VX_CHANNEL_G, tmp_img);

    out_img = vxCreateVirtualImage(graph, <span class="integer">0</span>, <span class="integer">0</span>, VX_DF_IMAGE_S16);

    <span class="comment">/* create a scalar object required for second node */</span>
    shift = <span class="integer">8</span>;
    s0 = vxCreateScalar(context, VX_TYPE_INT32, &amp;shift);

    <span class="comment">/* create second node, output is NULL since this will be made as graph parameter
     */</span>
    n1 = vxConvertDepthNode(graph, tmp_img, out_img, VX_CONVERT_POLICY_SATURATE, s0);

    <span class="comment">/* create sink node */</span>
    node_sink = user_node_sink_create_node(graph, out_img);

    vxReleaseScalar(&amp;s0);
    vxReleaseNode(&amp;n0);
    vxReleaseNode(&amp;n1);
    vxReleaseNode(&amp;node_source);
    vxReleaseNode(&amp;node_sink);
    vxReleaseImage(&amp;tmp_img);
    vxReleaseImage(&amp;in_img);
    vxReleaseImage(&amp;out_img);

    <span class="keyword">return</span> graph;
}

<span class="directive">void</span> vx_khr_streaming_sample()
{
    vx_uint32 width = <span class="integer">640</span>, height = <span class="integer">480</span>;
    vx_context context = vxCreateContext();
    vx_graph graph;

    <span class="comment">/* add user kernels to context */</span>
    user_node_source_add(context);
    user_node_sink_add(context);

    graph = create_graph(context, width, height);

    vxVerifyGraph(graph);

    <span class="comment">/* execute graph in streaming mode,
     * graph is retriggered when input reference is consumed by a graph execution
     */</span>
    vxStartGraphStreaming(graph);

    <span class="comment">/* wait until user wants to exit */</span>
    WaitExit();

    <span class="comment">/* stop graph streaming */</span>
    vxStopGraphStreaming(graph);

    vxReleaseGraph(&amp;graph);

    <span class="comment">/* remove user kernels from context */</span>
    user_node_source_remove();
    user_node_sink_remove();

    vxReleaseContext(&amp;context);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec_design_event">2.4. Event handling</h3>
<div class="paragraph">
<p>Event handling APIs allow users to register conditions on a graph, based on
which events are generated by the implementation. User applications can then
wait for events and take appropriate action based on the received event.
User-specified events can also be generated by the application so that all
events can be handled at a centralized location. This simplifies the
application state machine, and in the case of graph pipelining, it allows
optimized scheduling of the graph.</p>
</div>
<div class="sect3">
<h4 id="sec_limitations">2.4.1. Motivation for event handling</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Pipelining without events would need blocking calls on the data
producers, consumers, and the graph itself. If there were multiple
graphs or multiple data producers/consumers pipelined at different
rates, one can see how the application logic can easily get complicated.</p>
</li>
<li>
<p>Applications need a mechanism to allow input references to be dequeued
before the full graph execution is completed. This allows
implementations to have larger pipeline depths but at the same time have
fewer queued references at a graph parameter.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="sec_using_event_handling">2.4.2. Event handling application</h4>
<div class="paragraph">
<p>Event handling APIs allow user the flexibility to do early dequeue of input
references, and late enqueue of output references. It enables applications
to effectively block at a single centralized location for both
implementation-generated events as well as user-generated events. Event
handling allows the graph to produce events which can then be used by the
application. For example, if the thread had an event handler that is used to
manage multiple graphs, consumers, and producers, then the events produced
by the implementation could feed into this manager. Likewise, early dequeue
of input can be achieved, if the event handler could use the graph parameter
consumed events to trigger calls to <code><a href="#vxGraphParameterEnqueueReadyRef">vxGraphParameterEnqueueReadyRef</a></code>,
<code><a href="#vxGraphParameterDequeueDoneRef">vxGraphParameterDequeueDoneRef</a></code>.</p>
</div>
<div class="paragraph">
<p>The following code offers an example of the event handling.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="preprocessor">#define</span> INPUT_CONSUMED  <span class="integer">1</span>
<span class="preprocessor">#define</span> OUTPUT_FILLED   <span class="integer">2</span>

<span class="comment">/* Utility API to clear any pending events */</span>
<span class="directive">static</span> <span class="directive">void</span> clear_pending_events(vx_context context)
{
    vx_event_t event;

    <span class="comment">/* do not block */</span>
    <span class="keyword">while</span>(vxWaitEvent(context, &amp;event, vx_true_e)==VX_SUCCESS)
        ;
}

<span class="comment">/* execute graph in a pipelined manner with events used
 * to schedule the graph execution
 */</span>
<span class="directive">void</span> vx_khr_pipelining_with_events()
{
    vx_uint32 width = <span class="integer">640</span>, height = <span class="integer">480</span>, i;
    vx_context context;
    vx_graph graph;
    vx_image in_refs[GRAPH_PARAMETER_IN_MAX_REFS];
    vx_image out_refs[GRAPH_PARAMETER_IN_MAX_REFS];
    vx_image in_img, out_img;
    vx_graph_parameter_queue_params_t graph_parameters_queue_params_list[GRAPH_PARAMETER_MAX];

    context = vxCreateContext();
    graph = create_graph(context, width, height);

    create_data_refs(context, in_refs, out_refs, GRAPH_PARAMETER_IN_MAX_REFS,
                     GRAPH_PARAMETER_OUT_MAX_REFS, width, height);

    graph_parameters_queue_params_list[<span class="integer">0</span>].graph_parameter_index = GRAPH_PARAMETER_IN;
    graph_parameters_queue_params_list[<span class="integer">0</span>].refs_list_size =
                    GRAPH_PARAMETER_IN_MAX_REFS;
    graph_parameters_queue_params_list[<span class="integer">0</span>].refs_list = (vx_reference*)&amp;in_refs[<span class="integer">0</span>];
    graph_parameters_queue_params_list[<span class="integer">1</span>].graph_parameter_index = GRAPH_PARAMETER_OUT;
    graph_parameters_queue_params_list[<span class="integer">1</span>].refs_list_size =
                    GRAPH_PARAMETER_OUT_MAX_REFS;
    graph_parameters_queue_params_list[<span class="integer">1</span>].refs_list = (vx_reference*)&amp;out_refs[<span class="integer">0</span>];

    vxSetGraphScheduleConfig(graph,
            VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO,
            GRAPH_PARAMETER_MAX,
            graph_parameters_queue_params_list
            );

    <span class="comment">/* register events for input consumed and output consumed */</span>
    vxRegisterEvent((vx_reference)graph, VX_EVENT_GRAPH_PARAMETER_CONSUMED,
                    GRAPH_PARAMETER_IN, INPUT_CONSUMED);
    vxRegisterEvent((vx_reference)graph, VX_EVENT_GRAPH_PARAMETER_CONSUMED,
                    GRAPH_PARAMETER_OUT, OUTPUT_FILLED);

    vxVerifyGraph(graph);

    <span class="comment">/* disable events generation */</span>
    vxEnableEvents(context);
    <span class="comment">/* clear pending events.
     * Not strictly required but- it's a good practice to clear any
     * pending events from last execution before waiting on new events */</span>
    clear_pending_events(context);

    <span class="comment">/* enqueue input and output to trigger graph */</span>
    <span class="keyword">for</span>(i=<span class="integer">0</span>; i&lt;GRAPH_PARAMETER_IN_MAX_REFS; i++)
    {
        enqueue_input(graph, width, height, in_refs[i]);
    }
    <span class="keyword">for</span>(i=<span class="integer">0</span>; i&lt;GRAPH_PARAMETER_OUT_MAX_REFS; i++)
    {
        enqueue_output(graph, out_refs[i]);
    }

    <span class="keyword">while</span>(<span class="integer">1</span>)
    {
        vx_event_t event;

        <span class="comment">/* wait for events, block until event is received */</span>
        vxWaitEvent(context, &amp;event, vx_false_e);

        <span class="comment">/* event for input data ready for recycling, i.e early input release */</span>
        <span class="keyword">if</span>(event.app_value == INPUT_CONSUMED )
        {
            <span class="comment">/* dequeue consumed input, fill new data and re-enqueue */</span>
            dequeue_input(graph, &amp;in_img);
            enqueue_input(graph, width, height, in_img);
        }
        <span class="keyword">else</span>
        <span class="comment">/* event for output data ready for recycling, i.e output release */</span>
        <span class="keyword">if</span>(event.app_value == OUTPUT_FILLED )
        {
            <span class="comment">/* dequeue output reference, consume generated data and
             * re-enqueue output reference
             */</span>
            dequeue_output(graph, width, height, &amp;out_img);
            enqueue_output(graph, out_img);
        }
        <span class="keyword">else</span>
        <span class="keyword">if</span>(event.type == VX_EVENT_USER &amp;&amp; event.event_info.user_event.user_event_id
                                               == <span class="hex">0xDEADBEEF</span> <span class="comment">/* app code for exit */</span>
            )
        {
            <span class="comment">/* App wants to exit, break from main loop */</span>
            <span class="keyword">break</span>;
        }
    }

    <span class="comment">/*
     * wait until all previous graph executions have completed
     */</span>
    vxWaitGraph(graph);

    <span class="comment">/* flush output references, only required if need to consume last few references
     */</span>
    <span class="keyword">do</span> {
      dequeue_output(graph, width, height, &amp;out_img);
    } <span class="keyword">while</span>(out_img!=<span class="predefined-constant">NULL</span>);

    vxReleaseGraph(&amp;graph);
    release_data_refs(in_refs, out_refs, GRAPH_PARAMETER_IN_MAX_REFS,
                      GRAPH_PARAMETER_OUT_MAX_REFS);

    <span class="comment">/* disable events generation */</span>
    vxDisableEvents(context);
    <span class="comment">/* clear pending events.
     * Not strictly required but- it's a good practice to clear any
     * pending events from last execution before exiting application */</span>
    clear_pending_events(context);

    vxReleaseContext(&amp;context);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="module_documentation">3. Module Documentation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="group_pipelining">3.1. Pipelining and Batch Processing</h3>
<div class="paragraph">
<p><strong>Data Structures</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="#vx_graph_parameter_queue_params_t">vx_graph_parameter_queue_params_t</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Enumerations</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="#vx_graph_schedule_mode_enum_e">vx_graph_schedule_mode_enum_e</a></code></p>
</li>
<li>
<p><code><a href="#vx_graph_schedule_mode_type_e">vx_graph_schedule_mode_type_e</a></code></p>
</li>
<li>
<p><code><a href="#vx_graph_attribute_pipelining_e">vx_graph_attribute_pipelining_e</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Functions</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="#vxSetGraphScheduleConfig">vxSetGraphScheduleConfig</a></code></p>
</li>
<li>
<p><code><a href="#vxGraphParameterEnqueueReadyRef">vxGraphParameterEnqueueReadyRef</a></code></p>
</li>
<li>
<p><code><a href="#vxGraphParameterDequeueDoneRef">vxGraphParameterDequeueDoneRef</a></code></p>
</li>
<li>
<p><code><a href="#vxGraphParameterCheckDoneRef">vxGraphParameterCheckDoneRef</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This section lists the APIs required for graph pipelining and batch
processing.</p>
</div>
<div class="sect3">
<h4 id="_data_structures">3.1.1. Data Structures</h4>
<div class="sect4">
<h5 id="_vx_graph_parameter_queue_params_t">vx_graph_parameter_queue_params_t</h5>
<div class="paragraph">
<p>Queueing parameters for a specific graph parameter.</p>
</div>
<div id="vx_graph_parameter_queue_params_t" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">typedef</span> <span class="keyword">struct</span> _vx_graph_parameter_queue_params_t {
    uint32_t          graph_parameter_index;
    vx_uint32         refs_list_size;
    vx_reference *    refs_list;
} vx_graph_parameter_queue_params_t;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>graph_parameter_index</em> -   Index of graph parameter to which these properties apply</p>
</li>
<li>
<p><em>refs_list_size</em> -   Number of elements in array <em>refs_list</em></p>
</li>
<li>
<p><em>refs_list</em> -   Array of references that could be enqueued at a later point of time at this graph parameter</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <code><a href="#vxSetGraphScheduleConfig">vxSetGraphScheduleConfig</a></code> for additional details.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_enumerations">3.1.2. Enumerations</h4>
<div class="sect4">
<h5 id="_vx_graph_schedule_mode_enum_e">vx_graph_schedule_mode_enum_e</h5>
<div class="paragraph">
<p>Extra enums.</p>
</div>
<div id="vx_graph_schedule_mode_enum_e" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">enum</span> vx_graph_schedule_mode_enum_e {
    VX_ENUM_GRAPH_SCHEDULE_MODE_TYPE = <span class="hex">0x21</span>,
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Enumerator</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="VX_ENUM_GRAPH_SCHEDULE_MODE_TYPE"></a>
<code>VX_ENUM_GRAPH_SCHEDULE_MODE_TYPE</code> - Graph schedule mode type
enumeration.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vx_graph_schedule_mode_type_e">vx_graph_schedule_mode_type_e</h5>
<div class="paragraph">
<p>Type of graph scheduling mode.</p>
</div>
<div id="vx_graph_schedule_mode_type_e" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">enum</span> vx_graph_schedule_mode_type_e {
    VX_GRAPH_SCHEDULE_MODE_NORMAL = ((( VX_ID_KHRONOS ) &lt;&lt; <span class="integer">20</span>) | ( VX_ENUM_GRAPH_SCHEDULE_MODE_TYPE &lt;&lt; <span class="integer">12</span>)) + <span class="hex">0x0</span>,
    VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO = ((( VX_ID_KHRONOS ) &lt;&lt; <span class="integer">20</span>) | ( VX_ENUM_GRAPH_SCHEDULE_MODE_TYPE &lt;&lt; <span class="integer">12</span>)) + <span class="hex">0x1</span>,
    VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL = ((( VX_ID_KHRONOS ) &lt;&lt; <span class="integer">20</span>) | ( VX_ENUM_GRAPH_SCHEDULE_MODE_TYPE &lt;&lt; <span class="integer">12</span>)) + <span class="hex">0x2</span>,
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <code><a href="#vxSetGraphScheduleConfig">vxSetGraphScheduleConfig</a></code> and <code><a href="#vxGraphParameterEnqueueReadyRef">vxGraphParameterEnqueueReadyRef</a></code>
for details about each mode.</p>
</div>
<div class="paragraph">
<p><strong>Enumerator</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="VX_GRAPH_SCHEDULE_MODE_NORMAL"></a>
<code>VX_GRAPH_SCHEDULE_MODE_NORMAL</code> - Schedule graph in non-queueing mode.</p>
</li>
<li>
<p><a id="VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO"></a>
<code>VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</code> - Schedule graph in queueing mode with
auto scheduling.</p>
</li>
<li>
<p><a id="VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL"></a>
<code>VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</code> - Schedule graph in queueing mode
with manual scheduling.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vx_graph_attribute_pipelining_e">vx_graph_attribute_pipelining_e</h5>
<div class="paragraph">
<p>The graph attributes added by this extension.</p>
</div>
<div id="vx_graph_attribute_pipelining_e" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">enum</span> vx_graph_attribute_pipelining_e {
    VX_GRAPH_SCHEDULE_MODE = VX_ATTRIBUTE_BASE(VX_ID_KHRONOS, VX_TYPE_GRAPH) + <span class="hex">0x5</span>,
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Enumerator</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="VX_GRAPH_SCHEDULE_MODE"></a>
<code>VX_GRAPH_SCHEDULE_MODE</code> - Returns the schedule mode of a graph.
Read-only. Use a <code>vx_enum</code> parameter. See
<code><a href="#vx_graph_schedule_mode_type_e">vx_graph_schedule_mode_type_e</a></code> enum.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_functions">3.1.3. Functions</h4>
<div class="sect4">
<h5 id="_vxsetgraphscheduleconfig">vxSetGraphScheduleConfig</h5>
<div class="paragraph">
<p>Sets the graph scheduler config.</p>
</div>
<div id="vxSetGraphScheduleConfig" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">vx_status vxSetGraphScheduleConfig(
    vx_graph                                    graph,
    vx_enum                                     graph_schedule_mode,
    vx_uint32                                   graph_parameters_list_size,
    <span class="directive">const</span> vx_graph_parameter_queue_params_t     graph_parameters_queue_params_list[]);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This API is used to set the graph scheduler config to allow user to schedule
multiple instances of a graph for execution.</p>
</div>
<div class="paragraph">
<p>For legacy applications that don&#8217;t need graph pipelining or batch
processing, this API need not be used.</p>
</div>
<div class="paragraph">
<p>Using this API, the application specifies the graph schedule mode, as well
as queueing parameters for all graph parameters that need to allow
enqueueing of references. A single monolithic API is provided instead of
discrete APIs, since this allows the implementation to get all information
related to scheduling in one shot and then optimize the subsequent graph
scheduling based on this information. <strong>This API MUST be called before graph
verify</strong>, since in this case it allows implementations the opportunity to
optimize resources based on information provided by the application.</p>
</div>
<div class="paragraph">
<p><em>graph_schedule_mode</em> selects how input and output references are provided
to a graph and how the next graph schedule is triggered by an
implementation.</p>
</div>
<div class="paragraph">
<p>Below scheduling modes are supported:</p>
</div>
<div class="paragraph">
<p>When graph schedule mode is <code><a href="#VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO">VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO</a></code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Application needs to explicitly call <code>vxVerifyGraph</code> before enqueing
data references</p>
</li>
<li>
<p>Application should not call <code>vxScheduleGraph</code> or <code>vxProcessGraph</code></p>
</li>
<li>
<p>When enough references are enqueued at various graph parameters, the
implementation could trigger the next graph schedule.</p>
</li>
<li>
<p>Here, not all graph parameters need to have enqueued references for a
graph schedule to begin. An implementation is expected to execute the
graph as much as possible until an enqueued reference is not available at
which time it will stall the graph until the reference becomes
available. This allows application to schedule a graph even when all
parameters references are not yet available, i.e do a &#8220;late&#8221; enqueue.
However, exact behaviour is implementation specific.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When graph schedule mode is <code><a href="#VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL">VX_GRAPH_SCHEDULE_MODE_QUEUE_MANUAL</a></code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Application needs to explicitly call <code>vxScheduleGraph</code></p>
</li>
<li>
<p>Application should not call <code>vxProcessGraph</code></p>
</li>
<li>
<p>References for all graph parameters of the graph needs to enqueued
before <code>vxScheduleGraph</code> is called on the graph else an error is returned
by <code>vxScheduleGraph</code></p>
</li>
<li>
<p>Application can enqueue multiple references at the same graph parameter.
When <code>vxScheduleGraph</code> is called, all enqueued references get processed in
a &#8220;batch&#8221;.</p>
</li>
<li>
<p>User can use <code>vxWaitGraph</code> to wait for the previous <code>vxScheduleGraph</code> to
complete.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When graph schedule mode is <code><a href="#VX_GRAPH_SCHEDULE_MODE_NORMAL">VX_GRAPH_SCHEDULE_MODE_NORMAL</a></code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>graph_parameters_list_size</em> MUST be 0 and</p>
</li>
<li>
<p><em>graph_parameters_queue_params_list</em> MUST be NULL</p>
</li>
<li>
<p>This mode is equivalent to non-queueing scheduling mode as defined by
OpenVX v1.2 and earlier.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default all graphs are in <code>VX_GRAPH_SCHEDULE_MODE_NORMAL</code> mode until this
API is called.</p>
</div>
<div class="paragraph">
<p><em>graph_parameters_queue_params_list</em> allows to specify below information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For the graph parameter index that is specified, it enables queueing
mode of operation</p>
</li>
<li>
<p>Further it allows the application to specify the list of references that
it could later enqueue at this graph parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For graph parameters listed in <em>graph_parameters_queue_params_list</em>,
application MUST use <code><a href="#vxGraphParameterEnqueueReadyRef">vxGraphParameterEnqueueReadyRef</a></code> to set references
at the graph parameter. Using other data access API&#8217;s on these parameters or
corresponding data objects will return an error. For graph parameters not
listed in <em>graph_parameters_queue_params_list</em> application MUST use the
<code>vxSetGraphParameterByIndex</code> to set the reference at the graph parameter.
Using other data access API&#8217;s on these parameters or corresponding data
objects will return an error.</p>
</div>
<div class="paragraph">
<p>This API also allows application to provide a list of references which could
be later enqueued at the graph parameter. This allows implementation to do
meta-data checking up front rather than during each reference enqueue.</p>
</div>
<div class="paragraph">
<p>When this API is called before <code>vxVerifyGraph</code>, the <em>refs_list</em> field can be
NULL, if the reference handles are not available yet at the application.
However <em>refs_list_size</em> MUST always be specified by the application.
Application can call <code><a href="#vxSetGraphScheduleConfig">vxSetGraphScheduleConfig</a></code> again after verify graph
with all parameters remaining the same except with <em>refs_list</em> field
providing the list of references that can be enqueued at the graph
parameter.</p>
</div>
<div class="paragraph">
<p><strong>Parameters</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[in]</code> <em>graph</em> - Graph reference</p>
</li>
<li>
<p><code>[in]</code> <em>graph_schedule_mode</em> - Graph schedule mode. See
<code><a href="#vx_graph_schedule_mode_type_e">vx_graph_schedule_mode_type_e</a></code></p>
</li>
<li>
<p><code>[in]</code> <em>graph_parameters_list_size</em> - Number of elements in
<em>graph_parameters_queue_params_list</em></p>
</li>
<li>
<p><code>[in]</code> <em>graph_parameters_queue_params_list</em> - Array containing queuing
properties at graph parameters that need to support queueing.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Returns:</strong> A <code>vx_status_e</code> enumeration.</p>
</div>
<div class="paragraph">
<p><strong>Return Values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VX_SUCCESS</code> - No errors.</p>
</li>
<li>
<p><code>VX_ERROR_INVALID_REFERENCE</code> - <em>graph</em> is not a valid reference</p>
</li>
<li>
<p><code>VX_ERROR_INVALID_PARAMETERS</code> - Invalid graph parameter queueing
parameters</p>
</li>
<li>
<p><code>VX_FAILURE</code> - Any other failure.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vxgraphparameterenqueuereadyref">vxGraphParameterEnqueueReadyRef</h5>
<div class="paragraph">
<p>Enqueues new references into a graph parameter for processing.</p>
</div>
<div id="vxGraphParameterEnqueueReadyRef" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">vx_status vxGraphParameterEnqueueReadyRef(
    vx_graph                                    graph,
    vx_uint32                                   graph_parameter_index,
    vx_reference *                              refs,
    vx_uint32                                   num_refs);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This new reference will take effect on the next graph schedule.</p>
</div>
<div class="paragraph">
<p>In case of a graph parameter which is input to a graph, this function
provides a data reference with new input data to the graph. In case of a
graph parameter which is not input to a graph, this function provides a
&#8220;empty&#8221; reference into which a graph execution can write new data into.</p>
</div>
<div class="paragraph">
<p>This function essentially transfers ownership of the reference from the
application to the graph.</p>
</div>
<div class="paragraph">
<p>User MUST use <code><a href="#vxGraphParameterDequeueDoneRef">vxGraphParameterDequeueDoneRef</a></code> to get back the processed
or consumed references.</p>
</div>
<div class="paragraph">
<p>The references that are enqueued MUST be the references listed during
<code><a href="#vxSetGraphScheduleConfig">vxSetGraphScheduleConfig</a></code>. If a reference outside this list is provided
then behaviour is undefined.</p>
</div>
<div class="paragraph">
<p><strong>Parameters</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[in]</code> <em>graph</em> - Graph reference</p>
</li>
<li>
<p><code>[in]</code> <em>graph_parameter_index</em> - Graph parameter index</p>
</li>
<li>
<p><code>[in]</code> <em>refs</em> - The array of references to enqueue into the graph parameter</p>
</li>
<li>
<p><code>[in]</code> <em>num_refs</em> - Number of references to enqueue</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Returns:</strong> A <code>vx_status_e</code> enumeration.</p>
</div>
<div class="paragraph">
<p><strong>Return Values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VX_SUCCESS</code> - No errors.</p>
</li>
<li>
<p><code>VX_ERROR_INVALID_REFERENCE</code> - <em>graph</em> is not a valid reference OR
reference is not a valid reference</p>
</li>
<li>
<p><code>VX_ERROR_INVALID_PARAMETERS</code> - <em>graph_parameter_index</em> is NOT a
valid graph parameter index</p>
</li>
<li>
<p><code>VX_FAILURE</code> - Reference could not be enqueued.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vxgraphparameterdequeuedoneref">vxGraphParameterDequeueDoneRef</h5>
<div class="paragraph">
<p>Dequeues &#8220;consumed&#8221; references from a graph parameter.</p>
</div>
<div id="vxGraphParameterDequeueDoneRef" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">vx_status vxGraphParameterDequeueDoneRef(
    vx_graph                                    graph,
    vx_uint32                                   graph_parameter_index,
    vx_reference *                              refs,
    vx_uint32                                   max_refs,
    vx_uint32 *                                 num_refs);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function dequeues references from a graph parameter of a graph. The
reference that is dequeued is a reference that had been previously enqueued
into a graph, and after subsequent graph execution is considered as
processed or consumed by the graph. This function essentially transfers
ownership of the reference from the graph to the application.</p>
</div>
<div class="paragraph">
<p><strong>IMPORTANT</strong> : This API will block until at least one reference is dequeued.</p>
</div>
<div class="paragraph">
<p>In case of a graph parameter which is input to a graph, this function
provides a &#8220;consumed&#8221; buffer to the application so that new input data can
filled and later enqueued to the graph. In case of a graph parameter which
is not input to a graph, this function provides a reference filled with new
data based on graph execution. User can then use this newly generated data
with their application. Typically when this new data is consumed by the
application the &#8220;empty&#8221; reference is again enqueued to the graph.</p>
</div>
<div class="paragraph">
<p>This API returns an array of references up to a maximum of <em>max_refs</em>.
Application MUST ensure the array pointer (<em>refs</em>) passed as input can hold
<em>max_refs</em>. <em>num_refs</em> is actual number of references returned and will be
less than or equal to <em>max_refs</em>.</p>
</div>
<div class="paragraph">
<p><strong>Parameters</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[in]</code> <em>graph</em> - Graph reference</p>
</li>
<li>
<p><code>[in]</code> <em>graph_parameter_index</em> - Graph parameter index</p>
</li>
<li>
<p><code>[in]</code> <em>refs</em> - Pointer to an array of max elements <em>max_refs</em></p>
</li>
<li>
<p><code>[out]</code> <em>refs</em> - Dequeued references filled in the array</p>
</li>
<li>
<p><code>[in]</code> <em>max_refs</em> - Max number of references to dequeue</p>
</li>
<li>
<p><code>[out]</code> <em>num_refs</em> - Actual number of references dequeued.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Returns:</strong> A <code>vx_status_e</code> enumeration.</p>
</div>
<div class="paragraph">
<p><strong>Return Values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VX_SUCCESS</code> - No errors.</p>
</li>
<li>
<p><code>VX_ERROR_INVALID_REFERENCE</code> - <em>graph</em> is not a valid reference</p>
</li>
<li>
<p><code>VX_ERROR_INVALID_PARAMETERS</code> - <em>graph_parameter_index</em> is NOT a
valid graph parameter index</p>
</li>
<li>
<p><code>VX_FAILURE</code> - Reference could not be dequeued.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vxgraphparametercheckdoneref">vxGraphParameterCheckDoneRef</h5>
<div class="paragraph">
<p>Checks and returns the number of references that are ready for dequeue.</p>
</div>
<div id="vxGraphParameterCheckDoneRef" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">vx_status vxGraphParameterCheckDoneRef(
    vx_graph                                    graph,
    vx_uint32                                   graph_parameter_index,
    vx_uint32 *                                 num_refs);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function checks the number of references that can be dequeued and
returns the value to the application.</p>
</div>
<div class="paragraph">
<p>See also <code><a href="#vxGraphParameterDequeueDoneRef">vxGraphParameterDequeueDoneRef</a></code>.</p>
</div>
<div class="paragraph">
<p><strong>Parameters</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[in]</code> <em>graph</em> - Graph reference</p>
</li>
<li>
<p><code>[in]</code> <em>graph_parameter_index</em> - Graph parameter index</p>
</li>
<li>
<p><code>[out]</code> <em>num_refs</em> - Number of references that can be dequeued using</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Returns:</strong> A <code>vx_status_e</code> enumeration.</p>
</div>
<div class="paragraph">
<p><strong>Return Values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VX_SUCCESS</code> - No errors.</p>
</li>
<li>
<p><code>VX_ERROR_INVALID_REFERENCE</code> - <em>graph</em> is not a valid reference</p>
</li>
<li>
<p><code>VX_ERROR_INVALID_PARAMETERS</code> - <em>graph_parameter_index</em> is NOT a valid
graph parameter index</p>
</li>
<li>
<p><code>VX_FAILURE</code> - Any other failure.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="group_streaming">3.2. Streaming</h3>
<div class="paragraph">
<p><strong>Enumerations</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="#vx_node_state_enum_e">vx_node_state_enum_e</a></code></p>
</li>
<li>
<p><code><a href="#vx_node_state_e">vx_node_state_e</a></code></p>
</li>
<li>
<p><code><a href="#vx_node_attribute_streaming_e">vx_node_attribute_streaming_e</a></code></p>
</li>
<li>
<p><code><a href="#vx_kernel_attribute_streaming_e">vx_kernel_attribute_streaming_e</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Functions</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="#vxEnableGraphStreaming">vxEnableGraphStreaming</a></code></p>
</li>
<li>
<p><code><a href="#vxStartGraphStreaming">vxStartGraphStreaming</a></code></p>
</li>
<li>
<p><code><a href="#vxStopGraphStreaming">vxStopGraphStreaming</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This section lists the APIs required for graph streaming.</p>
</div>
<div class="sect3">
<h4 id="_enumerations_2">3.2.1. Enumerations</h4>
<div class="sect4">
<h5 id="_vx_node_state_enum_e">vx_node_state_enum_e</h5>
<div class="paragraph">
<p>Extra enums.</p>
</div>
<div id="vx_node_state_enum_e" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">enum</span> vx_node_state_enum_e {
    VX_ENUM_NODE_STATE_TYPE = <span class="hex">0x23</span>,
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Enumerator</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="VX_ENUM_NODE_STATE_TYPE"></a>
<code>VX_ENUM_NODE_STATE_TYPE</code> - Node state type enumeration.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vx_node_state_e">vx_node_state_e</h5>
<div class="paragraph">
<p>Node state</p>
</div>
<div id="vx_node_state_e" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">enum</span> vx_node_state_e {
    VX_NODE_STATE_STEADY = ((( VX_ID_KHRONOS ) &lt;&lt; <span class="integer">20</span>) | ( VX_ENUM_NODE_STATE_TYPE &lt;&lt; <span class="integer">12</span>)) + <span class="hex">0x0</span>,
    VX_NODE_STATE_PIPEUP = ((( VX_ID_KHRONOS ) &lt;&lt; <span class="integer">20</span>) | ( VX_ENUM_NODE_STATE_TYPE &lt;&lt; <span class="integer">12</span>)) + <span class="hex">0x1</span>,
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Enumerator</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="VX_NODE_STATE_STEADY"></a>
<code>VX_NODE_STATE_STEADY</code> - Node is in steady state (output expected for each invocation).</p>
</li>
<li>
<p><a id="VX_NODE_STATE_PIPEUP"></a>
<code>VX_NODE_STATE_PIPEUP</code> - Node is in pipeup state (output not expected for each invocation).</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vx_node_attribute_streaming_e">vx_node_attribute_streaming_e</h5>
<div class="paragraph">
<p>The node attributes added by this extension.</p>
</div>
<div id="vx_node_attribute_streaming_e" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">enum</span> vx_node_attribute_streaming_e {
    VX_NODE_STATE = ((( VX_ID_KHRONOS ) &lt;&lt; <span class="integer">20</span>) | ( VX_TYPE_NODE &lt;&lt; <span class="integer">12</span>)) + <span class="hex">0x9</span>,
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Enumerator</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="VX_NODE_STATE"></a>
<code>VX_NODE_STATE</code> - Queries the state of the node.
Read-only. Use a <code>vx_enum</code> parameter. See
<code><a href="#vx_node_state_e">vx_node_state_e</a></code> enum.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vx_kernel_attribute_streaming_e">vx_kernel_attribute_streaming_e</h5>
<div class="paragraph">
<p>The kernel attributes added by this extension.</p>
</div>
<div id="vx_kernel_attribute_streaming_e" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">enum</span> vx_kernel_attribute_streaming_e {
    VX_KERNEL_PIPEUP_OUTPUT_DEPTH = ((( VX_ID_KHRONOS ) &lt;&lt; <span class="integer">20</span>) | ( VX_TYPE_KERNEL &lt;&lt; <span class="integer">12</span>)) + <span class="hex">0x4</span>,
    VX_KERNEL_PIPEUP_INPUT_DEPTH = ((( VX_ID_KHRONOS ) &lt;&lt; <span class="integer">20</span>) | ( VX_TYPE_KERNEL &lt;&lt; <span class="integer">12</span>)) + <span class="hex">0x5</span>,
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Enumerator</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="VX_KERNEL_PIPEUP_OUTPUT_DEPTH"></a>
<code>VX_KERNEL_PIPEUP_OUTPUT_DEPTH</code> - The pipeup depth required by the kernel.
 This is called by kernels that need to be primed with multiple output buffers before it can
 begin to return them.  A typical use case for this is a source node which needs to provide and
 retain multiple empty buffers to a camera driver to fill.  The first time the graph is executed
 after vxVerifyGraph is called, the framework calls the node associated with this kernel
 (pipeup_output_depth - 1) times before 'expecting' a valid output and calling downstream nodes.
 During this PIPEUP state, the framework provides the same set of input parameters for each
 call, but provides different set of output parameters for each call.  During the STEADY state,
 the kernel may return a different set of output parameters than was given during the execution callback.
 Read-write. Can be written only before user-kernel finalization.
 Use a <code>vx_uint32</code> parameter.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>If not set, it will default to 1.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Setting a value less than 1 shall return VX_ERROR_INVALID_PARAMETERS</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="VX_KERNEL_PIPEUP_INPUT_DEPTH"></a>
<code>VX_KERNEL_PIPEUP_INPUT_DEPTH</code> - The pipeup depth required by the kernel.
 This is called by kernels that need to retain one or more input buffers before it can
 begin to return them.  A typical use case for this is a sink node which needs to provide and
 retain one ore more filled buffers to a display driver to display.  The first (pipeup_input_depth - 1)
 times the graph is executed after vxVerifyGraph is called, the framework calls the node associated with this kernel
 without 'expecting' an input to have been consumed and returned by the node.
 During this PIPEUP state, the framework does not reuse any of the input bufers it had given to this node.
 During the STEADY state, the kernel may return a different set of input parameters than was given during
 the execution callback.
 Read-write. Can be written only before user-kernel finalization.
 Use a <code>vx_uint32</code> parameter.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>If not set, it will default to 1.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Setting a value less than 1 shall return VX_ERROR_INVALID_PARAMETERS</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_functions_2">3.2.2. Functions</h4>
<div class="sect4">
<h5 id="_vxenablegraphstreaming">vxEnableGraphStreaming</h5>
<div class="paragraph">
<p>Enable streaming mode of graph execution.</p>
</div>
<div id="vxEnableGraphStreaming" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">vx_status vxEnableGraphStreaming(
    vx_graph                                    graph,
    vx_node                                     trigger_node);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This API enables streaming mode of graph execution on the given graph. This
function must be called before vxVerifyGraph.  The trigger_node parameter
indicates which node should be used as the trigger node in the case that the
graph is pipelined by the implementation.  A trigger node is defined as the
node whose completion causes a new execution of the graph to be triggered. If
the graph is not pipelined by the implementation, then the trigger_node
parameter is ignored and the graph will be re-triggered upon each graph
completion. The trigger_node parameter is optional, so if it is set to NULL,
then the trigger node is implementation dependent.</p>
</div>
<div class="paragraph">
<p><strong>Parameters</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[in]</code> <em>graph</em> - Reference to the graph to start streaming mode of
execution.</p>
</li>
<li>
<p><code>[in][optional]</code> <em>trigger_node</em> - Reference to the node to be used as trigger
node of the graph.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Returns:</strong> A <code>vx_status_e</code> enumeration.</p>
</div>
<div class="paragraph">
<p><strong>Return Values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VX_SUCCESS</code> - No errors; any other value indicates failure.</p>
</li>
<li>
<p><code>VX_ERROR_INVALID_REFERENCE</code> - <em>graph</em> is not a valid <code>vx_graph</code>
reference</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vxstartgraphstreaming">vxStartGraphStreaming</h5>
<div class="paragraph">
<p>Start streaming mode of graph execution.</p>
</div>
<div id="vxStartGraphStreaming" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">vx_status vxStartGraphStreaming(
    vx_graph                                    graph);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In streaming mode of graph execution, once an application starts graph
execution further intervention of the application is not needed to
re-schedule a graph; i.e. a graph re-schedules itself and executes
continuously until streaming mode of execution is stopped.</p>
</div>
<div class="paragraph">
<p>When this API is called, the framework schedules the graph via
<code>vxScheduleGraph</code> and returns. This graph gets re-scheduled continuously
until <code><a href="#vxStopGraphStreaming">vxStopGraphStreaming</a></code> is called by the user or any of the graph
nodes return error during execution.</p>
</div>
<div class="paragraph">
<p>The graph MUST be verified via <code>vxVerifyGraph</code> before calling this API. Also
user application MUST ensure no previous executions of the graph are
scheduled before calling this API.</p>
</div>
<div class="paragraph">
<p>After streaming mode of a graph has been started, a <code>vxScheduleGraph</code> should
<em>*not* be</em> used on that graph by an application.</p>
</div>
<div class="paragraph">
<p><code>vxWaitGraph</code> can be used as before to wait for all pending graph executions
to complete.</p>
</div>
<div class="paragraph">
<p><strong>Parameters</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[in]</code> <em>graph</em> - Reference to the graph to start streaming mode of
execution.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Returns:</strong> A <code>vx_status_e</code> enumeration.</p>
</div>
<div class="paragraph">
<p><strong>Return Values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VX_SUCCESS</code> - No errors; any other value indicates failure.</p>
</li>
<li>
<p><code>VX_ERROR_INVALID_REFERENCE</code> - <em>graph</em> is not a valid <code>vx_graph</code>
reference.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vxstopgraphstreaming">vxStopGraphStreaming</h5>
<div class="paragraph">
<p>Stop streaming mode of graph execution.</p>
</div>
<div id="vxStopGraphStreaming" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">vx_status vxStopGraphStreaming(
    vx_graph                                    graph);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function blocks until graph execution is gracefully stopped at a
logical boundary, for example, when all internally scheduled graph
executions are completed.</p>
</div>
<div class="paragraph">
<p><strong>Parameters</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[in]</code> <em>graph</em> - Reference to the graph to stop streaming mode of execution.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Returns:</strong> A <code>vx_status_e</code> enumeration.</p>
</div>
<div class="paragraph">
<p><strong>Return Values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VX_SUCCESS</code> - No errors; any other value indicates failure.</p>
</li>
<li>
<p><code>VX_FAILURE</code> - Graph is not started in streaming execution mode.</p>
</li>
<li>
<p><code>VX_ERROR_INVALID_REFERENCE</code> - graph is not a valid reference.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="group_event">3.3. Event Handling</h3>
<div class="paragraph">
<p><strong>Data Structures</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="#vx_event_graph_parameter_consumed">vx_event_graph_parameter_consumed</a></code></p>
</li>
<li>
<p><code><a href="#vx_event_graph_completed">vx_event_graph_completed</a></code></p>
</li>
<li>
<p><code><a href="#vx_event_node_completed">vx_event_node_completed</a></code></p>
</li>
<li>
<p><code><a href="#vx_event_node_error">vx_event_node_error</a></code></p>
</li>
<li>
<p><code><a href="#vx_event_user_event">vx_event_user_event</a></code></p>
</li>
<li>
<p><code><a href="#vx_event_t">vx_event_t</a></code></p>
</li>
<li>
<p><code><a href="#vx_event_info_t">vx_event_info_t</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Enumerations</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="#vx_event_enum_e">vx_event_enum_e</a></code></p>
</li>
<li>
<p><code><a href="#vx_event_type_e">vx_event_type_e</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Functions</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="#vxDisableEvents">vxDisableEvents</a></code></p>
</li>
<li>
<p><code><a href="#vxEnableEvents">vxEnableEvents</a></code></p>
</li>
<li>
<p><code><a href="#vxRegisterEvent">vxRegisterEvent</a></code></p>
</li>
<li>
<p><code><a href="#vxSendUserEvent">vxSendUserEvent</a></code></p>
</li>
<li>
<p><code><a href="#vxWaitEvent">vxWaitEvent</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This section lists the APIs required for event driven graph execution</p>
</div>
<div class="sect3">
<h4 id="_data_structures_2">3.3.1. Data Structures</h4>
<div class="sect4">
<h5 id="_vx_event_graph_parameter_consumed">vx_event_graph_parameter_consumed</h5>
<div class="paragraph">
<p>Parameter structure returned with event of type
<code><a href="#VX_EVENT_GRAPH_PARAMETER_CONSUMED">VX_EVENT_GRAPH_PARAMETER_CONSUMED</a></code>.</p>
</div>
<div id="vx_event_graph_parameter_consumed" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">typedef</span> <span class="keyword">struct</span> _vx_event_graph_parameter_consumed {
    vx_graph     graph;
    vx_uint32    graph_parameter_index;
} vx_event_graph_parameter_consumed;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>graph</em> -   graph which generated this event</p>
</li>
<li>
<p><em>graph_parameter_index</em> -   graph parameter index which generated this event</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vx_event_graph_completed">vx_event_graph_completed</h5>
<div class="paragraph">
<p>Parameter structure returned with event of type
<code><a href="#VX_EVENT_GRAPH_COMPLETED">VX_EVENT_GRAPH_COMPLETED</a></code>.</p>
</div>
<div id="vx_event_graph_completed" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">typedef</span> <span class="keyword">struct</span> _vx_event_graph_completed {
    vx_graph    graph;
} vx_event_graph_completed;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>graph</em> -   graph which generated this event</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vx_event_node_completed">vx_event_node_completed</h5>
<div class="paragraph">
<p>Parameter structure returned with event of type
<code><a href="#VX_EVENT_NODE_COMPLETED">VX_EVENT_NODE_COMPLETED</a></code>.</p>
</div>
<div id="vx_event_node_completed" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">typedef</span> <span class="keyword">struct</span> _vx_event_node_completed {
    vx_graph    graph;
    vx_node     node;
} vx_event_node_completed;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>graph</em> -   graph which generated this event</p>
</li>
<li>
<p><em>node</em> -   node which generated this event</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vx_event_node_error">vx_event_node_error</h5>
<div class="paragraph">
<p>Parameter structure returned with event of type
<code><a href="#VX_EVENT_NODE_ERROR">VX_EVENT_NODE_ERROR</a></code>.</p>
</div>
<div id="vx_event_node_error" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">typedef</span> <span class="keyword">struct</span> _vx_event_node_error {
    vx_graph     graph;
    vx_node      node;
    vx_status    status;
} vx_event_node_error;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>graph</em> -   graph which generated this event</p>
</li>
<li>
<p><em>node</em> -   node which generated this event</p>
</li>
<li>
<p><em>status</em> -   status of failed node</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vx_event_user_event">vx_event_user_event</h5>
<div class="paragraph">
<p>Parameter structure returned with event of type
<code><a href="#VX_EVENT_USER_EVENT">VX_EVENT_USER_EVENT</a></code>.</p>
</div>
<div id="vx_event_user_event" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">typedef</span> <span class="keyword">struct</span> _vx_event_user_event {
    <span class="directive">void</span> *    user_event_parameter;
} vx_event_user_event;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>user_event_parameter</em> -   User defined parameter value. This is used to pass additional user defined parameters with a user event.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vx_event_info_t">vx_event_info_t</h5>
<div class="paragraph">
<p>Parameter structure associated with an event. Depends on type of the event.</p>
</div>
<div id="vx_event_info_t" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">typedef</span> <span class="keyword">union</span> _vx_event_info_t {
    vx_event_graph_parameter_consumed    graph_parameter_consumed;
    vx_event_graph_completed             graph_completed;
    vx_event_node_completed              node_completed;
    vx_event_node_error                  node_error;
    vx_event_user_event                  user_event;
} vx_event_info_t;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>graph_parameter_consumed</em> - event information for type <code><a href="#VX_EVENT_GRAPH_PARAMETER_CONSUMED">VX_EVENT_GRAPH_PARAMETER_CONSUMED</a></code></p>
</li>
<li>
<p><em>graph_completed</em> - event information for type <code><a href="#VX_EVENT_GRAPH_COMPLETED">VX_EVENT_GRAPH_COMPLETED</a></code></p>
</li>
<li>
<p><em>node_completed</em> - event information for type <code><a href="#VX_EVENT_NODE_COMPLETED">VX_EVENT_NODE_COMPLETED</a></code></p>
</li>
<li>
<p><em>node_error</em> - event information for type <code><a href="#VX_EVENT_NODE_ERROR">VX_EVENT_NODE_ERROR</a></code></p>
</li>
<li>
<p><em>user_event</em> - event information for type <code><a href="#VX_EVENT_USER">VX_EVENT_USER</a></code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vx_event_t">vx_event_t</h5>
<div class="paragraph">
<p>Data structure which holds event information.</p>
</div>
<div id="vx_event_t" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">typedef</span> <span class="keyword">struct</span> _vx_event_t {
    vx_enum            type;
    vx_uint64          timestamp;
    vx_uint32          app_value;
    vx_event_info_t    event_info;
} vx_event_t;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>type</em> -   see event type <code><a href="#vx_event_type_e">vx_event_type_e</a></code></p>
</li>
<li>
<p><em>timestamp</em> -  time at which this event was generated, in units of nano-secs</p>
</li>
<li>
<p><em>app_value</em> -  value given to event by application during event registration (<code><a href="#vxRegisterEvent">vxRegisterEvent</a></code>) or
<code><a href="#vxSendUserEvent">vxSendUserEvent</a></code> in the case of user events.</p>
</li>
<li>
<p><em>event_info</em> -  parameter structure associated with an event. Depends on <em>type</em> of the event</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_enumerations_3">3.3.2. Enumerations</h4>
<div class="sect4">
<h5 id="_vx_event_enum_e">vx_event_enum_e</h5>
<div class="paragraph">
<p>Extra enums.</p>
</div>
<div id="vx_event_enum_e" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">enum</span> vx_event_enum_e {
    VX_ENUM_EVENT_TYPE = <span class="hex">0x22</span>,
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Enumerator</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="VX_ENUM_EVENT_TYPE"></a> <code>VX_ENUM_EVENT_TYPE</code> - Event
Type enumeration.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vx_event_type_e">vx_event_type_e</h5>
<div class="paragraph">
<p>Type of event that can be generated during system execution.</p>
</div>
<div id="vx_event_type_e" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="keyword">enum</span> vx_event_type_e {
    VX_EVENT_GRAPH_PARAMETER_CONSUMED = ((( VX_ID_KHRONOS ) &lt;&lt; <span class="integer">20</span>) | ( VX_ENUM_EVENT_TYPE &lt;&lt; <span class="integer">12</span>)) + <span class="hex">0x0</span>,
    VX_EVENT_GRAPH_COMPLETED = ((( VX_ID_KHRONOS ) &lt;&lt; <span class="integer">20</span>) | ( VX_ENUM_EVENT_TYPE &lt;&lt; <span class="integer">12</span>)) + <span class="hex">0x1</span>,
    VX_EVENT_NODE_COMPLETED = ((( VX_ID_KHRONOS ) &lt;&lt; <span class="integer">20</span>) | ( VX_ENUM_EVENT_TYPE &lt;&lt; <span class="integer">12</span>)) + <span class="hex">0x2</span>,
    VX_EVENT_NODE_ERROR = ((( VX_ID_KHRONOS ) &lt;&lt; <span class="integer">20</span>) | ( VX_ENUM_EVENT_TYPE &lt;&lt; <span class="integer">12</span>)) + <span class="hex">0x3</span>,
    VX_EVENT_USER = ((( VX_ID_KHRONOS ) &lt;&lt; <span class="integer">20</span>) | ( VX_ENUM_EVENT_TYPE &lt;&lt; <span class="integer">12</span>)) + <span class="hex">0x4</span>,
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Enumerator</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="VX_EVENT_GRAPH_PARAMETER_CONSUMED"></a>
<code>VX_EVENT_GRAPH_PARAMETER_CONSUMED</code> - Graph parameter consumed event.</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>This event is generated when a data reference at a graph parameter is
consumed during a graph execution. It is used to indicate that a given data
reference is no longer used by the graph and can be dequeued and accessed by
the application.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Graph execution could still be &#8220;in progress&#8221; for rest of the graph that
does not use this data reference.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p><a id="VX_EVENT_GRAPH_COMPLETED"></a>
<code>VX_EVENT_GRAPH_COMPLETED</code> - Graph completion event.</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>This event is generated every time a graph execution completes. Graph
completion event is generated for both successful execution of a graph or
abandoned execution of a graph.</p>
</div>
</div>
</div>
</li>
<li>
<p><a id="VX_EVENT_NODE_COMPLETED"></a>
<code>VX_EVENT_NODE_COMPLETED</code> - Node completion event.</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>This event is generated every time a node within a graph completes execution.</p>
</div>
</div>
</div>
</li>
<li>
<p><a id="VX_EVENT_NODE_ERROR"></a>
<code>VX_EVENT_NODE_ERROR</code> - Node error event.</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>This event is generated every time a node within a graph returns a run-time error.</p>
</div>
</div>
</div>
</li>
<li>
<p><a id="VX_EVENT_USER"></a> <code>VX_EVENT_USER</code> - User defined event.</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>This event is generated by user application outside of OpenVX framework
using the <code><a href="#vxSendUserEvent">vxSendUserEvent</a></code> API. User events allow application to have
single centralized &#8220;wait-for&#8221; loop to handle both framework generated events
as well as user generated events.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Note</div>
<div class="paragraph">
<p>Since the application initiates user events and not the framework, the application
does <strong>NOT</strong> register user events using <code><a href="#vxRegisterEvent">vxRegisterEvent</a></code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_functions_3">3.3.3. Functions</h4>
<div class="sect4">
<h5 id="_vxwaitevent">vxWaitEvent</h5>
<div class="paragraph">
<p>Wait for a single event.</p>
</div>
<div id="vxWaitEvent" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">vx_status vxWaitEvent(
    vx_context                                  context,
    vx_event_t *                                event,
    vx_bool                                     do_not_block);</code></pre>
</div>
</div>
<div class="paragraph">
<p>After <code><a href="#vxDisableEvents">vxDisableEvents</a></code> is called, if <code><a href="#vxWaitEvent">vxWaitEvent</a>(.., ..,
vx_false_e)</code> is called, <code><a href="#vxWaitEvent">vxWaitEvent</a></code> will remain blocked until events
are re-enabled using <code><a href="#vxEnableEvents">vxEnableEvents</a></code> and a new event is received.</p>
</div>
<div class="paragraph">
<p>If <code>vxReleaseContext</code> is called while an application is blocked on
<code><a href="#vxWaitEvent">vxWaitEvent</a></code>, the behavior is not defined by OpenVX.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#vxWaitEvent">vxWaitEvent</a></code> is called simultaneously from multiple thread/task
contexts then its behaviour is not defined by OpenVX.</p>
</div>
<div class="paragraph">
<p><strong>Parameters</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[in]</code> <em>context</em> - OpenVX context</p>
</li>
<li>
<p><code>[out]</code> <em>event</em> - Data structure which holds information about a received
event</p>
</li>
<li>
<p><code>[in]</code> <em>do_not_block</em> - When value is <code>vx_true_e</code> API does not block and
only checks for the condition</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Returns:</strong> A <code>vx_status_e</code> enumeration.</p>
</div>
<div class="paragraph">
<p><strong>Return Values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VX_SUCCESS</code> - Event received and event information available in
<em>event</em></p>
</li>
<li>
<p><code>VX_FAILURE</code> - No event is received</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vxenableevents">vxEnableEvents</h5>
<div class="paragraph">
<p>Enable event generation.</p>
</div>
<div id="vxEnableEvents" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">vx_status vxEnableEvents(
    vx_context                                  context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Depending on the implementation, events may be either enabled or disabled
by default.</p>
</div>
<div class="paragraph">
<p><strong>Parameters</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[in]</code> <em>context</em> - OpenVX context</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Returns:</strong> A <code>vx_status_e</code> enumeration.</p>
</div>
<div class="paragraph">
<p><strong>Return Values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VX_SUCCESS</code> - No errors; any other value indicates failure.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vxdisableevents">vxDisableEvents</h5>
<div class="paragraph">
<p>Disable event generation.</p>
</div>
<div id="vxDisableEvents" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">vx_status vxDisableEvents(
    vx_context                                  context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>When events are disabled, any event generated before this API is called will
still be returned via <code><a href="#vxWaitEvent">vxWaitEvent</a></code> API. However no additional events
would be returned via <code><a href="#vxWaitEvent">vxWaitEvent</a></code> API until events are enabled again.</p>
</div>
<div class="paragraph">
<p><strong>Parameters</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[in]</code> <em>context</em> - OpenVX context</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Returns:</strong> A <code>vx_status_e</code> enumeration.</p>
</div>
<div class="paragraph">
<p><strong>Return Values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VX_SUCCESS</code> - No errors; any other value indicates failure.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vxsenduserevent">vxSendUserEvent</h5>
<div class="paragraph">
<p>Generate user defined event.</p>
</div>
<div id="vxSendUserEvent" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">vx_status vxSendUserEvent(
    vx_context                                  context,
    vx_uint32                                   app_value,
    <span class="directive">void</span> *                                      parameter);</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Parameters</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[in]</code> <em>context</em> - OpenVX context</p>
</li>
<li>
<p><code>[in]</code> <em>app_value</em> - User defined value. NOT used by implementation.
Returned to user as part of <code><a href="#vx_event_t">vx_event_t</a>.app_value</code> field.</p>
</li>
<li>
<p><code>[in]</code> <em>parameter</em> - User defined event parameter. NOT used
by implementation. Returned to user as part
<code><a href="#vx_event_t">vx_event_t</a>.event_info.user_event.user_event_parameter</code> field</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Returns:</strong> A <code>vx_status_e</code> enumeration.</p>
</div>
<div class="paragraph">
<p><strong>Return Values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VX_SUCCESS</code> - No errors; any other value indicates failure.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_vxregisterevent">vxRegisterEvent</h5>
<div class="paragraph">
<p>Register an event to be generated.</p>
</div>
<div id="vxRegisterEvent" class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">vx_status vxRegisterEvent(
    vx_reference                                ref,
    vx_event_type_e                             type,
    vx_uint32                                   param,
    vx_uint32                                   app_value);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Generation of event may need additional resources and overheads for an
implementation. Hence events should be registered for references only when
really required by an application.</p>
</div>
<div class="paragraph">
<p>This API can be called on graph, node, or graph parameter. This API MUST be
called before doing <code>vxVerifyGraph</code> for that graph.</p>
</div>
<div class="paragraph">
<p><strong>Parameters</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[in]</code> <em>ref</em> - Reference which will generate the event</p>
</li>
<li>
<p><code>[in]</code> <em>type</em> - Type or condition on which the event is generated</p>
</li>
<li>
<p><code>[in]</code> <em>param</em> - Specifies the graph parameter index when <em>type</em> is
<code><a href="#VX_EVENT_GRAPH_PARAMETER_CONSUMED">VX_EVENT_GRAPH_PARAMETER_CONSUMED</a></code></p>
</li>
<li>
<p><code>[in]</code> <em>app_value</em> - Application-specified value that will be returned
to user as part of <code><a href="#vx_event_t">vx_event_t</a>.app_value</code> field. NOT used by implementation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Returns:</strong> A <code>vx_status_e</code> enumeration.</p>
</div>
<div class="paragraph">
<p><strong>Return Values</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VX_SUCCESS</code> - No errors; any other value indicates failure.</p>
</li>
<li>
<p><code>VX_ERROR_INVALID_REFERENCE</code> - <em>ref</em> is not a valid <code>vx_reference</code>
reference.</p>
</li>
<li>
<p><code>VX_ERROR_NOT_SUPPORTED</code> - <em>type</em> is not valid for the provided
reference.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conformance">4. Conformance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For the purposes of claiming conformance for features introduced in this
extension, Khronos has split the conformance tests into two parts. This
way, an implementation may choose to claim conformance to one part, or cover
the entire extension by passing the conformance test for both parts.  This section
identifies these two conformance profiles:</p>
</div>
<div class="sect2">
<h3 id="_pipelining_batch_processing_event_handling">4.1. Pipelining, Batch Processing, Event Handling</h3>
<div class="paragraph">
<p>By enabling the <strong>OPENVX_USE_PIPELINING</strong> compile option in the conformance
tests, the implementation will be tested on all APIs mentioned in both sections
<a href="#group_pipelining">Pipelining and Batch Processing</a> and <a href="#group_event">Event Handling</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_streaming">4.2. Streaming</h3>
<div class="paragraph">
<p>By enabling the <strong>OPENVX_USE_STREAMING</strong> compile option in the conformance
tests, the implementation will be tested on all APIs mentioned in section
<a href="#group_streaming">Streaming</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.1.0<br>
Last updated 2019-04-10 14:17:13 UTC
</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>
